This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-02-05 22:56:10

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
core
  autoloads
    battle_data_manager.gd
    debug_overlay.gd
    dialogue_manager.gd
    event_bus.gd
    game_manager.gd
    game_root.gd
    game_root.tscn
    global_logger.gd
    scene_loader.gd
    team_manager.gd
    ui_manager.gd
    version_manager.gd
  data
    ability_data_loader.gd
    json_data_loader.gd
    model_validator.gd
    scene_registry.gd
    validation_result.gd
  dialogue
    bark_system.gd
    dialogue_box.gd
    dialogue_data.gd
  game_root.tscn
features
  debug
    debug_version_panel.gd
  menu
    main_menu.gd
    main_menu.tscn
```

# Repository Files


## core/autoloads/battle_data_manager.gd

```text
# scripts/core/battle_data_manager.gd
extends Node
## BattleDataManager - Gestionnaire centralis√© des donn√©es de combat
## Autoload d√©di√© au stockage et √† la validation des donn√©es de bataille
## 
## Responsabilit√©s :
## - Stocker les donn√©es du combat actuel
## - Valider la structure des donn√©es
## - Fournir un acc√®s thread-safe
## - Nettoyer apr√®s usage
##
## Acc√®s via : GameRoot.battle_data_manager

class_name BattleDataManagerClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal battle_data_stored(battle_id: String)
signal battle_data_cleared()
signal battle_data_invalid(errors: Array)

# ============================================================================
# DONN√âES
# ============================================================================

var _current_battle_data: Dictionary = {}
var _is_data_valid: bool = false
var _battle_id: String = ""

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# Attendre que GameRoot soit pr√™t
	call_deferred("_connect_signals")
	print("[BattleDataManager] ‚úÖ Initialis√©")

func _connect_signals() -> void:
	"""Connexion aux signaux de GameRoot"""
	await get_tree().process_frame
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("battle_ended", _on_battle_ended)

# ============================================================================
# STOCKAGE
# ============================================================================

## Stocke les donn√©es d'un combat
func set_battle_data(data: Dictionary) -> bool:
	"""
	Stocke les donn√©es de combat apr√®s validation
	
	@param data : Dictionnaire contenant les donn√©es de combat
	@return true si stockage r√©ussi, false si donn√©es invalides
	"""
	
	var result = ModelValidator.validate(data, "battle")

	if not result.is_valid:
		if GameRoot and GameRoot.global_logger:
			GameRoot.global_logger.error("BATTLE_DATA", "Validation √©chou√©e : " + str(result.errors))
		push_error("[BattleDataManager] ‚ùå Donn√©es invalides : ", result.errors)
		battle_data_invalid.emit(result.errors)
		return false

	# üî• IMPORTANT : r√©cup√©rer les donn√©es normalis√©es
	_current_battle_data = result.data.duplicate(true)
	_is_data_valid = true
	_battle_id = data.get("battle_id", "unknown_" + str(Time.get_unix_time_from_system()))
	
	print("[BattleDataManager] ‚úÖ Donn√©es stock√©es : ", _battle_id)
	battle_data_stored.emit(_battle_id)
	
	return true

## R√©cup√®re les donn√©es du combat actuel
func get_battle_data() -> Dictionary:
	"""
	Retourne les donn√©es du combat actuel
	
	@return Dictionary avec les donn√©es, ou {} si aucune donn√©e valide
	"""
	
	if not _is_data_valid:
		push_warning("[BattleDataManager] ‚ö†Ô∏è Aucune donn√©e de combat valide")
		return {}
	
	print("[BattleDataManager] üì¶ R√©cup√©ration des donn√©es : ", _battle_id)
	return _current_battle_data.duplicate(true)

## V√©rifie si des donn√©es sont disponibles
func has_battle_data() -> bool:
	"""V√©rifie si des donn√©es de combat valides sont stock√©es"""
	return _is_data_valid and not _current_battle_data.is_empty()

## R√©cup√®re l'ID du combat actuel
func get_battle_id() -> String:
	"""Retourne l'ID du combat actuel"""
	return _battle_id

# ============================================================================
# NETTOYAGE
# ============================================================================

## Efface les donn√©es du combat actuel
func clear_battle_data() -> void:
	"""
	Nettoie les donn√©es de combat
	Appel√© automatiquement apr√®s la bataille
	"""
	
	if _is_data_valid:
		print("[BattleDataManager] üßπ Nettoyage des donn√©es : ", _battle_id)
	
	_current_battle_data.clear()
	_is_data_valid = false
	_battle_id = ""
	
	battle_data_cleared.emit()

## Efface les donn√©es de mani√®re forc√©e (emergency)
func force_clear() -> void:
	"""Nettoyage forc√© en cas d'erreur critique"""
	push_warning("[BattleDataManager] ‚ö†Ô∏è Nettoyage forc√© des donn√©es")
	clear_battle_data()


# ============================================================================
# DEBUG
# ============================================================================

## Affiche les donn√©es actuelles (debug)
func debug_print_data() -> void:
	"""Affiche les donn√©es de combat pour debug"""
	
	if not _is_data_valid:
		print("[BattleDataManager] üêõ Aucune donn√©e √† afficher")
		return
	
	print("\n=== BattleDataManager DEBUG ===")
	print("Battle ID : ", _battle_id)
	print("Player Units : ", _current_battle_data.get("player_units", []).size())
	print("Enemy Units : ", _current_battle_data.get("enemy_units", []).size())
	print("Terrain : ", _current_battle_data.get("terrain", "N/A"))
	print("================================\n")

## Retourne les statistiques du combat actuel
func get_battle_stats() -> Dictionary:
	"""Retourne des statistiques sur le combat actuel"""
	
	if not _is_data_valid:
		return {}
	
	return {
		"battle_id": _battle_id,
		"player_unit_count": _current_battle_data.get("player_units", []).size(),
		"enemy_unit_count": _current_battle_data.get("enemy_units", []).size(),
		"has_objectives": _current_battle_data.has("objectives"),
		"has_scenario": _current_battle_data.has("scenario"),
		"terrain_type": _current_battle_data.get("terrain", "unknown")
	}

# ============================================================================
# CALLBACKS
# ============================================================================

func _on_battle_ended(_results: Dictionary) -> void:
	"""Nettoyage automatique apr√®s la fin du combat"""
	clear_battle_data()

func _exit_tree() -> void:
	"""Nettoyage √† la fermeture"""
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
	
func _normalize_battle_data(data: Dictionary) -> void:
	# Player units
	if data.has("player_units"):
		for unit in data.player_units:
			# HP ‚Üí int
			unit.current_hp = int(unit.current_hp)
			unit.max_hp = int(unit.max_hp)

			# Position [x, y] ‚Üí Vector2i
			if unit.has("position") and unit.position is Array and unit.position.size() == 2:
				unit.position = Vector2i(
					int(unit.position[0]),
					int(unit.position[1])
				)

	# Enemy units
	if data.has("enemy_units"):
		for unit in data.enemy_units:
			unit.current_hp = int(unit.current_hp)
			unit.max_hp = int(unit.max_hp)

			if unit.has("position") and unit.position is Array and unit.position.size() == 2:
				unit.position = Vector2i(
					int(unit.position[0]),
					int(unit.position[1])
				)

	# Obstacles
	if data.has("terrain_obstacles"):
		for obs in data.terrain_obstacles:
			if obs.has("position") and obs.position is Array and obs.position.size() == 2:
				obs.position = Vector2i(
					int(obs.position[0]),
					int(obs.position[1])
				)
```

## core/autoloads/debug_overlay.gd

```text
extends CanvasLayer
## DebugOverlay - Interface de debug en jeu (F3)
## Affiche les informations de debug, FPS, √©tat du jeu
##
## Acc√®s via : GameRoot.debug_overlay

class_name DebugOverlayClass

# ============================================================================
# CONFIGURATION
# ============================================================================

const PANEL_WIDTH: int = 450
const PANEL_MIN_HEIGHT: int = 400

# ============================================================================
# R√âF√âRENCES UI
# ============================================================================

var panel: PanelContainer = null
var info_label: RichTextLabel = null
var log_label: RichTextLabel = null

# ============================================================================
# √âTAT
# ============================================================================

var is_visible: bool = false
var watched_variables: Dictionary = {}  # key -> { object: Node, property: String }
var show_logs: bool = true

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	layer = 110  # Au-dessus de tout
	name = "DebugOverlay"
	
	_create_ui()
	visible = false
	
	print("[DebugOverlay] ‚úÖ Initialis√© (F3 pour afficher)")

func _create_ui() -> void:
	"""Cr√©e l'interface de debug"""
	
	# Panel principal
	panel = PanelContainer.new()
	panel.name = "DebugPanel"
	panel.position = Vector2(10, 10)
	panel.custom_minimum_size = Vector2(PANEL_WIDTH, PANEL_MIN_HEIGHT)
	
	# Style du panel
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.05, 0.05, 0.1, 0.9)
	style.border_width_left = 2
	style.border_width_top = 2
	style.border_width_right = 2
	style.border_width_bottom = 2
	style.border_color = Color(0.3, 0.3, 0.5)
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	panel.add_theme_stylebox_override("panel", style)
	
	add_child(panel)
	
	# Margin
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 15)
	margin.add_theme_constant_override("margin_top", 15)
	margin.add_theme_constant_override("margin_right", 15)
	margin.add_theme_constant_override("margin_bottom", 15)
	panel.add_child(margin)
	
	# VBox pour organiser
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 10)
	margin.add_child(vbox)
	
	# Label d'info principal
	info_label = RichTextLabel.new()
	info_label.bbcode_enabled = true
	info_label.fit_content = true
	info_label.scroll_active = false
	info_label.custom_minimum_size = Vector2(0, 200)
	vbox.add_child(info_label)
	
	# S√©parateur
	var separator = HSeparator.new()
	vbox.add_child(separator)
	
	# Label des logs r√©cents
	var log_title = Label.new()
	log_title.text = "üìú Logs r√©cents"
	log_title.add_theme_color_override("font_color", Color(0.7, 0.7, 0.9))
	vbox.add_child(log_title)
	
	var scroll = ScrollContainer.new()
	scroll.custom_minimum_size = Vector2(0, 150)
	scroll.size_flags_vertical = Control.SIZE_EXPAND_FILL
	vbox.add_child(scroll)
	
	log_label = RichTextLabel.new()
	log_label.bbcode_enabled = true
	log_label.fit_content = true
	log_label.scroll_active = false
	scroll.add_child(log_label)

# ============================================================================
# VISIBILIT√â
# ============================================================================

func toggle_visibility() -> void:
	"""Inverse la visibilit√© de l'overlay"""
	is_visible = not is_visible
	visible = is_visible

func show_overlay() -> void:
	"""Affiche l'overlay"""
	is_visible = true
	visible = true

func hide_overlay() -> void:
	"""Cache l'overlay"""
	is_visible = false
	visible = false

# ============================================================================
# MISE √Ä JOUR
# ============================================================================

func _process(_delta: float) -> void:
	if not is_visible:
		return
	
	_update_display()

func _update_display() -> void:
	"""Met √† jour l'affichage"""
	
	var text = "[b][color=cyan]‚ïê‚ïê‚ïê DEBUG OVERLAY ‚ïê‚ïê‚ïê[/color][/b]\n\n"
	
	# Performance
	text += "[b][color=yellow]Performance[/color][/b]\n"
	text += "  FPS: [color=lime]%d[/color]\n" % Engine.get_frames_per_second()
	
	var mem_static = OS.get_static_memory_usage() / 1024.0 / 1024.0
	text += "  M√©moire: [color=lime]%.2f MB[/color]\n\n" % mem_static
	
	# GameRoot Status (via autoload)
	if GameRoot:
		text += "[b][color=yellow]GameRoot[/color][/b]\n"
		text += "  EventBus: %s\n" % _status_icon(GameRoot.event_bus != null)
		text += "  SceneLoader: %s\n" % _status_icon(GameRoot.scene_loader != null)
		text += "  GameManager: %s\n" % _status_icon(GameRoot.game_manager != null)
		text += "  UIManager: %s\n" % _status_icon(GameRoot.ui_manager != null)
		text += "  GlobalLogger: %s\n\n" % _status_icon(GameRoot.global_logger != null)
		
		# Sc√®ne actuelle
		if GameRoot.scene_loader:
			var scene_name = GameRoot.scene_loader.get_current_scene_name()
			var is_loading = GameRoot.scene_loader.is_loading
			text += "[b][color=yellow]Sc√®ne[/color][/b]\n"
			text += "  Actuelle: [color=white]%s[/color]\n" % scene_name
			text += "  Loading: %s\n\n" % _status_icon(is_loading, "üîÑ", "‚úÖ")
		
		# √âtat du jeu
		if GameRoot.game_manager:
			text += "[b][color=yellow]√âtat[/color][/b]\n"
			text += "  Pause: %s\n\n" % _status_icon(GameRoot.game_manager.is_paused, "‚è∏Ô∏è", "‚ñ∂Ô∏è")
	
	# Variables surveill√©es
	if not watched_variables.is_empty():
		text += "[b][color=yellow]Variables[/color][/b]\n"
		
		for key in watched_variables:
			var entry = watched_variables[key]
			var obj = entry.object
			var prop = entry.property
			
			if is_instance_valid(obj):
				var value = obj.get(prop)
				if value != null:
					text += "  [color=cyan]%s:[/color] %s\n" % [key, _format_value(value)]
		
		text += "\n"
	
	info_label.text = text
	
	# Logs r√©cents
	if show_logs and GameRoot and GameRoot.global_logger:
		var log_text = ""
		var recent_logs = GameRoot.global_logger.get_recent_logs(10)
		
		for entry in recent_logs:
			var color = "white"
			match entry.level:
				GlobalLoggerClass.LogLevel.DEBUG:
					color = "gray"
				GlobalLoggerClass.LogLevel.WARNING:
					color = "yellow"
				GlobalLoggerClass.LogLevel.ERROR:
					color = "red"
			
			log_text += "[color=%s][%s] %s[/color]\n" % [color, entry.category, entry.message]
		
		log_label.text = log_text

func _status_icon(condition: bool, true_icon: String = "‚úÖ", false_icon: String = "‚ùå") -> String:
	return true_icon if condition else false_icon

func _format_value(value: Variant) -> String:
	"""Formate une valeur pour l'affichage"""
	
	if value is Array:
		return "Array[%d]" % value.size()
	elif value is Dictionary:
		return "Dict[%d]" % value.size()
	elif value is Vector2 or value is Vector2i:
		return "(%s, %s)" % [value.x, value.y]
	elif value is Vector3:
		return "(%.1f, %.1f, %.1f)" % [value.x, value.y, value.z]
	else:
		return str(value)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func watch_variable(key: String, object: Node, property: String) -> void:
	"""Surveille une variable pour l'afficher dans l'overlay"""
	watched_variables[key] = {"object": object, "property": property}

func unwatch_variable(key: String) -> void:
	"""Arr√™te de surveiller une variable"""
	watched_variables.erase(key)

func clear_watched() -> void:
	"""Supprime toutes les variables surveill√©es"""
	watched_variables.clear()

func set_show_logs(show: bool) -> void:
	"""Active/d√©sactive l'affichage des logs"""
	show_logs = show

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	# Le toggle est g√©r√© par GameRoot
	pass
```

## core/autoloads/dialogue_manager.gd

```text
extends Node
## Dialogue_Manager - Gestionnaire central du syst√®me de dialogue
## Autoload qui orchestre tous les dialogues du jeu
##
## Acc√®s via : GameRoot.dialogue_manager

class_name DialogueManagerClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal dialogue_started(dialogue_id: String)
signal dialogue_line_shown(line_data: Dictionary)
signal dialogue_choices_shown(choices: Array)
signal dialogue_choice_selected(choice_index: int)
signal dialogue_ended(dialogue_id: String)
signal bark_requested(speaker: String, text: String, position: Vector2)

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var default_text_speed: float = 50.0  # Caract√®res par seconde
@export var default_auto_advance_delay: float = 2.0
@export var enable_skip: bool = true
@export var enable_auto_mode: bool = false
@export var dialogue_sfx_volume: float = 0.0  # dB

# Configuration du temps de lecture
@export var reading_speed_chars_per_second: float = 15.0
@export var minimum_reading_time: float = 1.5
@export var maximum_reading_time: float = 8.0

# ============================================================================
# √âTAT
# ============================================================================

var current_dialogue = null  # DialogueData
var current_line_index: int = 0
var is_dialogue_active: bool = false
var dialogue_box = null  # DialogueBox
var bark_system = null  # BarkSystem

var text_speed: float = 50.0
var auto_mode: bool = false
var is_skippable: bool = true

# Historique
var dialogue_history: Array[Dictionary] = []
var max_history_size: int = 100

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	text_speed = default_text_speed
	auto_mode = enable_auto_mode
	
	# Cr√©er le BarkSystem si la classe existe
	if ClassDB.class_exists("BarkSystem"):
		bark_system = ClassDB.instantiate("BarkSystem")
		add_child(bark_system)
	
	call_deferred("_connect_to_event_bus")
	
	print("[DialogueManager] ‚úÖ Initialis√© - auto_mode: ", auto_mode)

func _connect_to_event_bus() -> void:
	"""Connexion aux √©v√©nements globaux"""
	await get_tree().process_frame
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("dialogue_started", _on_eventbus_dialogue_started)
		GameRoot.event_bus.safe_connect("dialogue_ended", _on_eventbus_dialogue_ended)

# ============================================================================
# CHARGEMENT DE DIALOGUES
# ============================================================================

func start_dialogue(dialogue, dialogue_box_instance = null) -> void:
	"""D√©marre un nouveau dialogue"""
	
	if is_dialogue_active:
		push_warning("[DialogueManager] Un dialogue est d√©j√† en cours")
		return
	
	if not dialogue or dialogue.lines.is_empty():
		push_error("[DialogueManager] Dialogue invalide ou vide")
		return
	
	current_dialogue = dialogue
	current_line_index = 0
	is_dialogue_active = true
	
	# Utiliser la DialogueBox fournie
	dialogue_box = dialogue_box_instance
	
	if not dialogue_box:
		push_error("[DialogueManager] Aucune DialogueBox fournie")
		end_dialogue()
		return
	
	# Configurer la DialogueBox
	dialogue_box.dialogue_manager = self
	dialogue_box.show_dialogue_box()
	
	# Se connecter au signal de r√©v√©lation du texte
	if dialogue_box.has_signal("text_reveal_completed"):
		if not dialogue_box.text_reveal_completed.is_connected(_on_text_reveal_completed):
			dialogue_box.text_reveal_completed.connect(_on_text_reveal_completed)
	
	# √âmettre les signaux
	dialogue_started.emit(dialogue.dialogue_id)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.dialogue_started.emit(dialogue.dialogue_id)
	
	# Afficher la premi√®re ligne
	show_current_line()
	
	print("[DialogueManager] ‚úÖ Dialogue d√©marr√© : ", dialogue.dialogue_id)
	
func start_dialogue_from_id(dialogue_id: String, dialogue_box_instance = null) -> void:
	"""D√©marre un dialogue √† partir de son ID"""
	
	# TODO: Impl√©menter un syst√®me de registre de dialogues
	push_warning("[DialogueManager] start_dialogue_from_id non impl√©ment√©")

# ============================================================================
# AFFICHAGE DES LIGNES
# ============================================================================

func show_current_line() -> void:
	"""Affiche la ligne actuelle du dialogue"""
	
	if not current_dialogue or current_line_index >= current_dialogue.lines.size():
		end_dialogue()
		return
	
	var line = current_dialogue.lines[current_line_index]
	
	print("[DialogueManager] üìñ Ligne ", current_line_index + 1, "/", current_dialogue.lines.size())
	
	# Ajouter √† l'historique
	_add_to_history(line)
	
	# Si c'est un choix
	if line.has("choices") and not line.choices.is_empty():
		show_choices(line.choices)
		return
	
	# Si c'est un √©v√©nement
	if line.has("event"):
		_trigger_event(line.event)
		advance_dialogue()
		return
	
	# Affichage normal
	dialogue_box.display_line(line)
	
	# √âmettre le signal
	dialogue_line_shown.emit(line)

func _calculate_reading_time(line: Dictionary) -> float:
	"""Calcule le temps de lecture optimal pour une ligne de dialogue"""
	
	if line.has("auto_delay"):
		return line.auto_delay
	
	var text = line.get("text", "")
	var text_key = line.get("text_key", "")
	
	if text_key:
		text = tr(text_key)
	
	var clean_text = _strip_bbcode(text)
	var char_count = clean_text.length()
	
	var reveal_speed = line.get("speed", default_text_speed)
	var reveal_time = char_count / reveal_speed
	var reading_time = char_count / reading_speed_chars_per_second
	var total_time = reveal_time + reading_time
	
	total_time = clamp(total_time, minimum_reading_time, maximum_reading_time)
	
	return total_time

func _strip_bbcode(text: String) -> String:
	"""Retire les balises BBCode pour obtenir le texte brut"""
	var regex = RegEx.new()
	regex.compile("\\[[\\/]?[^\\]]*\\]")
	return regex.sub(text, "", true)

func show_choices(choices: Array) -> void:
	"""Affiche des choix au joueur"""
	
	dialogue_box.display_choices(choices)
	dialogue_choices_shown.emit(choices)

func select_choice(choice_index: int) -> void:
	"""S√©lectionne un choix"""
	
	var line = current_dialogue.lines[current_line_index]
	
	if not line.has("choices") or choice_index >= line.choices.size():
		push_error("[DialogueManager] Index de choix invalide")
		return
	
	var choice = line.choices[choice_index]
	
	# √âmettre le signal
	dialogue_choice_selected.emit(choice_index)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.choice_made.emit(current_dialogue.dialogue_id, choice_index)
	
	# Ex√©cuter l'action du choix
	if choice.has("next_line"):
		current_line_index = choice.next_line
		show_current_line()
	elif choice.has("end_dialogue") and choice.end_dialogue:
		end_dialogue()
	else:
		advance_dialogue()

# ============================================================================
# NAVIGATION
# ============================================================================

func advance_dialogue() -> void:
	"""Avance √† la ligne suivante"""
	
	if not is_dialogue_active:
		return
	
	# Si le texte est en train d'appara√Ætre, le compl√©ter
	if dialogue_box and dialogue_box.is_text_revealing:
		dialogue_box.complete_text()
		return
	
	current_line_index += 1
	
	if current_line_index >= current_dialogue.lines.size():
		end_dialogue()
	else:
		show_current_line()

func skip_dialogue() -> void:
	"""Skip le dialogue entier (si autoris√©)"""
	
	if not is_skippable or not enable_skip:
		return
	
	end_dialogue()

func end_dialogue() -> void:
	"""Termine le dialogue actuel"""
	
	if not is_dialogue_active:
		return
	
	var dialogue_id = current_dialogue.dialogue_id if current_dialogue else ""
	
	is_dialogue_active = false
	
	# D√©connecter les signaux
	if dialogue_box and dialogue_box.has_signal("text_reveal_completed"):
		if dialogue_box.text_reveal_completed.is_connected(_on_text_reveal_completed):
			dialogue_box.text_reveal_completed.disconnect(_on_text_reveal_completed)
	
	if dialogue_box:
		dialogue_box.hide_dialogue_box()
	
	# √âmettre les signaux
	dialogue_ended.emit(dialogue_id)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.dialogue_ended.emit(dialogue_id)
	
	# Nettoyer
	current_dialogue = null
	current_line_index = 0
	
	print("[DialogueManager] üèÅ Dialogue termin√© : ", dialogue_id)

# ============================================================================
# BARKS (Messages courts)
# ============================================================================

func show_bark(speaker: String, text_key: String, world_position: Vector2, duration: float = 2.0) -> void:
	"""Affiche un bark (message court) au-dessus d'un personnage"""
	
	if not bark_system:
		push_warning("[DialogueManager] BarkSystem non initialis√©")
		return
	
	var translated_text = tr(text_key)
	bark_system.show_bark(speaker, translated_text, world_position, duration)
	
	bark_requested.emit(speaker, translated_text, world_position)

# ============================================================================
# √âV√âNEMENTS
# ============================================================================

func _trigger_event(event_data: Dictionary) -> void:
	"""D√©clenche un √©v√©nement personnalis√©"""
	
	var event_type = event_data.get("type", "")
	
	match event_type:
		"set_variable":
			var key = event_data.get("key", "")
			var value = event_data.get("value", null)
			if key:
				print("[DialogueManager] Variable set : ", key, " = ", value)
		
		"play_sound":
			var sound_path = event_data.get("sound", "")
			if sound_path:
				print("[DialogueManager] Play sound : ", sound_path)
		
		"trigger_battle":
			var battle_id = event_data.get("battle_id", "")
			if battle_id and GameRoot and GameRoot.event_bus:
				GameRoot.event_bus.notify("D√©clenchement du combat : " + battle_id, "info")
		
		_:
			print("[DialogueManager] √âv√©nement inconnu : ", event_type)

# ============================================================================
# HISTORIQUE
# ============================================================================

func _add_to_history(line: Dictionary) -> void:
	"""Ajoute une ligne √† l'historique"""
	
	dialogue_history.append(line.duplicate())
	
	while dialogue_history.size() > max_history_size:
		dialogue_history.pop_front()

func get_history() -> Array[Dictionary]:
	"""Retourne l'historique des dialogues"""
	return dialogue_history.duplicate()

func clear_history() -> void:
	"""Efface l'historique"""
	dialogue_history.clear()

# ============================================================================
# CONFIGURATION
# ============================================================================

func set_text_speed(speed: float) -> void:
	"""Change la vitesse du texte"""
	text_speed = clamp(speed, 10.0, 200.0)

func set_auto_mode(enabled: bool) -> void:
	"""Active/d√©sactive le mode auto"""
	auto_mode = enabled

func toggle_auto_mode() -> void:
	"""Bascule le mode auto"""
	auto_mode = not auto_mode
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Mode auto: " + ("ON" if auto_mode else "OFF"), "info")

# ============================================================================
# HELPERS
# ============================================================================

func is_active() -> bool:
	"""V√©rifie si un dialogue est actif"""
	return is_dialogue_active

# ============================================================================
# CALLBACKS
# ============================================================================

func _on_eventbus_dialogue_started(_dialogue_id: String) -> void:
	pass

func _on_eventbus_dialogue_ended(_dialogue_id: String) -> void:
	pass

func _on_text_reveal_completed() -> void:
	"""Appel√© quand le texte est compl√®tement r√©v√©l√©"""
	
	if not is_dialogue_active or not current_dialogue:
		return
	
	var line = current_dialogue.lines[current_line_index]
	
	if auto_mode and line.get("auto_advance", false):
		var delay = _calculate_reading_time(line)
		
		get_tree().create_timer(delay).timeout.connect(
			func():
				if is_dialogue_active and current_line_index < current_dialogue.lines.size():
					advance_dialogue()
		)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## core/autoloads/event_bus.gd

```text
extends Node
## EventBus - Hub de communication global d√©coupl√©
## Permet aux sc√®nes de communiquer sans d√©pendances directes
##
## Acc√®s via : GameRoot.event_bus

class_name EventBusClass

# ============================================================================
# SIGNAUX GLOBAUX DU JEU
# ============================================================================

# --- Syst√®me ---
signal game_started()
signal game_paused(paused: bool)
signal game_saved(save_name: String)
signal game_loaded(save_name: String)
signal settings_changed(settings: Dictionary)

# --- Navigation ---
signal scene_change_requested(scene_id: int)
signal return_to_menu_requested()
signal quit_game_requested()

# --- Combat ---
signal battle_started(battle_data: Variant)
signal battle_ended(results: Dictionary)
signal duo_formed(unit_a: Node, unit_b: Node)
signal duo_broken(unit_a: Node, unit_b: Node)
signal unit_attacked(attacker: Node, target: Node, damage: int)
signal unit_died(unit: Node)
signal turn_started(unit: Node)
signal turn_ended(unit: Node)

# --- Statistiques & Progression ---
signal stats_updated(unit: Node, stat_name: String, new_value: float)
signal threat_level_changed(duo: Array, new_threat: float)
signal legend_gained(duo: Array, legend_type: String)
signal title_unlocked(unit: Node, title: String)
signal mvp_awarded(unit: Node, battle_id: String)

# --- Divinit√©s (Syst√®me de Foi) ---
signal divine_points_gained(god_name: String, points: int)
signal divine_threshold_reached(god_name: String, threshold: int)
signal divine_event_triggered(god_name: String, event_data: Dictionary)

# --- Monde & Narration ---
signal dialogue_started(dialogue_id: String)
signal dialogue_ended(dialogue_id: String)
signal choice_made(choice_id: String, option: int)
signal cutscene_started(cutscene_id: String)
signal cutscene_ended(cutscene_id: String)
signal location_discovered(location_name: String)
signal quest_updated(quest_id: String, status: String)

# --- Ressources ---
signal gold_changed(new_amount: int)
signal item_gained(item_id: String, quantity: int)
signal item_lost(item_id: String, quantity: int)

# --- UI ---
signal notification_posted(message: String, type: String)
signal tooltip_requested(content: String, position: Vector2)
signal tooltip_hidden()

# --- Dialogue ---
signal dialogue_bark_requested(speaker: String, text_key: String, position: Vector2)
signal dialogue_typewriter_completed()
signal dialogue_skip_requested()

# --- Campagne ---
signal campaign_started()
signal campaign_completed()
signal chapter_changed(chapter_id: int)

# --- Data Loading ---
signal data_loaded(data_type: String, data: Dictionary)
signal data_load_warning(data_type: String, warning: String)
signal ability_reloaded(ability_id: String)

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	print("[EventBus] ‚úÖ Initialis√©")

# ============================================================================
# M√âTHODES UTILITAIRES
# ============================================================================

func emit_event(event_name: String, args: Array = [], debug: bool = false) -> void:
	"""√âmet un signal par son nom avec des arguments"""
	
	if not has_signal(event_name):
		push_warning("[EventBus] Signal introuvable : %s" % event_name)
		return
	
	if debug:
		print("[EventBus] √âmission : %s avec args : %s" % [event_name, args])
	
	callv("emit_signal", [event_name] + args)

func safe_connect(signal_name: String, callable: Callable, flags: int = 0) -> void:
	"""Connexion s√©curis√©e avec v√©rification"""
	
	if not has_signal(signal_name):
		push_error("[EventBus] Impossible de connecter √† un signal inexistant : %s" % signal_name)
		return
	
	if is_connected(signal_name, callable):
		push_warning("[EventBus] D√©j√† connect√© : %s" % signal_name)
		return
	
	connect(signal_name, callable, flags)

func safe_disconnect(signal_name: String, callable: Callable) -> void:
	"""D√©connexion s√©curis√©e"""
	
	if not has_signal(signal_name):
		return
	
	if is_connected(signal_name, callable):
		disconnect(signal_name, callable)

func disconnect_all(object: Object) -> void:
	"""D√©connexion de tous les signaux d'un objet"""
	
	for signal_dict in get_signal_list():
		var sig_name = signal_dict["name"]
		var connections = get_signal_connection_list(sig_name)
		
		for connection in connections:
			if connection["callable"].get_object() == object:
				disconnect(sig_name, connection["callable"])

# ============================================================================
# HELPERS SP√âCIFIQUES AU JEU
# ============================================================================

func notify(message: String, type: String = "info") -> void:
	"""Notification simple"""
	notification_posted.emit(message, type)

func change_scene(scene_id: int) -> void:
	"""Changement de sc√®ne via EventBus"""
	scene_change_requested.emit(scene_id)

func add_divine_points(god: String, points: int) -> void:
	"""Mise √† jour des statistiques divines"""
	divine_points_gained.emit(god, points)

func form_duo(unit_a: Node, unit_b: Node) -> void:
	"""Formation de duo"""
	duo_formed.emit(unit_a, unit_b)

func break_duo(unit_a: Node, unit_b: Node) -> void:
	"""Rupture de duo"""
	duo_broken.emit(unit_a, unit_b)

func attack(attacker: Node, target: Node, damage: int) -> void:
	"""Attaque d'unit√©"""
	unit_attacked.emit(attacker, target, damage)

func end_battle(results: Dictionary) -> void:
	"""Fin de combat"""
	battle_ended.emit(results)

func show_bark(speaker: String, text_key: String, position: Vector2) -> void:
	"""Affiche un bark de dialogue"""
	dialogue_bark_requested.emit(speaker, text_key, position)

func start_battle(battle_id: String) -> void:
	"""√âmet le signal de d√©but de combat"""
	print("[EventBus] üé¨ D√©but du combat : %s" % battle_id)
	battle_started.emit(battle_id)

# ============================================================================
# DEBUG
# ============================================================================

func debug_list_connections() -> void:
	"""Liste toutes les connexions actives (debug)"""
	
	print("\n=== EventBus - Connexions actives ===")
	
	for signal_dict in get_signal_list():
		var sig_name = signal_dict["name"]
		var connections = get_signal_connection_list(sig_name)
		
		if connections.size() > 0:
			print("\n[%s] : %d connexions" % [sig_name, connections.size()])
			for connection in connections:
				var target = connection["callable"].get_object()
				var method = connection["callable"].get_method()
				print("  -> %s.%s" % [target.name if target else "null", method])
	
	print("\n=====================================\n")
```

## core/autoloads/game_manager.gd

```text
extends Node
## GameManager - Orchestration du cycle de vie du jeu
## G√®re l'√©tat du jeu, les sauvegardes, la pause
##
## Acc√®s via : GameRoot.game_manager

class_name GameManagerClass

# ============================================================================
# R√âF√âRENCES (assign√©es par GameRoot)
# ============================================================================

var scene_loader: SceneLoaderClass = null

# ============================================================================
# √âTAT DU JEU
# ============================================================================

var game_state: Dictionary = {}
var is_paused: bool = false
var campaign_manager = null  # √Ä cr√©er si n√©cessaire

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	print("[GameManager] ‚úÖ Initialis√©")

# ============================================================================
# GESTION DE LA PAUSE
# ============================================================================

func pause_game(paused: bool) -> void:
	"""Met le jeu en pause ou le reprend"""
	
	is_paused = paused
	get_tree().paused = paused
	
	# Notifier via EventBus
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.game_paused.emit(paused)
	
	print("[GameManager] Jeu %s" % ("en pause" if paused else "repris"))

func toggle_pause() -> void:
	"""Inverse l'√©tat de pause"""
	pause_game(not is_paused)

# ============================================================================
# SAUVEGARDE / CHARGEMENT
# ============================================================================

func save_game(save_name: String) -> void:
	"""Sauvegarde l'√©tat du jeu"""
	
	game_state["timestamp"] = Time.get_unix_time_from_system()
	game_state["scene_id"] = scene_loader.current_scene_id if scene_loader else -1
	
	# Cr√©er le dossier saves s'il n'existe pas
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("saves"):
		dir.make_dir("saves")
	
	var save_path = "user://saves/%s.save" % save_name
	var file = FileAccess.open(save_path, FileAccess.WRITE)
	
	if file:
		file.store_string(JSON.stringify(game_state, "\t"))
		file.close()
		
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.game_saved.emit(save_name)
			GameRoot.event_bus.notify("Partie sauvegard√©e : %s" % save_name, "success")
		
		print("[GameManager] üíæ Sauvegarde : %s" % save_name)
	else:
		push_error("[GameManager] Impossible de sauvegarder")

func load_game(save_name: String) -> void:
	"""Charge une sauvegarde"""
	
	var save_path = "user://saves/%s.save" % save_name
	
	if not FileAccess.file_exists(save_path):
		push_error("[GameManager] Sauvegarde introuvable : %s" % save_name)
		return
	
	var file = FileAccess.open(save_path, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		game_state = json.data
		
		# Charger la sc√®ne sauvegard√©e
		var saved_scene_id = game_state.get("scene_id", -1)
		if saved_scene_id != -1 and scene_loader:
			scene_loader.load_scene_by_id(saved_scene_id)
		
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.game_loaded.emit(save_name)
			GameRoot.event_bus.notify("Partie charg√©e : %s" % save_name, "success")
		
		print("[GameManager] üìÇ Chargement : %s" % save_name)
	else:
		push_error("[GameManager] Erreur lors du chargement de la sauvegarde")

func has_save(save_name: String) -> bool:
	"""V√©rifie si une sauvegarde existe"""
	return FileAccess.file_exists("user://saves/%s.save" % save_name)

func get_save_list() -> Array[String]:
	"""Retourne la liste des sauvegardes disponibles"""
	
	var saves: Array[String] = []
	var save_dir = "user://saves/"
	
	if not DirAccess.dir_exists_absolute(save_dir):
		return saves
	
	var dir = DirAccess.open(save_dir)
	dir.list_dir_begin()
	
	var file_name = dir.get_next()
	while file_name != "":
		if file_name.ends_with(".save"):
			saves.append(file_name.get_basename())
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return saves

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_game_started() -> void:
	"""Callback quand une nouvelle partie d√©marre"""
	
	print("[GameManager] üéÆ Nouvelle partie d√©marr√©e")
	
	# Charger la sc√®ne d'intro ou la world map
	if scene_loader:
		# V√©rifier si la sc√®ne d'intro existe
		if SceneRegistry.scene_exists(SceneRegistry.SceneID.INTRO_DIALOGUE):
			scene_loader.load_scene_by_id(SceneRegistry.SceneID.INTRO_DIALOGUE, true)
		else:
			scene_loader.load_scene_by_id(SceneRegistry.SceneID.WORLD_MAP, true)

func _on_game_paused(paused: bool) -> void:
	"""Callback quand le jeu est mis en pause"""
	
	if paused != is_paused:
		is_paused = paused
		get_tree().paused = paused
	
	print("[GameManager] %s" % ("‚è∏Ô∏è Pause" if paused else "‚ñ∂Ô∏è Reprise"))

func _on_quit_game_requested() -> void:
	"""Callback pour quitter le jeu"""
	
	print("[GameManager] üö™ Fermeture du jeu...")
	
	# Sauvegarder automatiquement ?
	# save_game("auto_save")
	
	get_tree().quit()

func _on_return_to_menu_requested() -> void:
	"""Retour au menu principal"""
	
	print("[GameManager] üè† Retour au menu principal")
	
	is_paused = false
	get_tree().paused = false
	
	if scene_loader:
		scene_loader.load_scene_by_id(SceneRegistry.SceneID.MAIN_MENU)

# ============================================================================
# GETTERS
# ============================================================================

func get_current_scene() -> Node:
	"""Retourne la sc√®ne actuelle"""
	return scene_loader.current_scene if scene_loader else null

func get_current_scene_id() -> int:
	"""Retourne l'ID de la sc√®ne actuelle"""
	return scene_loader.current_scene_id if scene_loader else -1

func is_loading() -> bool:
	"""V√©rifie si un chargement est en cours"""
	return scene_loader.is_loading if scene_loader else false

# ============================================================================
# DEBUG
# ============================================================================

func _input(event: InputEvent) -> void:
	if OS.is_debug_build():
		# Debug : Afficher l'√©tat
		if event.is_action_pressed("ui_end"):
			print_status()

func print_status() -> void:
	"""Affiche l'√©tat du GameManager"""
	
	print("\n=== GameManager Status ===")
	print("  Sc√®ne : %s" % (SceneRegistry.get_scene_name(get_current_scene_id()) if get_current_scene_id() != -1 else "N/A"))
	print("  Pause : %s" % is_paused)
	print("  Loading : %s" % is_loading())
	print("===========================\n")
```

## core/autoloads/game_root.gd

```text
extends Node
## GameRoot - Point d'entr√©e unique du jeu
## Sc√®ne autoload principale qui instancie et expose tous les syst√®mes globaux
##
## Configuration : Ajouter GameRoot.tscn comme autoload nomm√© "GameRoot"
## Acc√®s : GameRoot.event_bus, GameRoot.scene_loader, etc.

class_name GameRootClass

# ============================================================================
# R√âF√âRENCES EXPOS√âES (acc√®s via GameRoot.xxx)
# ============================================================================

var event_bus: EventBusClass = null
var scene_loader: SceneLoaderClass = null
var game_manager: GameManagerClass = null
var ui_manager: UIManagerClass = null
var debug_overlay: DebugOverlayClass = null
var global_logger: GlobalLoggerClass = null
var battle_data_manager: BattleDataManagerClass = null
var dialogue_manager: DialogueManagerClass = null
var version_manager: VersionManagerClass = null
var team_manager = null  # TeamManager n'a pas de class_name typ√©

# ============================================================================
# CONTENEUR DE SC√àNES
# ============================================================================

var scene_container: Node = null
var current_scene: Node = null

# ============================================================================
# CONFIGURATION DES SCRIPTS
# ============================================================================

const SCRIPTS = {
	"event_bus": "res://core/autoloads/event_bus.gd",
	"global_logger": "res://core/autoloads/global_logger.gd",
	"scene_loader": "res://core/autoloads/scene_loader.gd",
	"game_manager": "res://core/autoloads/game_manager.gd",
	"ui_manager": "res://core/autoloads/ui_manager.gd",
	"debug_overlay": "res://core/autoloads/debug_overlay.gd",
	"battle_data_manager": "res://core/autoloads/battle_data_manager.gd",
	"dialogue_manager": "res://core/autoloads/dialogue_manager.gd",
	"version_manager": "res://core/autoloads/version_manager.gd",
	"team_manager": "res://core/autoloads/team_manager.gd"
}

# ============================================================================
# √âTAT
# ============================================================================

var _is_initialized: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	if _is_initialized:
		push_warning("[GameRoot] D√©j√† initialis√©, skip")
		return
	
	name = "GameRoot"
	
	print("========================================")
	print("  GAME ROOT - Initialisation")
	print("========================================")
	
	# Ordre d'initialisation important !
	_setup_scene_container()
	_initialize_core_systems()
	_initialize_managers()
	_initialize_ui_systems()
	_connect_systems()
	_check_migrations()
	
	_is_initialized = true
	
	print("========================================")
	print("  GAME ROOT - Pr√™t !")
	print("========================================")
	
	# Charger la sc√®ne initiale
	call_deferred("_load_initial_scene")

func _setup_scene_container() -> void:
	"""Configure le conteneur de sc√®nes (cr√©√© dans la .tscn ou dynamiquement)"""
	
	# Chercher le SceneContainer existant dans la sc√®ne
	scene_container = get_node_or_null("SceneContainer")
	
	if not scene_container:
		# Cr√©er dynamiquement si non pr√©sent dans la sc√®ne
		scene_container = Node.new()
		scene_container.name = "SceneContainer"
		add_child(scene_container)
		print("[GameRoot]   ‚Üí SceneContainer cr√©√© dynamiquement")
	else:
		print("[GameRoot]   ‚Üí SceneContainer trouv√© dans la sc√®ne")

func _initialize_core_systems() -> void:
	"""Initialise les syst√®mes de base (EventBus, Logger)"""
	
	# 1. Global Logger (en premier pour les logs)
	global_logger = _create_system("global_logger", "GlobalLogger") as GlobalLoggerClass
	
	# 2. Event Bus (communication globale)
	event_bus = _create_system("event_bus", "EventBus") as EventBusClass
	
	print("[GameRoot] ‚úÖ Syst√®mes de base initialis√©s")

func _initialize_managers() -> void:
	"""Initialise les managers principaux"""
	
	# 3. Scene Loader
	scene_loader = _create_system("scene_loader", "SceneLoader") as SceneLoaderClass
	scene_loader.scene_container = scene_container
	
	# 4. Game Manager
	game_manager = _create_system("game_manager", "GameManager") as GameManagerClass
	game_manager.scene_loader = scene_loader
	
	# 5. Battle Data Manager
	battle_data_manager = _create_system("battle_data_manager", "BattleDataManager") as BattleDataManagerClass
	
	# 6. Dialogue Manager
	dialogue_manager = _create_system("dialogue_manager", "DialogueManager") as DialogueManagerClass
	
	# 7. Version Manager
	version_manager = _create_system("version_manager", "VersionManager") as VersionManagerClass
	
	# 8. Team Manager
	team_manager = _create_system("team_manager", "TeamManager")
	
	print("[GameRoot] ‚úÖ Managers initialis√©s")

func _initialize_ui_systems() -> void:
	"""Initialise les syst√®mes UI (au-dessus des sc√®nes)"""
	
	# 9. UI Manager (CanvasLayer pour UI globale)
	ui_manager = _create_system("ui_manager", "UIManager") as UIManagerClass
	
	# 10. Debug Overlay (en dernier, layer le plus haut) - seulement en debug
	if OS.is_debug_build():
		debug_overlay = _create_system("debug_overlay", "DebugOverlay") as DebugOverlayClass
	
	print("[GameRoot] ‚úÖ Syst√®mes UI initialis√©s")

func _create_system(key: String, node_name: String) -> Node:
	"""Cr√©e et ajoute un syst√®me depuis son script.
	D√©tecte automatiquement le type natif h√©rit√© (Node, CanvasLayer, etc.)"""
	
	var script_path = SCRIPTS.get(key, "")
	
	if script_path == "":
		push_error("[GameRoot] Cl√© de script introuvable : %s" % key)
		return null
	
	if not ResourceLoader.exists(script_path):
		push_error("[GameRoot] Script introuvable : %s" % script_path)
		return null
	
	var script = load(script_path)
	if not script:
		push_error("[GameRoot] √âchec du chargement du script : %s" % script_path)
		return null
	
	# üî• FIX : D√©tecter le type natif h√©rit√© par le script
	# pour instancier le bon type de base (Node, CanvasLayer, etc.)
	var base_type: String = script.get_instance_base_type()
	var instance: Node
	
	match base_type:
		"CanvasLayer":
			instance = CanvasLayer.new()
		"Control":
			instance = Control.new()
		"Node2D":
			instance = Node2D.new()
		"Node3D":
			instance = Node3D.new()
		_:
			instance = Node.new()
	
	instance.set_script(script)
	instance.name = node_name
	
	add_child(instance)
	
	print("[GameRoot]   ‚Üí %s charg√© (%s)" % [node_name, base_type])
	return instance

func _connect_systems() -> void:
	"""Connecte les syst√®mes entre eux via l'EventBus"""
	
	if not event_bus:
		push_error("[GameRoot] EventBus non initialis√©, impossible de connecter les syst√®mes")
		return
	
	# Connecter SceneLoader aux √©v√©nements
	if scene_loader:
		event_bus.safe_connect("scene_change_requested", scene_loader._on_scene_change_requested)
	
	# Connecter GameManager aux √©v√©nements
	if game_manager:
		event_bus.safe_connect("game_started", game_manager._on_game_started)
		event_bus.safe_connect("game_paused", game_manager._on_game_paused)
		event_bus.safe_connect("quit_game_requested", game_manager._on_quit_game_requested)
		event_bus.safe_connect("return_to_menu_requested", game_manager._on_return_to_menu_requested)
	
	# Connecter UIManager aux notifications
	if ui_manager:
		event_bus.safe_connect("notification_posted", ui_manager._on_notification_posted)
	
	print("[GameRoot] ‚úÖ Syst√®mes connect√©s")

func _check_migrations() -> void:
	"""V√©rifie et applique les migrations de donn√©es si n√©cessaire"""
	
	if version_manager:
		version_manager.check_and_migrate()

func _load_initial_scene() -> void:
	"""Charge la sc√®ne initiale (menu principal)"""
	
	if scene_loader:
		# V√©rifier si le menu principal existe
		if SceneRegistry.scene_exists(SceneRegistry.SceneID.MAIN_MENU):
			scene_loader.load_scene_by_id(SceneRegistry.SceneID.MAIN_MENU, false)
		else:
			push_warning("[GameRoot] Menu principal non trouv√©, aucune sc√®ne charg√©e")

# ============================================================================
# CALLBACKS SC√àNE (appel√©s par SceneLoader)
# ============================================================================

func _on_scene_loaded(scene: Node) -> void:
	"""Appel√© par SceneLoader quand une nouvelle sc√®ne est charg√©e"""
	current_scene = scene
	
	if global_logger:
		global_logger.info("SCENE", "Sc√®ne charg√©e : %s" % scene.name)

func _on_scene_unloaded() -> void:
	"""Appel√© par SceneLoader quand la sc√®ne actuelle est d√©charg√©e"""
	current_scene = null

# ============================================================================
# API PUBLIQUE (Raccourcis)
# ============================================================================

## Raccourci pour changer de sc√®ne
func change_scene(scene_id: int, transition: bool = true) -> void:
	if scene_loader:
		scene_loader.load_scene_by_id(scene_id, transition)

## Raccourci pour changer de sc√®ne par chemin
func change_scene_by_path(scene_path: String, transition: bool = true) -> void:
	if scene_loader:
		scene_loader.load_scene(scene_path, transition)

## Raccourci pour √©mettre une notification
func notify(message: String, type: String = "info") -> void:
	if event_bus:
		event_bus.notify(message, type)

## Raccourci pour logger
func log_info(category: String, message: String) -> void:
	if global_logger:
		global_logger.info(category, message)

func log_debug(category: String, message: String) -> void:
	if global_logger:
		global_logger.debug(category, message)

func log_warning(category: String, message: String) -> void:
	if global_logger:
		global_logger.warning(category, message)

func log_error(category: String, message: String) -> void:
	if global_logger:
		global_logger.error(category, message)

# ============================================================================
# GETTERS POUR COMPATIBILIT√â
# ============================================================================

func get_current_scene() -> Node:
	"""Retourne la sc√®ne actuellement charg√©e"""
	return current_scene

func get_current_scene_id() -> int:
	"""Retourne l'ID de la sc√®ne actuelle"""
	return scene_loader.current_scene_id if scene_loader else -1

func is_loading() -> bool:
	"""V√©rifie si un chargement est en cours"""
	return scene_loader.is_loading if scene_loader else false

func is_initialized() -> bool:
	"""V√©rifie si GameRoot est compl√®tement initialis√©"""
	return _is_initialized

# ============================================================================
# ACC√àS AUX SYST√àMES (pour compatibilit√© avec l'ancien code)
# ============================================================================

func get_event_bus() -> EventBusClass:
	return event_bus

func get_scene_loader() -> SceneLoaderClass:
	return scene_loader

func get_game_manager() -> GameManagerClass:
	return game_manager

func get_ui_manager() -> UIManagerClass:
	return ui_manager

func get_global_logger() -> GlobalLoggerClass:
	return global_logger

func get_battle_data_manager() -> BattleDataManagerClass:
	return battle_data_manager

func get_dialogue_manager() -> DialogueManagerClass:
	return dialogue_manager

# ============================================================================
# DEBUG
# ============================================================================

func _input(event: InputEvent) -> void:
	if OS.is_debug_build():
		# Toggle debug overlay avec F3
		if event.is_action_pressed("debug_toggle") and debug_overlay:
			debug_overlay.toggle_visibility()

func print_status() -> void:
	"""Affiche l'√©tat de tous les syst√®mes"""
	
	print("\n=== GameRoot Status ===")
	print("  Initialized: ", _is_initialized)
	print("  EventBus: ", "OK" if event_bus else "NULL")
	print("  GlobalLogger: ", "OK" if global_logger else "NULL")
	print("  SceneLoader: ", "OK" if scene_loader else "NULL")
	print("  GameManager: ", "OK" if game_manager else "NULL")
	print("  UIManager: ", "OK" if ui_manager else "NULL")
	print("  BattleDataManager: ", "OK" if battle_data_manager else "NULL")
	print("  DialogueManager: ", "OK" if dialogue_manager else "NULL")
	print("  VersionManager: ", "OK" if version_manager else "NULL")
	print("  TeamManager: ", "OK" if team_manager else "NULL")
	print("  DebugOverlay: ", "OK" if debug_overlay else "N/A (release)")
	print("  SceneContainer: ", "OK" if scene_container else "NULL")
	print("  CurrentScene: ", current_scene.name if current_scene else "None")
	print("========================\n")

func debug_list_children() -> void:
	"""Liste tous les enfants de GameRoot (debug)"""
	
	print("\n=== GameRoot Children ===")
	for child in get_children():
		print("  - ", child.name, " (", child.get_class(), ")")
	print("=========================\n")
```

## core/autoloads/game_root.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://gameroot001"]

[ext_resource type="Script" path="res://core/autoloads/game_root.gd" id="1_gameroot"]

[node name="GameRoot" type="Node"]
script = ExtResource("1_gameroot")

[node name="SceneContainer" type="Node" parent="."]
```

## core/autoloads/global_logger.gd

```text
extends Node
## GlobalLogger - Syst√®me de logging centralis√©
## G√®re les logs avec cat√©gories, niveaux et formatage
##
## Acc√®s via : GameRoot.global_logger

class_name GlobalLoggerClass

# ============================================================================
# CONFIGURATION
# ============================================================================

enum LogLevel {
	DEBUG = 0,
	INFO = 1,
	WARNING = 2,
	ERROR = 3,
	NONE = 4
}

const LOG_COLORS = {
	LogLevel.DEBUG: "gray",
	LogLevel.INFO: "white",
	LogLevel.WARNING: "yellow",
	LogLevel.ERROR: "red"
}

const LOG_PREFIXES = {
	LogLevel.DEBUG: "üîç",
	LogLevel.INFO: "‚ÑπÔ∏è",
	LogLevel.WARNING: "‚ö†Ô∏è",
	LogLevel.ERROR: "‚ùå"
}

# ============================================================================
# √âTAT
# ============================================================================

var min_log_level: LogLevel = LogLevel.DEBUG
var enabled_categories: Dictionary = {}  # category -> bool
var log_to_file: bool = false
var log_file_path: String = "user://logs/game.log"
var log_file: FileAccess = null

# Historique des logs (pour debug overlay)
var log_history: Array[Dictionary] = []
var max_history: int = 100

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# En release, ne logger que les warnings et erreurs
	if not OS.is_debug_build():
		min_log_level = LogLevel.WARNING
	
	# Activer toutes les cat√©gories par d√©faut
	_enable_default_categories()
	
	print("[GlobalLogger] ‚úÖ Initialis√© (niveau: %s)" % LogLevel.keys()[min_log_level])

func _enable_default_categories() -> void:
	"""Active les cat√©gories de log par d√©faut"""
	
	var categories = [
		"GAME", "BATTLE", "UI", "SCENE", "SAVE",
		"AUDIO", "NETWORK", "AI", "DIALOGUE", "EVENT",
		"BATTLE_DATA", "TEAM"
	]
	
	for cat in categories:
		enabled_categories[cat] = true

# ============================================================================
# API PUBLIQUE
# ============================================================================

func debug(category: String, message: String) -> void:
	"""Log de niveau DEBUG"""
	_log(LogLevel.DEBUG, category, message)

func info(category: String, message: String) -> void:
	"""Log de niveau INFO"""
	_log(LogLevel.INFO, category, message)

func warning(category: String, message: String) -> void:
	"""Log de niveau WARNING"""
	_log(LogLevel.WARNING, category, message)

func error(category: String, message: String) -> void:
	"""Log de niveau ERROR"""
	_log(LogLevel.ERROR, category, message)

# ============================================================================
# LOGGING INTERNE
# ============================================================================

func _log(level: LogLevel, category: String, message: String) -> void:
	"""Fonction de logging principale"""
	
	# V√©rifier le niveau minimum
	if level < min_log_level:
		return
	
	# V√©rifier si la cat√©gorie est activ√©e (sauf pour ERROR)
	if level != LogLevel.ERROR:
		if enabled_categories.has(category) and not enabled_categories[category]:
			return
	
	# Formater le message
	var timestamp = Time.get_time_string_from_system()
	var prefix = LOG_PREFIXES.get(level, "")
	var formatted = "[%s] %s [%s] %s" % [timestamp, prefix, category, message]
	
	# Afficher dans la console
	match level:
		LogLevel.DEBUG:
			print(formatted)
		LogLevel.INFO:
			print(formatted)
		LogLevel.WARNING:
			push_warning(formatted)
		LogLevel.ERROR:
			push_error(formatted)
	
	# Ajouter √† l'historique
	_add_to_history(level, category, message, timestamp)
	
	# √âcrire dans le fichier si activ√©
	if log_to_file:
		_write_to_file(formatted)

func _add_to_history(level: LogLevel, category: String, message: String, timestamp: String) -> void:
	"""Ajoute un log √† l'historique"""
	
	log_history.append({
		"level": level,
		"category": category,
		"message": message,
		"timestamp": timestamp
	})
	
	# Limiter la taille
	while log_history.size() > max_history:
		log_history.pop_front()

func _write_to_file(message: String) -> void:
	"""√âcrit un message dans le fichier de log"""
	
	if not log_file:
		_open_log_file()
	
	if log_file:
		log_file.store_line(message)
		log_file.flush()

func _open_log_file() -> void:
	"""Ouvre le fichier de log"""
	
	# Cr√©er le dossier si n√©cessaire
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("logs"):
		dir.make_dir("logs")
	
	log_file = FileAccess.open(log_file_path, FileAccess.WRITE)
	
	if log_file:
		log_file.store_line("=== Game Log - %s ===" % Time.get_datetime_string_from_system())
		log_file.store_line("")

# ============================================================================
# CONFIGURATION
# ============================================================================

func set_log_level(level: LogLevel) -> void:
	"""D√©finit le niveau minimum de log"""
	min_log_level = level
	info("GAME", "Niveau de log chang√© : %s" % LogLevel.keys()[level])

func enable_category(category: String, enabled: bool = true) -> void:
	"""Active ou d√©sactive une cat√©gorie"""
	enabled_categories[category] = enabled

func enable_file_logging(enabled: bool = true, path: String = "") -> void:
	"""Active ou d√©sactive le logging dans un fichier"""
	
	log_to_file = enabled
	
	if path != "":
		log_file_path = path
	
	if enabled:
		_open_log_file()
		info("GAME", "Logging fichier activ√© : %s" % log_file_path)
	elif log_file:
		log_file.close()
		log_file = null

# ============================================================================
# UTILITAIRES
# ============================================================================

func get_recent_logs(count: int = 20, level_filter: LogLevel = LogLevel.DEBUG) -> Array[Dictionary]:
	"""Retourne les logs r√©cents filtr√©s par niveau"""
	
	var filtered: Array[Dictionary] = []
	
	for i in range(log_history.size() - 1, -1, -1):
		var entry = log_history[i]
		if entry.level >= level_filter:
			filtered.append(entry)
			if filtered.size() >= count:
				break
	
	filtered.reverse()
	return filtered

func get_logs_by_category(category: String, count: int = 20) -> Array[Dictionary]:
	"""Retourne les logs d'une cat√©gorie sp√©cifique"""
	
	var filtered: Array[Dictionary] = []
	
	for i in range(log_history.size() - 1, -1, -1):
		var entry = log_history[i]
		if entry.category == category:
			filtered.append(entry)
			if filtered.size() >= count:
				break
	
	filtered.reverse()
	return filtered

func clear_history() -> void:
	"""Vide l'historique des logs"""
	log_history.clear()

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if log_file:
		log_file.store_line("")
		log_file.store_line("=== Session termin√©e ===")
		log_file.close()
```

## core/autoloads/scene_loader.gd

```text
extends Node
## SceneLoader - Chargement et transition de sc√®nes
## Charge les sc√®nes dans le SceneContainer de GameRoot
##
## Acc√®s via : GameRoot.scene_loader

class_name SceneLoaderClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal scene_loading_started(scene_path: String)
signal scene_loading_progress(progress: float)
signal scene_loaded(scene: Node)
signal scene_transition_finished()

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var fade_duration: float = 0.3
@export var debug_mode: bool = true

# ============================================================================
# R√âF√âRENCES
# ============================================================================

var scene_container: Node = null  # Assign√© par GameRoot
var transition_overlay: ColorRect = null

# ============================================================================
# √âTAT
# ============================================================================

var current_scene: Node = null
var current_scene_id: int = -1
var is_loading: bool = false
var loading_progress: float = 0.0

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	call_deferred("_setup_transition_overlay")
	print("[SceneLoader] ‚úÖ Initialis√©")

func _setup_transition_overlay() -> void:
	"""Cr√©e l'overlay de transition dans l'UIManager"""
	
	# Attendre que l'UIManager soit pr√™t
	await get_tree().process_frame
	
	if GameRoot and GameRoot.ui_manager:
		transition_overlay = GameRoot.ui_manager.create_transition_overlay()
	else:
		# Fallback : cr√©er localement
		_create_local_overlay()
	
	if debug_mode:
		print("[SceneLoader] ‚úÖ Overlay de transition configur√©")

func _create_local_overlay() -> void:
	"""Cr√©e un overlay local (fallback)"""
	
	var canvas = CanvasLayer.new()
	canvas.layer = 100
	add_child(canvas)
	
	transition_overlay = ColorRect.new()
	transition_overlay.color = Color.BLACK
	transition_overlay.set_anchors_preset(Control.PRESET_FULL_RECT)
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	transition_overlay.modulate.a = 0.0
	canvas.add_child(transition_overlay)

# ============================================================================
# CHARGEMENT DE SC√àNE
# ============================================================================

func load_scene_by_id(scene_id: int, transition: bool = true) -> void:
	"""Charge une sc√®ne via son ID du registre"""
	
	if not SceneRegistry.scene_exists(scene_id):
		push_error("[SceneLoader] Sc√®ne introuvable : %d" % scene_id)
		return
	
	var scene_path = SceneRegistry.get_scene_path(scene_id)
	current_scene_id = scene_id
	
	if debug_mode:
		print("[SceneLoader] üé¨ Chargement : %s" % SceneRegistry.get_scene_name(scene_id))
	
	await load_scene(scene_path, transition)

func load_scene(scene_path: String, transition: bool = true) -> void:
	"""Charge une sc√®ne par son chemin"""
	
	if is_loading:
		push_warning("[SceneLoader] Chargement d√©j√† en cours")
		return
	
	if not ResourceLoader.exists(scene_path):
		push_error("[SceneLoader] Sc√®ne introuvable : %s" % scene_path)
		return
	
	is_loading = true
	scene_loading_started.emit(scene_path)
	
	if debug_mode:
		print("[SceneLoader] üé¨ D√©but du chargement : %s" % scene_path)
	
	# Transition sortante
	if transition:
		await _fade_out()
	
	# Nettoyer la sc√®ne actuelle
	_cleanup_current_scene()
	
	# Charger la nouvelle sc√®ne
	var new_scene = await _load_scene_async(scene_path)
	
	if new_scene == null:
		push_error("[SceneLoader] √âchec du chargement : %s" % scene_path)
		is_loading = false
		if transition:
			await _fade_in()
		return
	
	# Ajouter la sc√®ne au container
	if scene_container:
		scene_container.add_child(new_scene)
	else:
		push_error("[SceneLoader] SceneContainer non d√©fini !")
		get_tree().root.add_child(new_scene)
	
	current_scene = new_scene
	
	# Mettre √† jour la r√©f√©rence dans GameRoot
	if GameRoot:
		GameRoot.current_scene = new_scene
		GameRoot._on_scene_loaded(new_scene)
	
	scene_loaded.emit(new_scene)
	
	# Transition entrante
	if transition:
		await _fade_in()
	
	is_loading = false
	scene_transition_finished.emit()
	
	if debug_mode:
		print("[SceneLoader] ‚úÖ Sc√®ne charg√©e : %s" % scene_path)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _cleanup_current_scene() -> void:
	"""Supprime la sc√®ne actuelle"""
	
	if not scene_container:
		return
	
	for child in scene_container.get_children():
		if debug_mode:
			print("[SceneLoader] üóëÔ∏è Suppression : %s" % child.name)
		child.queue_free()
	
	current_scene = null
	
	# Notifier GameRoot
	if GameRoot:
		GameRoot._on_scene_unloaded()
	
	# Attendre le nettoyage
	await get_tree().process_frame

# ============================================================================
# CHARGEMENT ASYNCHRONE
# ============================================================================

func _load_scene_async(scene_path: String) -> Node:
	"""Chargement asynchrone avec progression"""
	
	var status = ResourceLoader.load_threaded_request(scene_path)
	
	if status != OK:
		push_error("[SceneLoader] Erreur lors de la requ√™te de chargement")
		return null
	
	while true:
		var progress_array = []
		status = ResourceLoader.load_threaded_get_status(scene_path, progress_array)
		
		if status == ResourceLoader.THREAD_LOAD_LOADED:
			var packed_scene = ResourceLoader.load_threaded_get(scene_path)
			return packed_scene.instantiate()
		
		elif status == ResourceLoader.THREAD_LOAD_FAILED:
			push_error("[SceneLoader] √âchec du chargement threaded")
			return null
		
		elif status == ResourceLoader.THREAD_LOAD_INVALID_RESOURCE:
			push_error("[SceneLoader] Ressource invalide")
			return null
		
		# Mettre √† jour la progression
		if progress_array.size() > 0:
			loading_progress = progress_array[0]
			scene_loading_progress.emit(loading_progress)
			
			# Notifier l'UIManager
			if GameRoot and GameRoot.ui_manager:
				GameRoot.ui_manager.update_loading_progress(loading_progress)
		
		await get_tree().process_frame
	
	return null

# ============================================================================
# TRANSITIONS VISUELLES
# ============================================================================

func _fade_out() -> void:
	"""Fondu vers le noir"""
	
	if not transition_overlay:
		return
	
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_STOP
	
	var tween = create_tween()
	tween.tween_property(transition_overlay, "modulate:a", 1.0, fade_duration)
	await tween.finished

func _fade_in() -> void:
	"""Fondu depuis le noir"""
	
	if not transition_overlay:
		return
	
	var tween = create_tween()
	tween.tween_property(transition_overlay, "modulate:a", 0.0, fade_duration)
	await tween.finished
	
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_scene_change_requested(scene_id: int) -> void:
	"""R√©action √† une demande de changement de sc√®ne"""
	load_scene_by_id(scene_id)

# ============================================================================
# UTILITAIRES
# ============================================================================

func reload_current_scene(transition: bool = true) -> void:
	"""Recharge la sc√®ne actuelle"""
	
	if current_scene_id != -1:
		load_scene_by_id(current_scene_id, transition)
	elif current_scene:
		var scene_path = current_scene.scene_file_path
		load_scene(scene_path, transition)

func get_current_scene_name() -> String:
	"""Retourne le nom de la sc√®ne actuelle"""
	
	if current_scene_id != -1:
		return SceneRegistry.get_scene_name(current_scene_id)
	elif current_scene:
		return current_scene.name
	return "Aucune"
```

## core/autoloads/team_manager.gd

```text
extends Node
## TeamManager - Gestion de l'√©quipe du joueur
## Autoload pour g√©rer le roster, le recrutement, l'XP
##
## Acc√®s via : GameRoot.team_manager

signal team_changed()
signal unit_recruited(unit_id: String)
signal unit_dismissed(unit_id: String)
signal unit_leveled_up(unit_id: String, new_level: int)

# ============================================================================
# CONFIGURATION
# ============================================================================

const MAX_TEAM_SIZE: int = 8
const TEAM_SAVE_PATH: String = "user://team_data.json"
const AVAILABLE_UNITS_PATH: String = "res://data/team/available_units.json"

# ============================================================================
# DONN√âES
# ============================================================================

var current_team: Array[Dictionary] = []  # √âquipe active (max 4 en combat)
var roster: Array[Dictionary] = []  # Toutes les unit√©s recrut√©es
var available_units: Dictionary = {}  # Unit√©s recrutables

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_load_available_units()
	_load_team_from_save()
	print("[TeamManager] ‚úÖ Initialis√© - √âquipe : ", current_team.size(), " / Roster : ", roster.size())

func _load_available_units() -> void:
	if not FileAccess.file_exists(AVAILABLE_UNITS_PATH):
		push_warning("[TeamManager] Fichier d'unit√©s disponibles non trouv√©")
		return
	
	var file = FileAccess.open(AVAILABLE_UNITS_PATH, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		available_units = json.data
	else:
		push_warning("[TeamManager] Erreur de parsing des unit√©s disponibles")

# ============================================================================
# GESTION DE L'√âQUIPE
# ============================================================================

func add_to_team(unit_data: Dictionary) -> bool:
	"""Ajoute une unit√© √† l'√©quipe active"""
	
	if current_team.size() >= 4:
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.notify("√âquipe compl√®te (max 4 en combat)", "warning")
		return false
	
	current_team.append(unit_data)
	team_changed.emit()
	_save_team()
	
	print("[TeamManager] ‚úÖ Ajout√© : ", unit_data.get("name"))
	return true

func remove_from_team(unit_id: String) -> bool:
	"""Retire une unit√© de l'√©quipe active"""
	
	for i in range(current_team.size()):
		if current_team[i].get("id") == unit_id:
			current_team.remove_at(i)
			team_changed.emit()
			_save_team()
			return true
	
	return false

func recruit_unit(unit_id: String) -> bool:
	"""Recrute une unit√© (l'ajoute au roster)"""
	
	if roster.size() >= MAX_TEAM_SIZE:
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.notify("Roster complet (max " + str(MAX_TEAM_SIZE) + ")", "warning")
		return false
	
	# V√©rifier si d√©j√† recrut√©e
	for unit in roster:
		if unit.get("id") == unit_id:
			if GameRoot and GameRoot.event_bus:
				GameRoot.event_bus.notify("Unit√© d√©j√† recrut√©e", "warning")
			return false
	
	# Cr√©er l'instance depuis les donn√©es disponibles
	if not available_units.has(unit_id):
		push_error("[TeamManager] Unit√© introuvable : ", unit_id)
		return false
	
	var unit_template = available_units[unit_id]
	var new_unit = _create_unit_instance(unit_template)
	
	roster.append(new_unit)
	unit_recruited.emit(unit_id)
	_save_team()
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Recrut√© : " + new_unit.get("name"), "success")
	return true

func _create_unit_instance(template: Dictionary) -> Dictionary:
	"""Cr√©e une instance d'unit√© depuis un template"""
	
	var instance = template.duplicate(true)
	instance["instance_id"] = str(Time.get_ticks_msec())  # ID unique
	instance["level"] = 1
	instance["xp"] = 0
	instance["current_hp"] = instance.get("stats", {}).get("hp", 100)
	
	return instance

# ============================================================================
# GETTERS
# ============================================================================

func get_current_team() -> Array[Dictionary]:
	return current_team.duplicate()

func get_roster() -> Array[Dictionary]:
	return roster.duplicate()

func get_unit_by_id(unit_id: String) -> Dictionary:
	for unit in roster:
		if unit.get("id") == unit_id:
			return unit
	return {}

func is_team_full() -> bool:
	return current_team.size() >= 4

# ============================================================================
# XP & LEVEL UP
# ============================================================================

func add_xp(unit_id: String, xp_amount: int) -> void:
	"""Ajoute de l'XP √† une unit√©"""
	
	var unit = get_unit_by_id(unit_id)
	
	if unit.is_empty():
		return
	
	unit.xp += xp_amount
	
	# Check level up
	var xp_needed = _calculate_xp_for_level(unit.level + 1)
	
	if unit.xp >= xp_needed:
		_level_up(unit)

func _level_up(unit: Dictionary) -> void:
	"""Level up d'une unit√©"""
	
	unit.level += 1
	unit.xp = 0  # Reset XP
	
	# Augmenter les stats (exemple simple)
	var stats = unit.get("stats", {})
	stats.hp = int(stats.get("hp", 100) * 1.1)
	stats.attack = int(stats.get("attack", 20) * 1.1)
	stats.defense = int(stats.get("defense", 10) * 1.1)
	
	unit_leveled_up.emit(unit.get("id"), unit.level)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify(unit.get("name") + " atteint le niveau " + str(unit.level) + " !", "success")
	
	_save_team()

func _calculate_xp_for_level(level: int) -> int:
	"""Calcul XP n√©cessaire pour un niveau"""
	return 100 * level  # Formule simple

# ============================================================================
# SAUVEGARDE / CHARGEMENT
# ============================================================================

func _save_team() -> void:
	"""Sauvegarde l'√©quipe"""
	
	var save_data = {
		"current_team": current_team,
		"roster": roster,
		"timestamp": Time.get_unix_time_from_system()
	}
	
	var file = FileAccess.open(TEAM_SAVE_PATH, FileAccess.WRITE)
	
	if not file:
		push_error("[TeamManager] Impossible de sauvegarder")
		return
	
	file.store_string(JSON.stringify(save_data, "\t"))
	file.close()
	
	print("[TeamManager] üíæ √âquipe sauvegard√©e")

func _load_team_from_save() -> void:
	"""Charge l'√©quipe depuis la sauvegarde"""
	
	if not FileAccess.file_exists(TEAM_SAVE_PATH):
		# Cr√©er une √©quipe par d√©faut
		_create_default_team()
		return
	
	var file = FileAccess.open(TEAM_SAVE_PATH, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) != OK:
		push_error("[TeamManager] Erreur de parsing de la sauvegarde")
		_create_default_team()
		return
	
	var data = json.data
	current_team.clear()
	for unit in data.get("current_team", []):
		current_team.append(unit as Dictionary)
	
	roster.clear()
	for unit in data.get("roster", []):
		roster.append(unit as Dictionary)
	
	print("[TeamManager] üìÇ √âquipe charg√©e depuis sauvegarde")

func _create_default_team() -> void:
	"""Cr√©e une √©quipe de d√©part"""
	
	print("[TeamManager] üÜï Cr√©ation √©quipe par d√©faut")
	
	# Recruter 2 unit√©s de base si disponibles
	if available_units.has("starter_knight"):
		recruit_unit("starter_knight")
		if roster.size() > 0:
			add_to_team(roster[0])
	
	if available_units.has("starter_mage"):
		recruit_unit("starter_mage")
		if roster.size() > 1:
			add_to_team(roster[1])
```

## core/autoloads/ui_manager.gd

```text
extends CanvasLayer
## UIManager - Gestion de l'interface utilisateur globale
## G√®re les notifications, l'√©cran de chargement, les menus globaux
##
## Acc√®s via : GameRoot.ui_manager

class_name UIManagerClass

# ============================================================================
# CONFIGURATION
# ============================================================================

const NOTIFICATION_DURATION: float = 3.0
const NOTIFICATION_FADE: float = 0.3
const MAX_NOTIFICATIONS: int = 5

# ============================================================================
# R√âF√âRENCES UI
# ============================================================================

var notification_container: VBoxContainer = null
var loading_screen: Control = null
var loading_progress_bar: ProgressBar = null
var loading_label: Label = null
var pause_menu: Control = null
var transition_overlay: ColorRect = null

# ============================================================================
# √âTAT
# ============================================================================

var active_notifications: Array[Control] = []
var is_loading_visible: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	layer = 90  # Au-dessus des sc√®nes, en dessous du debug
	name = "UIManager"
	
	_create_transition_layer()
	_create_notification_system()
	_create_loading_screen()
	_create_pause_menu()
	
	print("[UIManager] ‚úÖ Initialis√©")

func _create_transition_layer() -> void:
	"""Cr√©e l'overlay de transition"""
	
	transition_overlay = ColorRect.new()
	transition_overlay.name = "TransitionOverlay"
	transition_overlay.color = Color.BLACK
	transition_overlay.set_anchors_preset(Control.PRESET_FULL_RECT)
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	transition_overlay.modulate.a = 0.0
	transition_overlay.z_index = 100
	add_child(transition_overlay)

func _create_notification_system() -> void:
	"""Cr√©e le conteneur de notifications"""
	
	notification_container = VBoxContainer.new()
	notification_container.name = "NotificationContainer"
	notification_container.set_anchors_preset(Control.PRESET_TOP_RIGHT)
	notification_container.anchor_left = 1.0
	notification_container.anchor_right = 1.0
	notification_container.offset_left = -320
	notification_container.offset_top = 20
	notification_container.offset_right = -20
	notification_container.add_theme_constant_override("separation", 10)
	add_child(notification_container)

func _create_loading_screen() -> void:
	"""Cr√©e l'√©cran de chargement"""
	
	loading_screen = Control.new()
	loading_screen.name = "LoadingScreen"
	loading_screen.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.visible = false
	loading_screen.z_index = 50
	add_child(loading_screen)
	
	# Fond semi-transparent
	var bg = ColorRect.new()
	bg.color = Color(0.05, 0.05, 0.08, 0.95)
	bg.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.add_child(bg)
	
	# Container central
	var center = CenterContainer.new()
	center.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.add_child(center)
	
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 20)
	center.add_child(vbox)
	
	# Label
	loading_label = Label.new()
	loading_label.text = "Chargement..."
	loading_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	loading_label.add_theme_font_size_override("font_size", 32)
	vbox.add_child(loading_label)
	
	# Barre de progression
	loading_progress_bar = ProgressBar.new()
	loading_progress_bar.custom_minimum_size = Vector2(400, 30)
	loading_progress_bar.value = 0
	vbox.add_child(loading_progress_bar)

func _create_pause_menu() -> void:
	"""Cr√©e le menu de pause"""
	
	pause_menu = Control.new()
	pause_menu.name = "PauseMenu"
	pause_menu.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.visible = false
	pause_menu.z_index = 80
	add_child(pause_menu)
	
	# Fond semi-transparent
	var bg = ColorRect.new()
	bg.color = Color(0, 0, 0, 0.7)
	bg.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.add_child(bg)
	
	# Container central
	var center = CenterContainer.new()
	center.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.add_child(center)
	
	var panel = PanelContainer.new()
	center.add_child(panel)
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 40)
	margin.add_theme_constant_override("margin_top", 40)
	margin.add_theme_constant_override("margin_right", 40)
	margin.add_theme_constant_override("margin_bottom", 40)
	panel.add_child(margin)
	
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 15)
	margin.add_child(vbox)
	
	# Titre
	var title = Label.new()
	title.text = "PAUSE"
	title.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title.add_theme_font_size_override("font_size", 48)
	vbox.add_child(title)
	
	# Boutons
	var resume_btn = Button.new()
	resume_btn.text = "Reprendre"
	resume_btn.custom_minimum_size = Vector2(200, 50)
	resume_btn.pressed.connect(_on_resume_pressed)
	vbox.add_child(resume_btn)
	
	var options_btn = Button.new()
	options_btn.text = "Options"
	options_btn.custom_minimum_size = Vector2(200, 50)
	options_btn.pressed.connect(_on_options_pressed)
	vbox.add_child(options_btn)
	
	var menu_btn = Button.new()
	menu_btn.text = "Menu Principal"
	menu_btn.custom_minimum_size = Vector2(200, 50)
	menu_btn.pressed.connect(_on_main_menu_pressed)
	vbox.add_child(menu_btn)
	
	var quit_btn = Button.new()
	quit_btn.text = "Quitter"
	quit_btn.custom_minimum_size = Vector2(200, 50)
	quit_btn.pressed.connect(_on_quit_pressed)
	vbox.add_child(quit_btn)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func create_transition_overlay() -> ColorRect:
	"""Retourne l'overlay de transition pour le SceneLoader"""
	return transition_overlay

func show_notification(message: String, type: String = "info", duration: float = NOTIFICATION_DURATION) -> void:
	"""Affiche une notification"""
	
	# Limiter le nombre de notifications
	while active_notifications.size() >= MAX_NOTIFICATIONS:
		var oldest = active_notifications.pop_front()
		if oldest and is_instance_valid(oldest):
			oldest.queue_free()
	
	# Cr√©er la notification
	var notif = _create_notification_panel(message, type)
	notification_container.add_child(notif)
	active_notifications.append(notif)
	
	# Animation d'apparition
	notif.modulate.a = 0.0
	notif.position.x = 50
	
	var tween = create_tween()
	tween.set_parallel(true)
	tween.tween_property(notif, "modulate:a", 1.0, NOTIFICATION_FADE)
	tween.tween_property(notif, "position:x", 0.0, NOTIFICATION_FADE)
	
	# Timer de disparition
	await get_tree().create_timer(duration).timeout
	
	if is_instance_valid(notif):
		var fade_tween = create_tween()
		fade_tween.tween_property(notif, "modulate:a", 0.0, NOTIFICATION_FADE)
		fade_tween.tween_callback(func():
			if is_instance_valid(notif):
				active_notifications.erase(notif)
				notif.queue_free()
		)

func _create_notification_panel(message: String, type: String) -> PanelContainer:
	"""Cr√©e un panel de notification stylis√©"""
	
	var panel = PanelContainer.new()
	panel.custom_minimum_size = Vector2(300, 0)
	
	# Style selon le type
	var style = StyleBoxFlat.new()
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	style.border_width_left = 4
	
	match type:
		"success":
			style.bg_color = Color(0.1, 0.3, 0.1, 0.95)
			style.border_color = Color(0.3, 0.8, 0.3)
		"warning":
			style.bg_color = Color(0.3, 0.25, 0.1, 0.95)
			style.border_color = Color(0.9, 0.7, 0.2)
		"error":
			style.bg_color = Color(0.3, 0.1, 0.1, 0.95)
			style.border_color = Color(0.9, 0.3, 0.3)
		_:  # info
			style.bg_color = Color(0.1, 0.15, 0.25, 0.95)
			style.border_color = Color(0.4, 0.6, 0.9)
	
	panel.add_theme_stylebox_override("panel", style)
	
	# Contenu
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 15)
	margin.add_theme_constant_override("margin_top", 10)
	margin.add_theme_constant_override("margin_right", 15)
	margin.add_theme_constant_override("margin_bottom", 10)
	panel.add_child(margin)
	
	var label = Label.new()
	label.text = message
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	margin.add_child(label)
	
	return panel

func show_loading(text: String = "Chargement...") -> void:
	"""Affiche l'√©cran de chargement"""
	
	loading_label.text = text
	loading_progress_bar.value = 0
	loading_screen.visible = true
	is_loading_visible = true

func hide_loading() -> void:
	"""Cache l'√©cran de chargement"""
	
	loading_screen.visible = false
	is_loading_visible = false

func update_loading_progress(progress: float) -> void:
	"""Met √† jour la barre de progression"""
	
	loading_progress_bar.value = progress * 100

func show_pause_menu() -> void:
	"""Affiche le menu de pause"""
	pause_menu.visible = true

func hide_pause_menu() -> void:
	"""Cache le menu de pause"""
	pause_menu.visible = false

func toggle_pause_menu() -> void:
	"""Inverse la visibilit√© du menu de pause"""
	
	if pause_menu.visible:
		hide_pause_menu()
	else:
		show_pause_menu()

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_notification_posted(message: String, type: String) -> void:
	"""Callback des notifications via EventBus"""
	show_notification(message, type)

# ============================================================================
# CALLBACKS MENU PAUSE
# ============================================================================

func _on_resume_pressed() -> void:
	hide_pause_menu()
	if GameRoot and GameRoot.game_manager:
		GameRoot.game_manager.pause_game(false)

func _on_options_pressed() -> void:
	# TODO: Ouvrir les options
	show_notification("Options (√† impl√©menter)", "info")

func _on_main_menu_pressed() -> void:
	hide_pause_menu()
	if GameRoot:
		if GameRoot.game_manager:
			GameRoot.game_manager.pause_game(false)
		if GameRoot.event_bus:
			GameRoot.event_bus.return_to_menu_requested.emit()

func _on_quit_pressed() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.quit_game_requested.emit()

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_cancel"):
		if GameRoot and GameRoot.game_manager:
			# Seulement si on n'est pas au menu principal
			var current_id = GameRoot.game_manager.get_current_scene_id()
			if current_id != SceneRegistry.SceneID.MAIN_MENU:
				GameRoot.game_manager.toggle_pause()
				toggle_pause_menu()
```

## core/autoloads/version_manager.gd

```text
extends Node
class_name VersionManagerClass
## Gestion des versions de donn√©es et migrations
##
## Acc√®s via : GameRoot.version_manager

const CURRENT_VERSION = "1.0.0"
const VERSION_FILE = "user://version.json"

signal migration_started(from_version: String, to_version: String)
signal migration_completed(from_version: String, to_version: String)
signal migration_failed(from_version: String, to_version: String, error: String)

var migrations: Dictionary = {}  # "0.9.0" -> Callable

func _ready() -> void:
	_register_migrations()
	print("[VersionManager] ‚úÖ Initialis√© (version: %s)" % CURRENT_VERSION)

func _register_migrations() -> void:
	# Exemple de migration 0.9.0 -> 1.0.0
	register_migration("0.9.0", _migrate_0_9_to_1_0)

func register_migration(from_version: String, migration_func: Callable) -> void:
	migrations[from_version] = migration_func

func check_and_migrate() -> bool:
	var installed_version = _get_installed_version()
	
	if installed_version == CURRENT_VERSION:
		print("[VersionManager] ‚úÖ Version √† jour : ", CURRENT_VERSION)
		return true
	
	print("[VersionManager] üîÑ Migration n√©cessaire : ", installed_version, " -> ", CURRENT_VERSION)
	
	return migrate_from(installed_version)

func migrate_from(from_version: String) -> bool:
	if not migrations.has(from_version):
		# Pas de migration n√©cessaire, mettre √† jour la version
		_set_installed_version(CURRENT_VERSION)
		return true
	
	migration_started.emit(from_version, CURRENT_VERSION)
	
	var migration_func = migrations[from_version]
	var success = migration_func.call()
	
	if success:
		_set_installed_version(CURRENT_VERSION)
		migration_completed.emit(from_version, CURRENT_VERSION)
		print("[VersionManager] ‚úÖ Migration r√©ussie")
		return true
	else:
		migration_failed.emit(from_version, CURRENT_VERSION, "√âchec de la migration")
		return false

func _get_installed_version() -> String:
	if not FileAccess.file_exists(VERSION_FILE):
		return "0.0.0"
	
	var file = FileAccess.open(VERSION_FILE, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		return json.data.get("version", "0.0.0")
	
	return "0.0.0"

func _set_installed_version(version: String) -> void:
	var data = {"version": version, "timestamp": Time.get_unix_time_from_system()}
	
	var file = FileAccess.open(VERSION_FILE, FileAccess.WRITE)
	file.store_string(JSON.stringify(data, "\t"))
	file.close()

func get_current_version() -> String:
	return CURRENT_VERSION

func get_installed_version() -> String:
	return _get_installed_version()

# ============================================================================
# MIGRATIONS SP√âCIFIQUES
# ============================================================================

func _migrate_0_9_to_1_0() -> bool:
	print("[VersionManager] Migration 0.9.0 -> 1.0.0")
	
	var save_dir = "user://saves/"
	
	if not DirAccess.dir_exists_absolute(save_dir):
		return true  # Pas de sauvegardes
	
	var dir = DirAccess.open(save_dir)
	dir.list_dir_begin()
	
	var file_name = dir.get_next()
	while file_name != "":
		if file_name.ends_with(".save"):
			var full_path = save_dir + file_name
			_migrate_save_file(full_path)
		
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return true

func _migrate_save_file(path: String) -> void:
	var file = FileAccess.open(path, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) != OK:
		return
	
	var data = json.data
	data["version"] = "1.0.0"
	
	file = FileAccess.open(path, FileAccess.WRITE)
	file.store_string(JSON.stringify(data, "\t"))
	file.close()
```

## core/data/ability_data_loader.gd

```text
class_name AbilityDataLoader
extends Node
## Charge les donn√©es d'abilities depuis JSON
## Format: data/abilities/*.json

const ABILITIES_DIR = "res://data/abilities/"

var _json_loader: JSONDataLoader
var abilities: Dictionary = {}

func _init():
	_json_loader = JSONDataLoader.new()

func _ready() -> void:
	load_all_abilities()

func load_all_abilities() -> void:
	abilities = _json_loader.load_json_directory(ABILITIES_DIR, false)
	
	if abilities.is_empty():
		push_warning("No abilities loaded from " + ABILITIES_DIR)
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.data_load_warning.emit("abilities", "No data found")
	else:
		print("[AbilityDataLoader] Loaded %d abilities" % abilities.size())
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.data_loaded.emit("abilities", abilities)

func get_ability(ability_id: String) -> Dictionary:
	if abilities.has(ability_id):
		return abilities[ability_id]
	
	push_error("Ability not found: " + ability_id)
	return {}

func reload_ability(ability_id: String) -> void:
	var file_path = ABILITIES_DIR.path_join(ability_id + ".json")
	_json_loader.clear_cache(file_path)
	var data = _json_loader.load_json_file(file_path)
	
	if data:
		abilities[ability_id] = data
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.ability_reloaded.emit(ability_id)

## Valide les champs requis d'une ability
func validate_ability(data: Dictionary) -> bool:
	var required = ["id", "name", "type", "cost"]
	return _json_loader.validate_schema(data, required)
```

## core/data/json_data_loader.gd

```text
class_name JSONDataLoader
extends RefCounted
## Chargeur JSON g√©n√©rique avec validation et cache

signal data_loaded(data_type: String, data: Dictionary)
signal data_load_failed(data_type: String, error: String)

var _cache: Dictionary = {}
var _schema_validators: Dictionary = {}

## Charge un fichier JSON avec cache optionnel
func load_json_file(file_path: String, use_cache: bool = true) -> Variant:
	if use_cache and _cache.has(file_path):
		return _cache[file_path]
	
	if not FileAccess.file_exists(file_path):
		push_error("JSON file not found: " + file_path)
		return null
	
	var file = FileAccess.open(file_path, FileAccess.READ)
	if not file:
		push_error("Failed to open JSON file: " + file_path)
		return null
	
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	var parse_result = json.parse(json_string)
	
	if parse_result != OK:
		var error_msg = "JSON parse error at line %d: %s" % [json.get_error_line(), json.get_error_message()]
		push_error(error_msg)
		return null
	
	var data = json.data
	
	if use_cache:
		_cache[file_path] = data
	
	return data

## Charge tous les fichiers JSON d'un dossier
func load_json_directory(dir_path: String, recursive: bool = false) -> Dictionary:
	var result = {}
	var dir = DirAccess.open(dir_path)
	
	if not dir:
		push_error("Failed to open directory: " + dir_path)
		return result
	
	dir.list_dir_begin()
	var file_name = dir.get_next()
	
	while file_name != "":
		if file_name.begins_with("."):
			file_name = dir.get_next()
			continue
		
		var full_path = dir_path.path_join(file_name)
		
		if dir.current_is_dir():
			if recursive:
				var subdir_data = load_json_directory(full_path, true)
				result[file_name] = subdir_data
		elif file_name.ends_with(".json"):
			var data = load_json_file(full_path)
			if data != null:
				var key = file_name.get_basename()
				result[key] = data
		
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return result

## Valide la structure d'un objet JSON selon un sch√©ma basique
func validate_schema(data: Dictionary, required_fields: Array) -> bool:
	for field in required_fields:
		if not data.has(field):
			push_error("Missing required field: " + field)
			return false
	return true

## Charge et valide un fichier avec sch√©ma
func load_validated_json(file_path: String, required_fields: Array = []) -> Variant:
	var data = load_json_file(file_path)
	
	if data == null:
		return null
	
	if data is Dictionary and required_fields.size() > 0:
		if not validate_schema(data, required_fields):
			return null
	
	return data

## Nettoie le cache (utile pour rechargement √† chaud)
func clear_cache(file_path: String = "") -> void:
	if file_path.is_empty():
		_cache.clear()
	else:
		_cache.erase(file_path)

## Sauvegarde des donn√©es en JSON (pour √©diteurs/outils)
func save_json_file(file_path: String, data: Variant) -> bool:
	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if not file:
		push_error("Failed to save JSON file: " + file_path)
		return false
	
	var json_string = JSON.stringify(data, "\t")
	file.store_string(json_string)
	file.close()
	return true
```

## core/data/model_validator.gd

```text
extends Node
class_name ModelValidator
## Validateur de mod√®les de donn√©es JSON

static var _models: Dictionary = {}

# ======================================================
# PUBLIC API
# ======================================================

static func validate(data: Variant, model_id: String) -> ValidationResult:
	var result := ValidationResult.new()
	var model := _load_model(model_id)

	if model.is_empty():
		result.add_error("Model not found: %s" % model_id)
		return result

	_validate_value(data, model, "", result)

	result.data = data
	return result


# ======================================================
# MODEL LOADING
# ======================================================

static func _load_model(model_id: String) -> Dictionary:
	if _models.has(model_id):
		return _models[model_id]

	var path := "res://data/models/%s_model.json" % model_id
	if not FileAccess.file_exists(path):
		push_error("[ModelValidator] Model file not found: " + path)
		return {}

	var file := FileAccess.open(path, FileAccess.READ)
	var parsed = JSON.parse_string(file.get_as_text())
	file.close()

	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("[ModelValidator] Invalid model format: " + model_id)
		return {}

	_models[model_id] = parsed
	return parsed


# ======================================================
# CORE VALIDATION
# ======================================================

static func _validate_value(value: Variant, model: Dictionary, path: String, result: ValidationResult) -> void:
	match model.get("type"):
		"object":
			_validate_object(value, model, path, result)

		"array":
			_validate_array(value, model, path, result)

		"vector2i":
			_validate_vector2i(value, path, result)

		_:
			result.add_error("%s: Unknown model type" % path)


# ======================================================
# OBJECT
# ======================================================

static func _validate_object(value, model, path, result):
	if typeof(value) != TYPE_DICTIONARY:
		result.add_error("%s must be an object" % path)
		return

	var fields: Dictionary = model.get("fields", {})

	for field_name in fields.keys():
		var rule = fields[field_name]
		var field_path = field_name if path == "" else "%s.%s" % [path, field_name]

		if rule.get("required", false) and not value.has(field_name):
			result.add_error("Missing field: %s" % field_path)
			continue

		if not value.has(field_name):
			continue

		_validate_field(value, field_name, rule, field_path, result)


# ======================================================
# ARRAY
# ======================================================

static func _validate_array(value, model, path, result):
	if typeof(value) != TYPE_ARRAY:
		result.add_error("%s must be an array" % path)
		return

	var item_model_id = model.get("items", {}).get("model", "")
	if item_model_id == "":
		return

	var item_model = _load_model(item_model_id)

	for i in range(value.size()):
		var item_path = "%s[%d]" % [path, i]
		_validate_value(value[i], item_model, item_path, result)


# ======================================================
# VECTOR2I
# ======================================================

static func _validate_vector2i(value, path, result):
	if typeof(value) != TYPE_DICTIONARY or not value.has("x") or not value.has("y"):
		result.add_error("%s must be a Vector2i-like object" % path)
		return

	value.x = int(value.x)
	value.y = int(value.y)


# ======================================================
# FIELD
# ======================================================

static func _validate_field(obj, key, rule, path, result):
	var v = obj[key]

	match rule.get("type"):
		"string":
			if typeof(v) != TYPE_STRING:
				result.add_error("%s must be a string" % path)

		"number":
			if typeof(v) != TYPE_FLOAT and typeof(v) != TYPE_INT:
				result.add_error("%s must be a number" % path)
				return

			if rule.get("integer", false) and typeof(v) == TYPE_FLOAT and v != int(v):
				result.add_error("%s must be an integer (got %s)" % [path, v])

			if rule.has("min") and v < rule.min:
				result.add_error("%s < min (%s)" % [path, rule.min])

			if rule.has("max") and v > rule.max:
				result.add_error("%s > max (%s)" % [path, rule.max])

			if rule.get("normalize") == "int":
				obj[key] = int(v)

		"object":
			var sub_model = rule.get("model", "")
			if sub_model != "":
				_validate_value(v, _load_model(sub_model), path, result)

		"array":
			if typeof(v) != TYPE_ARRAY:
				result.add_error("%s must be an array" % path)
				return
			
			var item_rule = rule.get("items", {})
			if not item_rule.is_empty():
				for i in range(v.size()):
					var item_path = "%s[%d]" % [path, i]
					if item_rule.has("model"):
						var item_model = _load_model(item_rule.model)
						_validate_value(v[i], item_model, item_path, result)

		"boolean":
			if typeof(v) != TYPE_BOOL:
				result.add_error("%s must be a boolean" % path)

# ======================================================
# CACHE MANAGEMENT
# ======================================================

static func clear_cache() -> void:
	"""Vide le cache des mod√®les"""
	_models.clear()

static func reload_model(model_id: String) -> void:
	"""Recharge un mod√®le sp√©cifique"""
	_models.erase(model_id)
	_load_model(model_id)
```

## core/data/scene_registry.gd

```text
extends Node
## SceneRegistry - Registre centralis√© de toutes les sc√®nes du jeu
## Permet un acc√®s d√©coupl√© aux chemins de sc√®nes

class_name SceneRegistry

# √ânum√©ration des sc√®nes principales
enum SceneID {
	# Menus
	MAIN_MENU,
	OPTIONS_MENU,
	PAUSE_MENU,
	SAVE_LOAD_MENU,
	
	# Monde
	WORLD_MAP,
	TOWN,
	CASTLE,
	
	# Combat
	BATTLE,
	BATTLE_PREPARATION,
	BATTLE_RESULTS,
	
	# Narration
	INTRO_DIALOGUE,
	CUTSCENE,
	DIALOGUE,
	
	# Syst√®me
	LOADING_SCREEN,
	CREDITS,
}

# Registre des chemins de sc√®nes
const SCENE_PATHS: Dictionary = {
	# Menus
	SceneID.MAIN_MENU: "res://features/menu/main_menu.tscn",
	SceneID.OPTIONS_MENU: "res://features/menu/options_menu.tscn",
	SceneID.PAUSE_MENU: "res://features/menu/pause_menu.tscn",
	SceneID.SAVE_LOAD_MENU: "res://features/menu/save_load_menu.tscn",
	
	# Monde
	SceneID.WORLD_MAP: "res://features/world_map/visuals/world_map.tscn",
	SceneID.TOWN: "res://features/world_map/visuals/town.tscn",
	SceneID.CASTLE: "res://features/world_map/visuals/castle.tscn",
	
	# Combat
	SceneID.BATTLE: "res://features/combat/visuals/battle_3d.tscn",
	SceneID.BATTLE_PREPARATION: "res://features/combat/visuals/battle_preparation.tscn",
	SceneID.BATTLE_RESULTS: "res://features/Duo/ui/battle_results.tscn",
	
	# Narration
	SceneID.INTRO_DIALOGUE: "res://features/intro/intro_dialogue.tscn",
	SceneID.CUTSCENE: "res://features/narrative/cutscene.tscn",
	SceneID.DIALOGUE: "res://features/narrative/dialogue.tscn",
	
	# Syst√®me
	SceneID.LOADING_SCREEN: "res://shared/system/loading_screen.tscn",
	SceneID.CREDITS: "res://shared/credits/credits.tscn",
}

# M√©tadonn√©es des sc√®nes (optionnel)
const SCENE_METADATA: Dictionary = {
	SceneID.MAIN_MENU: {
		"category": "menu",
		"requires_save": false,
		"pausable": false,
	},
	SceneID.WORLD_MAP: {
		"category": "world",
		"requires_save": true,
		"pausable": true,
		"music": "res://audio/music/world_theme.ogg",
	},
	SceneID.BATTLE: {
		"category": "battle",
		"requires_save": true,
		"pausable": true,
		"music": "res://audio/music/battle_theme.ogg",
	},
}

## Obtenir le chemin d'une sc√®ne
static func get_scene_path(scene_id: SceneID) -> String:
	if SCENE_PATHS.has(scene_id):
		return SCENE_PATHS[scene_id]
	
	push_error("[SceneRegistry] SceneID introuvable : ", scene_id)
	return ""

## Obtenir les m√©tadonn√©es d'une sc√®ne
static func get_scene_metadata(scene_id: SceneID) -> Dictionary:
	if SCENE_METADATA.has(scene_id):
		return SCENE_METADATA[scene_id]
	return {}

## V√©rifier si une sc√®ne existe
static func scene_exists(scene_id: SceneID) -> bool:
	var path = get_scene_path(scene_id)
	return path != "" and ResourceLoader.exists(path)

## Obtenir toutes les sc√®nes d'une cat√©gorie
static func get_scenes_by_category(category: String) -> Array[SceneID]:
	var result: Array[SceneID] = []
	
	for scene_id in SCENE_METADATA:
		var metadata = SCENE_METADATA[scene_id]
		if metadata.get("category") == category:
			result.append(scene_id)
	
	return result

## Obtenir le nom lisible d'une sc√®ne
static func get_scene_name(scene_id: SceneID) -> String:
	var scene_names = {
		SceneID.MAIN_MENU: "Menu Principal",
		SceneID.OPTIONS_MENU: "Options",
		SceneID.PAUSE_MENU: "Pause",
		SceneID.SAVE_LOAD_MENU: "Sauvegarder/Charger",
		SceneID.WORLD_MAP: "Carte du Monde",
		SceneID.TOWN: "Ville",
		SceneID.CASTLE: "Ch√¢teau",
		SceneID.BATTLE: "Combat",
		SceneID.BATTLE_PREPARATION: "Pr√©paration Combat",
		SceneID.BATTLE_RESULTS: "R√©sultats Combat",
		SceneID.INTRO_DIALOGUE: "Introduction",
		SceneID.CUTSCENE: "Cin√©matique",
		SceneID.DIALOGUE: "Dialogue",
		SceneID.LOADING_SCREEN: "Chargement",
		SceneID.CREDITS: "Cr√©dits",
	}
	
	return scene_names.get(scene_id, "Inconnu")

## Validation du registre au d√©marrage
static func validate_registry() -> bool:
	var all_valid = true
	
	for scene_id in SCENE_PATHS:
		var path = SCENE_PATHS[scene_id]
		if not ResourceLoader.exists(path):
			push_warning("[SceneRegistry] Sc√®ne manquante : ", get_scene_name(scene_id), " (", path, ")")
			all_valid = false
	
	return all_valid
```

## core/data/validation_result.gd

```text
extends RefCounted
class_name ValidationResult
## R√©sultat d'une validation de donn√©es

var is_valid: bool = true
var errors: Array[String] = []
var data: Variant = null

func add_error(message: String) -> void:
	"""Ajoute une erreur et marque le r√©sultat comme invalide"""
	errors.append(message)
	is_valid = false

func has_errors() -> bool:
	"""V√©rifie si des erreurs sont pr√©sentes"""
	return not errors.is_empty()

func get_errors_string() -> String:
	"""Retourne toutes les erreurs en une seule cha√Æne"""
	return "\n".join(errors)

func clear() -> void:
	"""R√©initialise le r√©sultat"""
	is_valid = true
	errors.clear()
	data = null
```

## core/dialogue/bark_system.gd

```text
extends Node
class_name BarkSystem
## Syst√®me de "barks" - messages courts au-dessus des personnages

signal bark_shown(speaker: String, text: String)
signal bark_hidden(speaker: String)

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var default_duration: float = 2.0
@export var fade_duration: float = 0.3
@export var max_barks: int = 5
@export var bark_offset: Vector2 = Vector2(0, -50)

# ============================================================================
# √âTAT
# ============================================================================

var active_barks: Dictionary = {}  # speaker -> BarkLabel
var bark_container: CanvasLayer = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_create_bark_container()
	print("[BarkSystem] ‚úÖ Initialis√©")

func _create_bark_container() -> void:
	"""Cr√©e le conteneur pour les barks"""
	bark_container = CanvasLayer.new()
	bark_container.layer = 50
	bark_container.name = "BarkContainer"
	add_child(bark_container)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func show_bark(speaker: String, text: String, world_position: Vector2, duration: float = -1.0) -> void:
	"""Affiche un bark au-dessus d'une position"""
	
	if duration < 0:
		duration = default_duration
	
	# Supprimer le bark existant pour ce speaker
	if active_barks.has(speaker):
		_remove_bark(speaker)
	
	# Limiter le nombre de barks
	while active_barks.size() >= max_barks:
		var oldest = active_barks.keys()[0]
		_remove_bark(oldest)
	
	# Cr√©er le nouveau bark
	var bark_label = _create_bark_label(text, world_position)
	active_barks[speaker] = bark_label
	bark_container.add_child(bark_label)
	
	# Animation d'apparition
	bark_label.modulate.a = 0.0
	var tween = create_tween()
	tween.tween_property(bark_label, "modulate:a", 1.0, fade_duration)
	
	bark_shown.emit(speaker, text)
	
	# Timer de disparition
	await get_tree().create_timer(duration).timeout
	
	if active_barks.has(speaker) and is_instance_valid(active_barks[speaker]):
		_fade_out_bark(speaker)

func hide_bark(speaker: String) -> void:
	"""Cache imm√©diatement un bark"""
	_remove_bark(speaker)

func hide_all_barks() -> void:
	"""Cache tous les barks"""
	for speaker in active_barks.keys():
		_remove_bark(speaker)

# ============================================================================
# CR√âATION UI
# ============================================================================

func _create_bark_label(text: String, world_position: Vector2) -> PanelContainer:
	"""Cr√©e un label de bark stylis√©"""
	
	var panel = PanelContainer.new()
	
	# Style du panel
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.1, 0.1, 0.15, 0.9)
	style.border_width_left = 2
	style.border_width_top = 2
	style.border_width_right = 2
	style.border_width_bottom = 2
	style.border_color = Color(0.5, 0.5, 0.6)
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	style.content_margin_left = 10
	style.content_margin_top = 5
	style.content_margin_right = 10
	style.content_margin_bottom = 5
	panel.add_theme_stylebox_override("panel", style)
	
	# Label
	var label = Label.new()
	label.text = text
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	label.custom_minimum_size = Vector2(50, 0)
	panel.add_child(label)
	
	# Position (convertir world √† screen si n√©cessaire)
	panel.position = world_position + bark_offset
	
	return panel

func _fade_out_bark(speaker: String) -> void:
	"""Fait dispara√Ætre un bark avec animation"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	if not is_instance_valid(bark):
		active_barks.erase(speaker)
		return
	
	var tween = create_tween()
	tween.tween_property(bark, "modulate:a", 0.0, fade_duration)
	tween.tween_callback(func(): _remove_bark(speaker))

func _remove_bark(speaker: String) -> void:
	"""Supprime un bark"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	active_barks.erase(speaker)
	
	if is_instance_valid(bark):
		bark.queue_free()
	
	bark_hidden.emit(speaker)

# ============================================================================
# MISE √Ä JOUR POSITION
# ============================================================================

func update_bark_position(speaker: String, world_position: Vector2) -> void:
	"""Met √† jour la position d'un bark (pour suivre un personnage)"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	if is_instance_valid(bark):
		bark.position = world_position + bark_offset
```

## core/dialogue/dialogue_box.gd

```text
extends Control
class_name DialogueBox
## Bo√Æte de dialogue UI - √† √©tendre ou utiliser directement

# ============================================================================
# SIGNAUX
# ============================================================================

signal text_reveal_completed()
signal choice_selected(index: int)
signal dialogue_box_shown()
signal dialogue_box_hidden()

# ============================================================================
# R√âF√âRENCES (√† connecter dans l'inspecteur ou via code)
# ============================================================================

@export var speaker_label: Label
@export var text_label: RichTextLabel
@export var portrait_texture: TextureRect
@export var choices_container: VBoxContainer
@export var continue_indicator: Control

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var typewriter_speed: float = 50.0  # Caract√®res par seconde
@export var show_continue_indicator: bool = true
@export var auto_size: bool = true

# ============================================================================
# √âTAT
# ============================================================================

var dialogue_manager = null  # R√©f√©rence au DialogueManager
var is_text_revealing: bool = false
var current_text: String = ""
var revealed_characters: int = 0
var _typewriter_timer: float = 0.0

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# Cr√©er l'UI si pas de r√©f√©rences
	if not speaker_label or not text_label:
		_create_default_ui()
	
	# Cacher par d√©faut
	visible = false
	
	if continue_indicator:
		continue_indicator.visible = false

func _create_default_ui() -> void:
	"""Cr√©e une UI de dialogue par d√©faut"""
	
	# Panel principal
	var panel = PanelContainer.new()
	panel.set_anchors_preset(Control.PRESET_BOTTOM_WIDE)
	panel.anchor_top = 0.7
	panel.offset_top = 0
	panel.offset_bottom = -20
	panel.offset_left = 20
	panel.offset_right = -20
	add_child(panel)
	
	# Style
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.08, 0.08, 0.12, 0.95)
	style.border_width_left = 3
	style.border_width_top = 3
	style.border_width_right = 3
	style.border_width_bottom = 3
	style.border_color = Color(0.4, 0.4, 0.6)
	style.corner_radius_top_left = 12
	style.corner_radius_top_right = 12
	style.corner_radius_bottom_left = 12
	style.corner_radius_bottom_right = 12
	panel.add_theme_stylebox_override("panel", style)
	
	# Margin
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 20)
	margin.add_theme_constant_override("margin_top", 15)
	margin.add_theme_constant_override("margin_right", 20)
	margin.add_theme_constant_override("margin_bottom", 15)
	panel.add_child(margin)
	
	# VBox
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 10)
	margin.add_child(vbox)
	
	# Speaker
	speaker_label = Label.new()
	speaker_label.add_theme_font_size_override("font_size", 24)
	speaker_label.add_theme_color_override("font_color", Color(0.9, 0.8, 0.5))
	vbox.add_child(speaker_label)
	
	# Text
	text_label = RichTextLabel.new()
	text_label.bbcode_enabled = true
	text_label.fit_content = true
	text_label.scroll_active = false
	text_label.size_flags_vertical = Control.SIZE_EXPAND_FILL
	text_label.add_theme_font_size_override("normal_font_size", 20)
	vbox.add_child(text_label)
	
	# Choices container
	choices_container = VBoxContainer.new()
	choices_container.add_theme_constant_override("separation", 8)
	choices_container.visible = false
	vbox.add_child(choices_container)
	
	# Continue indicator
	continue_indicator = Label.new()
	continue_indicator.text = "‚ñº"
	continue_indicator.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	continue_indicator.visible = false
	vbox.add_child(continue_indicator)

# ============================================================================
# AFFICHAGE
# ============================================================================

func show_dialogue_box() -> void:
	"""Affiche la bo√Æte de dialogue"""
	visible = true
	dialogue_box_shown.emit()

func hide_dialogue_box() -> void:
	"""Cache la bo√Æte de dialogue"""
	visible = false
	is_text_revealing = false
	dialogue_box_hidden.emit()

func display_line(line: Dictionary) -> void:
	"""Affiche une ligne de dialogue"""
	
	# Speaker
	var speaker = line.get("speaker", "")
	if speaker_label:
		speaker_label.text = speaker
		speaker_label.visible = speaker != ""
	
	# Portrait
	if portrait_texture and line.has("portrait"):
		var portrait_path = line.get("portrait", "")
		if portrait_path != "" and ResourceLoader.exists(portrait_path):
			portrait_texture.texture = load(portrait_path)
			portrait_texture.visible = true
		else:
			portrait_texture.visible = false
	
	# Texte
	var text = line.get("text", "")
	var text_key = line.get("text_key", "")
	
	if text_key != "":
		text = tr(text_key)
	
	current_text = text
	
	# Cacher les choix
	if choices_container:
		choices_container.visible = false
		_clear_choices()
	
	# Cacher l'indicateur de continuation
	if continue_indicator:
		continue_indicator.visible = false
	
	# D√©marrer le typewriter
	var speed = line.get("speed", typewriter_speed)
	_start_typewriter(text, speed)

func display_choices(choices: Array) -> void:
	"""Affiche les choix"""
	
	if not choices_container:
		return
	
	_clear_choices()
	
	for i in range(choices.size()):
		var choice = choices[i]
		var button = Button.new()
		
		var choice_text = choice.get("text", "")
		var choice_key = choice.get("text_key", "")
		
		if choice_key != "":
			choice_text = tr(choice_key)
		
		button.text = choice_text
		button.custom_minimum_size = Vector2(0, 40)
		button.pressed.connect(func(): _on_choice_pressed(i))
		
		choices_container.add_child(button)
	
	choices_container.visible = true

func _clear_choices() -> void:
	"""Supprime tous les boutons de choix"""
	if choices_container:
		for child in choices_container.get_children():
			child.queue_free()

func _on_choice_pressed(index: int) -> void:
	"""Callback quand un choix est s√©lectionn√©"""
	choice_selected.emit(index)
	
	if dialogue_manager:
		dialogue_manager.select_choice(index)

# ============================================================================
# TYPEWRITER
# ============================================================================

func _start_typewriter(text: String, speed: float) -> void:
	"""D√©marre l'effet typewriter"""
	
	current_text = text
	revealed_characters = 0
	is_text_revealing = true
	typewriter_speed = speed
	_typewriter_timer = 0.0
	
	if text_label:
		text_label.text = ""

func _process(delta: float) -> void:
	if not is_text_revealing:
		return
	
	_typewriter_timer += delta * typewriter_speed
	
	var chars_to_show = int(_typewriter_timer)
	
	if chars_to_show > revealed_characters:
		revealed_characters = chars_to_show
		
		if text_label:
			if revealed_characters >= current_text.length():
				text_label.text = current_text
				complete_text()
			else:
				text_label.text = current_text.substr(0, revealed_characters)

func complete_text() -> void:
	"""Compl√®te imm√©diatement le texte"""
	
	if text_label:
		text_label.text = current_text
	
	revealed_characters = current_text.length()
	is_text_revealing = false
	
	# Afficher l'indicateur de continuation
	if continue_indicator and show_continue_indicator:
		continue_indicator.visible = true
	
	text_reveal_completed.emit()

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	if not visible:
		return
	
	# Avancer le dialogue
	if event.is_action_pressed("ui_accept") or event.is_action_pressed("ui_select"):
		if dialogue_manager:
			dialogue_manager.advance_dialogue()
		get_viewport().set_input_as_handled()
```

## core/dialogue/dialogue_data.gd

```text
extends Resource
class_name DialogueData
## Structure de donn√©es pour un dialogue

@export var dialogue_id: String = ""
@export var lines: Array[Dictionary] = []
@export var metadata: Dictionary = {}

## Structure d'une ligne de dialogue :
## {
##   "speaker": "nom_du_personnage",
##   "text": "Texte du dialogue",
##   "text_key": "DIALOGUE_KEY",  # Cl√© de traduction (optionnel)
##   "portrait": "res://path/to/portrait.png",  # (optionnel)
##   "emotion": "happy",  # (optionnel)
##   "speed": 50.0,  # Vitesse du texte (optionnel)
##   "auto_advance": false,  # Auto-avance (optionnel)
##   "auto_delay": 2.0,  # D√©lai avant auto-avance (optionnel)
##   "choices": [],  # Choix possibles (optionnel)
##   "event": {},  # √âv√©nement √† d√©clencher (optionnel)
## }

func _init(id: String = "", dialogue_lines: Array = []) -> void:
	dialogue_id = id
	for line in dialogue_lines:
		lines.append(line)

func add_line(line_data: Dictionary) -> void:
	"""Ajoute une ligne de dialogue"""
	lines.append(line_data)

func get_line(index: int) -> Dictionary:
	"""R√©cup√®re une ligne par son index"""
	if index >= 0 and index < lines.size():
		return lines[index]
	return {}

func get_line_count() -> int:
	"""Retourne le nombre de lignes"""
	return lines.size()

## Cr√©e un DialogueData depuis un dictionnaire JSON
static func from_dict(data: Dictionary) -> DialogueData:
	var dialogue = DialogueData.new()
	dialogue.dialogue_id = data.get("dialogue_id", "")
	dialogue.metadata = data.get("metadata", {})
	
	var raw_lines = data.get("lines", [])
	for line in raw_lines:
		dialogue.lines.append(line)
	
	return dialogue

## Convertit en dictionnaire pour sauvegarde
func to_dict() -> Dictionary:
	return {
		"dialogue_id": dialogue_id,
		"lines": lines,
		"metadata": metadata
	}
```

## core/game_root.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://gameroot001"]

[ext_resource type="Script" path="res://core/autoloads/game_root.gd" id="1_gameroot"]

[node name="GameRoot" type="Node"]
script = ExtResource("1_gameroot")

[node name="SceneContainer" type="Node" parent="."]
```

## features/debug/debug_version_panel.gd

```text
extends Control

@onready var label = self


func _ready():
	var text := "=== DEBUG VERSION INFO ===\n\n"
	text += load_build_info()
	text += "\n"
	text += load_doc_status()

	label.text = text


func load_build_info() -> String:
	var path = "res://documentation/build_info.json"
	if not FileAccess.file_exists(path):
		return "Build info: NOT AVAILABLE\n"

	var file = FileAccess.open(path, FileAccess.READ)
	if file == null:
		return "Build info: FAILED TO OPEN\n"

	var content = file.get_as_text()
	var data = JSON.parse_string(content)

	if typeof(data) != TYPE_DICTIONARY:
		return "Build info: INVALID JSON\n"

	var text := "=== BUILD INFO ===\n"
	text += "Game Version : %s\n" % data.get("game_version", "unknown")
	text += "Git Commit   : %s\n" % data.get("git_commit", "unknown")
	text += "Git Branch   : %s\n" % data.get("git_branch", "unknown")
	text += "Build Date   : %s\n" % data.get("build_date", "unknown")

	if data.get("git_dirty", false):
		text += "Working Tree : DIRTY ‚ö†Ô∏è\n"
	else:
		text += "Working Tree : CLEAN\n"

	return text


func load_doc_status() -> String:
	var path = "res://documentation/DOCUMENTATION_STATUS.md"
	if not FileAccess.file_exists(path):
		return "Documentation status: NOT AVAILABLE\n"

	var file = FileAccess.open(path, FileAccess.READ)
	if file == null:
		return "Documentation status: FAILED TO OPEN\n"

	return "Documentation status: AVAILABLE\n"
```

## features/menu/main_menu.gd

```text
extends Control
## Menu Principal - Point d'entr√©e du jeu
## Utilise SceneLoader pour les transitions et EventBus pour la communication

class_name MainMenu

# R√©f√©rences aux n≈ìuds UI
@onready var start_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/StartButton
@onready var continue_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/ContinueButton
@onready var options_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/OptionsButton
@onready var credits_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/CreditsButton
@onready var quit_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/QuitButton
@onready var title_label: Label = $MarginContainer/VBoxContainer/TitleLabel
@onready var version_label: Label = $MarginContainer/VBoxContainer/VersionLabel

# √âtat
var has_save: bool = false

func _ready() -> void:
	# V√©rifier les sauvegardes disponibles
	_check_save_availability()
	
	# Connexion √† l'EventBus
	GameRoot.event_bus.safe_connect("game_started", _on_game_started)
	GameRoot.event_bus.safe_connect("game_loaded", _on_game_loaded)
	
	# Animation d'entr√©e
	_play_intro_animation()
	
	print("[MainMenu] Initialis√©")

## Auto-connexion des signaux via SceneLoader
func _get_signal_connections() -> Array:
	"""
	Retourne une liste de connexions de signaux pour SceneLoader.
	Cette m√©thode est appel√©e automatiquement par SceneLoader.
	"""
	if not is_node_ready():
		return []
	
	return [
		{
			"source": start_button,
			"signal_name": "pressed",
			"target": self,
			"method": "_on_start_pressed"
		},
		{
			"source": continue_button,
			"signal_name": "pressed",
			"target": self,
			"method": "_on_continue_pressed"
		},
		{
			"source": options_button,
			"signal_name": "pressed",
			"target": self,
			"method": "_on_options_pressed"
		},
		{
			"source": credits_button,
			"signal_name": "pressed",
			"target": self,
			"method": "_on_credits_pressed"
		},
		{
			"source": quit_button,
			"signal_name": "pressed",
			"target": self,
			"method": "_on_quit_pressed"
		},
	]

# ============================================================================
# INITIALISATION
# ============================================================================

func _check_save_availability() -> void:
	"""V√©rifie si une sauvegarde existe"""
	# TODO: Impl√©menter la v√©rification r√©elle des sauvegardes
	has_save = false
	
	# D√©sactiver le bouton Continuer si pas de sauvegarde
	continue_button.disabled = not has_save
	
	if not has_save:
		continue_button.modulate.a = 0.5

func _play_intro_animation() -> void:
	"""Animation d'entr√©e du menu"""
	title_label.modulate.a = 0.0
	
	var tween = create_tween()
	tween.set_parallel(true)
	tween.tween_property(title_label, "modulate:a", 1.0, 0.8).set_ease(Tween.EASE_OUT)
	tween.tween_property(title_label, "position:y", title_label.position.y, 0.8).from(title_label.position.y - 50).set_ease(Tween.EASE_OUT)

# ============================================================================
# CALLBACKS BOUTONS
# ============================================================================

func _on_start_pressed() -> void:
	"""D√©marrer une nouvelle partie"""
	print("[MainMenu] Nouvelle partie")
	
	# Notification
	GameRoot.event_bus.notify("D√©marrage d'une nouvelle partie...", "info")
	
	# √âmettre l'√©v√©nement de d√©but de jeu
	GameRoot.event_bus.game_started.emit()
	
	# Transition vers la carte du monde
	GameRoot.event_bus.change_scene(SceneRegistry.SceneID.WORLD_MAP)

func _on_continue_pressed() -> void:
	"""Continuer la derni√®re sauvegarde"""
	if not has_save:
		return
	
	print("[MainMenu] Chargement de la derni√®re sauvegarde")
	
	# TODO: Charger la sauvegarde via GameManager
	GameRoot.event_bus.notify("Chargement de la partie...", "info")
	GameRoot.game_manager.load_game("auto_save")
	
	# Transition vers la sc√®ne sauvegard√©e
	GameRoot.event_bus.change_scene(SceneRegistry.SceneID.WORLD_MAP)

func _on_options_pressed() -> void:
	"""Ouvrir le menu des options"""
	print("[MainMenu] Options")
	GameRoot.event_bus.notify("Options (√† impl√©menter)", "info")
	
	# TODO: Quand la sc√®ne options sera cr√©√©e
	# GameRoot.event_bus.change_scene(SceneRegistry.SceneID.OPTIONS_MENU)

func _on_credits_pressed() -> void:
	"""Afficher les cr√©dits"""
	print("[MainMenu] Cr√©dits")
	GameRoot.event_bus.notify("Cr√©dits (√† impl√©menter)", "info")
	
	# TODO: Quand la sc√®ne cr√©dits sera cr√©√©e
	# GameRoot.event_bus.change_scene(SceneRegistry.SceneID.CREDITS)

func _on_quit_pressed() -> void:
	"""Quitter le jeu"""
	print("[MainMenu] Quitter le jeu")
	
	# Animation de sortie
	var tween = create_tween()
	tween.tween_property(self, "modulate:a", 0.0, 0.3)
	await tween.finished
	
	# √âmettre la demande de fermeture via EventBus
	GameRoot.event_bus.quit_game_requested.emit()

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_game_started() -> void:
	"""R√©action au d√©marrage du jeu"""
	print("[MainMenu] Le jeu d√©marre (EventBus)")

func _on_game_loaded(save_name: String) -> void:
	"""R√©action au chargement d'une sauvegarde"""
	print("[MainMenu] Sauvegarde charg√©e : ", save_name)

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	# Raccourci clavier pour d√©marrer rapidement (DEBUG)
	if OS.is_debug_build():
		if event.is_action_pressed("ui_accept") and not event.is_echo():
			_on_start_pressed()

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	"""Nettoyage √† la fermeture de la sc√®ne"""
	GameRoot.event_bus.disconnect_all(self)
	print("[MainMenu] Sc√®ne nettoy√©e")
```

## features/menu/main_menu.tscn

```text
[gd_scene load_steps=3 format=3 uid="uid://ceiip1bmiqtbi"]

[ext_resource type="Script" uid="uid://cvalg4aho3bsa" path="res://features/menu/main_menu.gd" id="1_main_menu"]
[ext_resource type="Script" uid="uid://dfcb31h84rfiv" path="res://features/debug/debug_version_panel.gd" id="2_3rkf3"]

[node name="MainMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_main_menu")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.1, 0.1, 0.15, 1)

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 100
theme_override_constants/margin_top = 80
theme_override_constants/margin_right = 100
theme_override_constants/margin_bottom = 80

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 30
alignment = 1

[node name="TitleLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 6
theme_override_colors/font_color = Color(0.9, 0.85, 0.7, 1)
theme_override_font_sizes/font_size = 72
text = "AKRIB TACTICAL RPG TEST"
horizontal_alignment = 1

[node name="SubtitleLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.7, 0.65, 0.5, 1)
theme_override_font_sizes/font_size = 24
text = "documentation status"
horizontal_alignment = 1
script = ExtResource("2_3rkf3")

[node name="Spacer1" type="Control" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2

[node name="ButtonsContainer" type="VBoxContainer" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 20

[node name="StartButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚ñ∂ Nouvelle Partie"

[node name="ContinueButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚Üª Continuer"

[node name="OptionsButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚öô Options"

[node name="CreditsButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚Ñπ Cr√©dits"

[node name="QuitButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚úï Quitter"

[node name="Spacer2" type="Control" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2

[node name="VersionLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.7, 0.65, 0.5, 1)
theme_override_font_sizes/font_size = 24
text = "documentation status"
horizontal_alignment = 1
```

## Statistics

- Total Files: 24
- Total Characters: 132294
- Total Tokens: 0

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-02-06 01:04:22

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
core
  autoloads
    battle_data_manager.gd
    campaign_manager.gd
    debug_overlay.gd
    dialogue_manager.gd
    event_bus.gd
    game_manager.gd
    game_root.gd
    game_root.tscn
    global_logger.gd
    scene_loader.gd
    team_manager.gd
    ui_manager.gd
    version_manager.gd
  data
    ability_data_loader.gd
    json_data_loader.gd
    model_validator.gd
    scene_registry.gd
    validation_result.gd
  dialogue
    bark_system.gd
    dialogue_box.gd
    dialogue_box.tscn
    dialogue_data.gd
    dialogue_data_loader.gd
  game_root.tscn
features
  debug
    debug_version_panel.gd
  menu
    main_menu.gd
    main_menu.tscn
  world_map
    logic
      world_map.gd
      world_map_connection.gd
      world_map_data_loader.gd
      world_map_location.gd
      world_map_player.gd
    visuals
      world_map.tscn
```

# Repository Files


## core/autoloads/battle_data_manager.gd

```text
# scripts/core/battle_data_manager.gd
extends Node
## BattleDataManager - Gestionnaire centralisÃ© des donnÃ©es de combat
## Autoload dÃ©diÃ© au stockage et Ã  la validation des donnÃ©es de bataille
## 
## ResponsabilitÃ©s :
## - Stocker les donnÃ©es du combat actuel
## - Valider la structure des donnÃ©es
## - Fournir un accÃ¨s thread-safe
## - Nettoyer aprÃ¨s usage
##
## AccÃ¨s via : GameRoot.battle_data_manager

class_name BattleDataManagerClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal battle_data_stored(battle_id: String)
signal battle_data_cleared()
signal battle_data_invalid(errors: Array)

# ============================================================================
# DONNÃ‰ES
# ============================================================================

var _current_battle_data: Dictionary = {}
var _is_data_valid: bool = false
var _battle_id: String = ""

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# Attendre que GameRoot soit prÃªt
	call_deferred("_connect_signals")
	print("[BattleDataManager] âœ… InitialisÃ©")

func _connect_signals() -> void:
	"""Connexion aux signaux de GameRoot"""
	await get_tree().process_frame
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("battle_ended", _on_battle_ended)

# ============================================================================
# STOCKAGE
# ============================================================================

## Stocke les donnÃ©es d'un combat
func set_battle_data(data: Dictionary) -> bool:
	"""
	Stocke les donnÃ©es de combat aprÃ¨s validation
	
	@param data : Dictionnaire contenant les donnÃ©es de combat
	@return true si stockage rÃ©ussi, false si donnÃ©es invalides
	"""
	
	var result = ModelValidator.validate(data, "battle")

	if not result.is_valid:
		if GameRoot and GameRoot.global_logger:
			GameRoot.global_logger.error("BATTLE_DATA", "Validation Ã©chouÃ©e : " + str(result.errors))
		push_error("[BattleDataManager] âŒ DonnÃ©es invalides : ", result.errors)
		battle_data_invalid.emit(result.errors)
		return false

	# ðŸ”¥ IMPORTANT : rÃ©cupÃ©rer les donnÃ©es normalisÃ©es
	_current_battle_data = result.data.duplicate(true)
	_is_data_valid = true
	_battle_id = data.get("battle_id", "unknown_" + str(Time.get_unix_time_from_system()))
	
	print("[BattleDataManager] âœ… DonnÃ©es stockÃ©es : ", _battle_id)
	battle_data_stored.emit(_battle_id)
	
	return true

## RÃ©cupÃ¨re les donnÃ©es du combat actuel
func get_battle_data() -> Dictionary:
	"""
	Retourne les donnÃ©es du combat actuel
	
	@return Dictionary avec les donnÃ©es, ou {} si aucune donnÃ©e valide
	"""
	
	if not _is_data_valid:
		push_warning("[BattleDataManager] âš ï¸ Aucune donnÃ©e de combat valide")
		return {}
	
	print("[BattleDataManager] ðŸ“¦ RÃ©cupÃ©ration des donnÃ©es : ", _battle_id)
	return _current_battle_data.duplicate(true)

## VÃ©rifie si des donnÃ©es sont disponibles
func has_battle_data() -> bool:
	"""VÃ©rifie si des donnÃ©es de combat valides sont stockÃ©es"""
	return _is_data_valid and not _current_battle_data.is_empty()

## RÃ©cupÃ¨re l'ID du combat actuel
func get_battle_id() -> String:
	"""Retourne l'ID du combat actuel"""
	return _battle_id

# ============================================================================
# NETTOYAGE
# ============================================================================

## Efface les donnÃ©es du combat actuel
func clear_battle_data() -> void:
	"""
	Nettoie les donnÃ©es de combat
	AppelÃ© automatiquement aprÃ¨s la bataille
	"""
	
	if _is_data_valid:
		print("[BattleDataManager] ðŸ§¹ Nettoyage des donnÃ©es : ", _battle_id)
	
	_current_battle_data.clear()
	_is_data_valid = false
	_battle_id = ""
	
	battle_data_cleared.emit()

## Efface les donnÃ©es de maniÃ¨re forcÃ©e (emergency)
func force_clear() -> void:
	"""Nettoyage forcÃ© en cas d'erreur critique"""
	push_warning("[BattleDataManager] âš ï¸ Nettoyage forcÃ© des donnÃ©es")
	clear_battle_data()


# ============================================================================
# DEBUG
# ============================================================================

## Affiche les donnÃ©es actuelles (debug)
func debug_print_data() -> void:
	"""Affiche les donnÃ©es de combat pour debug"""
	
	if not _is_data_valid:
		print("[BattleDataManager] ðŸ› Aucune donnÃ©e Ã  afficher")
		return
	
	print("\n=== BattleDataManager DEBUG ===")
	print("Battle ID : ", _battle_id)
	print("Player Units : ", _current_battle_data.get("player_units", []).size())
	print("Enemy Units : ", _current_battle_data.get("enemy_units", []).size())
	print("Terrain : ", _current_battle_data.get("terrain", "N/A"))
	print("================================\n")

## Retourne les statistiques du combat actuel
func get_battle_stats() -> Dictionary:
	"""Retourne des statistiques sur le combat actuel"""
	
	if not _is_data_valid:
		return {}
	
	return {
		"battle_id": _battle_id,
		"player_unit_count": _current_battle_data.get("player_units", []).size(),
		"enemy_unit_count": _current_battle_data.get("enemy_units", []).size(),
		"has_objectives": _current_battle_data.has("objectives"),
		"has_scenario": _current_battle_data.has("scenario"),
		"terrain_type": _current_battle_data.get("terrain", "unknown")
	}

# ============================================================================
# CALLBACKS
# ============================================================================

func _on_battle_ended(_results: Dictionary) -> void:
	"""Nettoyage automatique aprÃ¨s la fin du combat"""
	clear_battle_data()

func _exit_tree() -> void:
	"""Nettoyage Ã  la fermeture"""
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
	
func _normalize_battle_data(data: Dictionary) -> void:
	# Player units
	if data.has("player_units"):
		for unit in data.player_units:
			# HP â†’ int
			unit.current_hp = int(unit.current_hp)
			unit.max_hp = int(unit.max_hp)

			# Position [x, y] â†’ Vector2i
			if unit.has("position") and unit.position is Array and unit.position.size() == 2:
				unit.position = Vector2i(
					int(unit.position[0]),
					int(unit.position[1])
				)

	# Enemy units
	if data.has("enemy_units"):
		for unit in data.enemy_units:
			unit.current_hp = int(unit.current_hp)
			unit.max_hp = int(unit.max_hp)

			if unit.has("position") and unit.position is Array and unit.position.size() == 2:
				unit.position = Vector2i(
					int(unit.position[0]),
					int(unit.position[1])
				)

	# Obstacles
	if data.has("terrain_obstacles"):
		for obs in data.terrain_obstacles:
			if obs.has("position") and obs.position is Array and obs.position.size() == 2:
				obs.position = Vector2i(
					int(obs.position[0]),
					int(obs.position[1])
				)
```

## core/autoloads/campaign_manager.gd

```text
extends Node
## CampaignManager - Gestion de la campagne et sÃ©quences narratives
## Autoload qui orchestre la progression, les combats et les sÃ©quences d'intro
##
## Absorbe la logique de IntroDialogue (sÃ©quences de dÃ©marrage)
## Les dialogues sont dÃ©lÃ©guÃ©s Ã  DialogueManager
## L'UI (DialogueBox) est gÃ©rÃ©e par UIManager (persistante)
##
## AccÃ¨s via : GameRoot.campaign_manager

class_name CampaignManagerClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal campaign_sequence_started(sequence_id: String)
signal campaign_sequence_ended(sequence_id: String)
signal battle_requested(battle_id: String)

# ============================================================================
# CONFIGURATION
# ============================================================================

const BATTLE_DATA_PATHS: Dictionary = {
	"tutorial": "res://data/battles/tutorial.json",
	"forest_battle": "res://data/battles/forest_battle.json",
	"village_defense": "res://data/battles/village_defense.json",
	"boss_fight": "res://data/battles/boss_fight.json"
}

const CAMPAIGN_START_PATH: String = "res://data/campaign/campaign_start.json"

# ============================================================================
# Ã‰TAT
# ============================================================================

var campaign_state: Dictionary = {
	"current_chapter": 1,
	"current_battle": 1,
	"battles_won": 0
}

var campaign_start_data: Dictionary = {}
var current_sequence_index: int = 0
var is_sequence_running: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	print("[CampaignManager] âœ… InitialisÃ© (mode JSON)")

# ============================================================================
# CALLBACKS EVENTBUS (connectÃ©s par GameRoot)
# ============================================================================

func _on_game_started() -> void:
	"""AppelÃ© quand le joueur lance 'Nouvelle Partie'"""
	print("[CampaignManager] ðŸŽ® Nouvelle partie - dÃ©marrage campagne")
	start_new_campaign()

func _on_battle_ended(results: Dictionary) -> void:
	"""AppelÃ© Ã  la fin d'un combat"""
	print("[CampaignManager] Combat terminÃ©")
	
	if results.get("victory", false):
		campaign_state.battles_won += 1
		_advance_campaign()

# ============================================================================
# DÃ‰MARRAGE DE CAMPAGNE
# ============================================================================

func start_new_campaign() -> void:
	"""DÃ©marre une nouvelle campagne avec la sÃ©quence d'intro"""
	print("[CampaignManager] ðŸŽ¬ DÃ©marrage nouvelle campagne")
	
	# Charger les donnÃ©es de campagne
	campaign_start_data = _load_campaign_start_from_json()
	
	if campaign_start_data.is_empty():
		push_warning("[CampaignManager] Pas de campaign_start.json, fallback direct")
		_fallback_to_world_map()
		return
	
	# Initialiser l'Ã©tat de la campagne
	if campaign_start_data.has("initial_state"):
		var initial_state = campaign_start_data.initial_state
		campaign_state.current_chapter = initial_state.get("chapter", 1)
		campaign_state.current_battle = initial_state.get("battle_index", 0)
		campaign_state.battles_won = initial_state.get("battles_won", 0)
	
	# Ã‰mettre l'Ã©vÃ©nement
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.campaign_started.emit()
	
	# ExÃ©cuter la sÃ©quence de dÃ©marrage
	if campaign_start_data.has("start_sequence"):
		await _execute_start_sequence()
	else:
		push_warning("[CampaignManager] Pas de start_sequence, fallback")
		_fallback_to_world_map()

# ============================================================================
# EXÃ‰CUTION DE SÃ‰QUENCES (ex-IntroDialogue)
# ============================================================================

func _execute_start_sequence() -> void:
	"""ExÃ©cute la sÃ©quence de dÃ©marrage dÃ©finie dans le JSON"""
	
	var sequence = campaign_start_data.start_sequence
	current_sequence_index = 0
	is_sequence_running = true
	
	campaign_sequence_started.emit("campaign_start")
	print("[CampaignManager] ðŸŽ¬ DÃ©but de la sÃ©quence (", sequence.size(), " Ã©tapes)")
	
	await _execute_next_step()
	
	is_sequence_running = false
	campaign_sequence_ended.emit("campaign_start")

func _execute_next_step() -> void:
	"""ExÃ©cute l'Ã©tape suivante de la sÃ©quence"""
	
	var sequence = campaign_start_data.start_sequence
	
	if current_sequence_index >= sequence.size():
		print("[CampaignManager] âœ… SÃ©quence terminÃ©e")
		return
	
	var step = sequence[current_sequence_index]
	var step_type = step.get("type", "")
	
	print("[CampaignManager] ðŸ“‹ Ã‰tape %d/%d : %s" % [
		current_sequence_index + 1, sequence.size(), step_type
	])
	
	match step_type:
		"dialogue":
			await _execute_dialogue_step(step)
		"transition":
			await _execute_transition_step(step)
		"notification":
			_execute_notification_step(step)
		"unlock_location":
			_execute_unlock_location_step(step)
		_:
			push_warning("[CampaignManager] Type d'Ã©tape inconnu : %s" % step_type)
	
	current_sequence_index += 1
	await _execute_next_step()

func _execute_dialogue_step(step: Dictionary) -> void:
	"""ExÃ©cute une Ã©tape de dialogue via DialogueManager + UIManager"""
	
	var dialogue_id = step.get("dialogue_id", "")
	var blocking = step.get("blocking", true)
	
	if dialogue_id == "":
		push_warning("[CampaignManager] dialogue_id vide")
		return
	
	print("[CampaignManager] ðŸ’¬ Dialogue : %s" % dialogue_id)
	
	# Charger les donnÃ©es du dialogue
	var dialogue_loader = DialogueDataLoader.new()
	var dialogue_data_dict = dialogue_loader.load_dialogue(dialogue_id)
	
	if dialogue_data_dict.is_empty():
		push_error("[CampaignManager] Dialogue introuvable : %s" % dialogue_id)
		return
	
	# Convertir en DialogueData
	var dialogue_data = _convert_to_dialogue_data(dialogue_data_dict)
	
	# DÃ©marrer via DialogueManager (utilise la DialogueBox persistante de UIManager)
	if GameRoot and GameRoot.dialogue_manager:
		GameRoot.dialogue_manager.start_dialogue(dialogue_data)
		
		# Attendre la fin si bloquant
		if blocking:
			await GameRoot.dialogue_manager.dialogue_ended
			print("[CampaignManager] âœ… Dialogue terminÃ©")

func _execute_transition_step(step: Dictionary) -> void:
	"""ExÃ©cute une transition vers une autre scÃ¨ne"""
	
	var target = step.get("target", "")
	var fade_duration = step.get("fade_duration", 1.0)
	
	print("[CampaignManager] ðŸŽžï¸ Transition vers : %s" % target)
	
	var scene_map = {
		"world_map": SceneRegistry.SceneID.WORLD_MAP,
		"battle": SceneRegistry.SceneID.BATTLE,
		"main_menu": SceneRegistry.SceneID.MAIN_MENU
	}
	
	if not scene_map.has(target):
		push_error("[CampaignManager] Cible de transition inconnue : %s" % target)
		return
	
	# Changer de scÃ¨ne via SceneLoader (gÃ¨re fade automatiquement)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.change_scene(scene_map[target])

func _execute_notification_step(step: Dictionary) -> void:
	"""Affiche une notification"""
	var message = step.get("message", "")
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify(message, "info")

func _execute_unlock_location_step(step: Dictionary) -> void:
	"""DÃ©verrouille une location sur la world map"""
	var location = step.get("location", "")
	print("[CampaignManager] ðŸ”“ DÃ©verrouillage : %s" % location)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.location_discovered.emit(location)

# ============================================================================
# LANCEMENT DE COMBAT
# ============================================================================

func start_battle(battle_id: String) -> void:
	"""Charge et lance un combat depuis son ID"""
	print("[CampaignManager] ðŸŽ¯ Chargement du combat : %s" % battle_id)
	
	var battle_data = load_battle_data_from_json(battle_id)
	
	if battle_data.is_empty():
		push_error("[CampaignManager] Impossible de charger : %s" % battle_id)
		return
	
	# Merger avec la team du joueur
	battle_data = _merge_player_team(battle_data)
	
	# Ajouter un ID unique
	battle_data["battle_id"] = battle_id + "_" + str(Time.get_unix_time_from_system())
	
	# Stocker dans BattleDataManager
	if not GameRoot or not GameRoot.battle_data_manager:
		push_error("[CampaignManager] BattleDataManager non disponible")
		return
	
	var stored = GameRoot.battle_data_manager.set_battle_data(battle_data)
	
	if stored:
		print("[CampaignManager] âœ… DonnÃ©es de combat stockÃ©es")
		GameRoot.event_bus.change_scene(SceneRegistry.SceneID.BATTLE)
	else:
		push_error("[CampaignManager] âŒ Ã‰chec du stockage des donnÃ©es")

func load_battle_data_from_json(battle_id: String) -> Dictionary:
	"""Charge un fichier JSON de donnÃ©es de combat"""
	
	# Essayer le chemin depuis BATTLE_DATA_PATHS
	var json_path = BATTLE_DATA_PATHS.get(battle_id, "")
	
	# Sinon essayer le chemin gÃ©nÃ©rique
	if json_path == "":
		json_path = "res://data/battles/%s.json" % battle_id
	
	if not FileAccess.file_exists(json_path):
		push_error("[CampaignManager] Fichier de combat introuvable : %s" % json_path)
		return {}
	
	var json_loader = JSONDataLoader.new()
	var battle_data = json_loader.load_json_file(json_path)
	
	if typeof(battle_data) != TYPE_DICTIONARY or battle_data.is_empty():
		push_error("[CampaignManager] DonnÃ©es invalides : %s" % battle_id)
		return {}
	
	# Convertir les positions JSON
	battle_data = _convert_json_positions(battle_data)
	
	print("[CampaignManager] âœ… Battle data chargÃ©e : %s" % battle_id)
	return battle_data

# ============================================================================
# MERGE TEAM JOUEUR
# ============================================================================

func _merge_player_team(battle_data: Dictionary) -> Dictionary:
	"""Fusionne l'Ã©quipe du joueur avec les alliÃ©s du scÃ©nario"""
	
	var result = battle_data.duplicate(true)
	
	if not GameRoot or not GameRoot.team_manager:
		return result
	
	var team = GameRoot.team_manager.get_current_team()
	var team_units: Array = []
	
	for i in range(team.size()):
		var unit = team[i]
		var battle_unit = _convert_team_unit_to_battle(unit, i)
		team_units.append(battle_unit)
	
	# DÃ©caler les alliÃ©s du scÃ©nario
	if result.has("player_units"):
		for ally in result.player_units:
			if ally.has("position"):
				ally.position.x += 2
	else:
		result["player_units"] = []
	
	# Ajouter la team au dÃ©but
	for unit in team_units:
		result.player_units.insert(0, unit)
	
	print("[CampaignManager] âœ… Team mergÃ©e : %d + %d alliÃ©s" % [
		team_units.size(), result.player_units.size() - team_units.size()
	])
	
	return result

func _convert_team_unit_to_battle(unit: Dictionary, index: int) -> Dictionary:
	return {
		"id": unit.get("instance_id", unit.get("id")),
		"name": unit.get("name"),
		"position": Vector2i(2, 6 + index),
		"stats": unit.get("stats", {}).duplicate(),
		"abilities": unit.get("abilities", []).duplicate(),
		"color": unit.get("color", {"r": 0.5, "g": 0.5, "b": 0.8, "a": 1.0}),
		"level": unit.get("level", 1),
		"xp": unit.get("xp", 0),
		"current_hp": unit.get("current_hp", unit.get("stats", {}).get("hp", 100))
	}

# ============================================================================
# CONVERSIONS JSON
# ============================================================================

func _convert_json_positions(data: Dictionary) -> Dictionary:
	var result = data.duplicate(true)
	
	for key in ["player_units", "enemy_units"]:
		if result.has(key):
			for unit in result[key]:
				if unit.has("position"):
					var pos = unit.position
					if pos is Array and pos.size() == 2:
						unit.position = Vector2i(int(pos[0]), int(pos[1]))
					elif pos is Dictionary:
						unit.position = Vector2i(pos.get("x", 0), pos.get("y", 0))
	
	if result.has("terrain_obstacles"):
		for obs in result.terrain_obstacles:
			if obs.has("position"):
				var pos = obs.position
				if pos is Array and pos.size() == 2:
					obs.position = Vector2i(int(pos[0]), int(pos[1]))
				elif pos is Dictionary:
					obs.position = Vector2i(pos.get("x", 0), pos.get("y", 0))
	
	if result.has("grid_size") and result["grid_size"] is Dictionary:
		var grid = result["grid_size"]
		if grid.has("width") and grid.has("height"):
			result["grid_size"] = Vector2i(int(grid["width"]), int(grid["height"]))
	
	return result

func _convert_to_dialogue_data(data_dict: Dictionary) -> DialogueData:
	"""Convertit un dictionnaire JSON en DialogueData"""
	
	var dialogue = DialogueData.new(data_dict.get("id", ""))
	
	# Traiter les sÃ©quences
	if data_dict.has("sequences"):
		for sequence in data_dict.sequences:
			if sequence.has("lines"):
				for line in sequence.lines:
					dialogue.add_line({
						"speaker": line.get("speaker", ""),
						"text": line.get("text", ""),
						"emotion": line.get("emotion", "neutral"),
						"auto_advance": false
					})
	
	# Traiter les lignes directes
	if data_dict.has("lines"):
		for line in data_dict.lines:
			dialogue.add_line(line)
	
	return dialogue

# ============================================================================
# CHARGEMENT JSON
# ============================================================================

func _load_campaign_start_from_json() -> Dictionary:
	if not FileAccess.file_exists(CAMPAIGN_START_PATH):
		push_warning("[CampaignManager] Fichier introuvable : %s" % CAMPAIGN_START_PATH)
		return {}
	
	var json_loader = JSONDataLoader.new()
	var data = json_loader.load_json_file(CAMPAIGN_START_PATH)
	
	if typeof(data) != TYPE_DICTIONARY or data.is_empty():
		push_error("[CampaignManager] Format invalide pour campaign_start.json")
		return {}
	
	return data

# ============================================================================
# PROGRESSION
# ============================================================================

func _advance_campaign() -> void:
	campaign_state.current_battle += 1
	# TODO: Logique de progression (chapitres, etc.)

func get_campaign_state() -> Dictionary:
	return campaign_state.duplicate()

# ============================================================================
# FALLBACK
# ============================================================================

func _fallback_to_world_map() -> void:
	"""En cas d'erreur, aller directement Ã  la world map"""
	print("[CampaignManager] âš ï¸ Fallback vers World Map")
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Bienvenue dans le jeu !", "info")
	
	await get_tree().create_timer(1.0).timeout
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.change_scene(SceneRegistry.SceneID.WORLD_MAP)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## core/autoloads/debug_overlay.gd

```text
extends CanvasLayer
## DebugOverlay - Interface de debug en jeu (F3)
## Affiche les informations de debug, FPS, Ã©tat du jeu
##
## AccÃ¨s via : GameRoot.debug_overlay

class_name DebugOverlayClass

# ============================================================================
# CONFIGURATION
# ============================================================================

const PANEL_WIDTH: int = 450
const PANEL_MIN_HEIGHT: int = 400

# ============================================================================
# RÃ‰FÃ‰RENCES UI
# ============================================================================

var panel: PanelContainer = null
var info_label: RichTextLabel = null
var log_label: RichTextLabel = null

# ============================================================================
# Ã‰TAT
# ============================================================================

var is_visible: bool = false
var watched_variables: Dictionary = {}  # key -> { object: Node, property: String }
var show_logs: bool = true

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	layer = 110  # Au-dessus de tout
	name = "DebugOverlay"
	
	_create_ui()
	visible = false
	
	print("[DebugOverlay] âœ… InitialisÃ© (F3 pour afficher)")

func _create_ui() -> void:
	"""CrÃ©e l'interface de debug"""
	
	# Panel principal
	panel = PanelContainer.new()
	panel.name = "DebugPanel"
	panel.position = Vector2(10, 10)
	panel.custom_minimum_size = Vector2(PANEL_WIDTH, PANEL_MIN_HEIGHT)
	
	# Style du panel
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.05, 0.05, 0.1, 0.9)
	style.border_width_left = 2
	style.border_width_top = 2
	style.border_width_right = 2
	style.border_width_bottom = 2
	style.border_color = Color(0.3, 0.3, 0.5)
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	panel.add_theme_stylebox_override("panel", style)
	
	add_child(panel)
	
	# Margin
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 15)
	margin.add_theme_constant_override("margin_top", 15)
	margin.add_theme_constant_override("margin_right", 15)
	margin.add_theme_constant_override("margin_bottom", 15)
	panel.add_child(margin)
	
	# VBox pour organiser
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 10)
	margin.add_child(vbox)
	
	# Label d'info principal
	info_label = RichTextLabel.new()
	info_label.bbcode_enabled = true
	info_label.fit_content = true
	info_label.scroll_active = false
	info_label.custom_minimum_size = Vector2(0, 200)
	vbox.add_child(info_label)
	
	# SÃ©parateur
	var separator = HSeparator.new()
	vbox.add_child(separator)
	
	# Label des logs rÃ©cents
	var log_title = Label.new()
	log_title.text = "ðŸ“œ Logs rÃ©cents"
	log_title.add_theme_color_override("font_color", Color(0.7, 0.7, 0.9))
	vbox.add_child(log_title)
	
	var scroll = ScrollContainer.new()
	scroll.custom_minimum_size = Vector2(0, 150)
	scroll.size_flags_vertical = Control.SIZE_EXPAND_FILL
	vbox.add_child(scroll)
	
	log_label = RichTextLabel.new()
	log_label.bbcode_enabled = true
	log_label.fit_content = true
	log_label.scroll_active = false
	scroll.add_child(log_label)

# ============================================================================
# VISIBILITÃ‰
# ============================================================================

func toggle_visibility() -> void:
	"""Inverse la visibilitÃ© de l'overlay"""
	is_visible = not is_visible
	visible = is_visible

func show_overlay() -> void:
	"""Affiche l'overlay"""
	is_visible = true
	visible = true

func hide_overlay() -> void:
	"""Cache l'overlay"""
	is_visible = false
	visible = false

# ============================================================================
# MISE Ã€ JOUR
# ============================================================================

func _process(_delta: float) -> void:
	if not is_visible:
		return
	
	_update_display()

func _update_display() -> void:
	"""Met Ã  jour l'affichage"""
	
	var text = "[b][color=cyan]â•â•â• DEBUG OVERLAY â•â•â•[/color][/b]\n\n"
	
	# Performance
	text += "[b][color=yellow]Performance[/color][/b]\n"
	text += "  FPS: [color=lime]%d[/color]\n" % Engine.get_frames_per_second()
	
	var mem_static = OS.get_static_memory_usage() / 1024.0 / 1024.0
	text += "  MÃ©moire: [color=lime]%.2f MB[/color]\n\n" % mem_static
	
	# GameRoot Status (via autoload)
	if GameRoot:
		text += "[b][color=yellow]GameRoot[/color][/b]\n"
		text += "  EventBus: %s\n" % _status_icon(GameRoot.event_bus != null)
		text += "  SceneLoader: %s\n" % _status_icon(GameRoot.scene_loader != null)
		text += "  GameManager: %s\n" % _status_icon(GameRoot.game_manager != null)
		text += "  UIManager: %s\n" % _status_icon(GameRoot.ui_manager != null)
		text += "  GlobalLogger: %s\n\n" % _status_icon(GameRoot.global_logger != null)
		
		# ScÃ¨ne actuelle
		if GameRoot.scene_loader:
			var scene_name = GameRoot.scene_loader.get_current_scene_name()
			var is_loading = GameRoot.scene_loader.is_loading
			text += "[b][color=yellow]ScÃ¨ne[/color][/b]\n"
			text += "  Actuelle: [color=white]%s[/color]\n" % scene_name
			text += "  Loading: %s\n\n" % _status_icon(is_loading, "ðŸ”„", "âœ…")
		
		# Ã‰tat du jeu
		if GameRoot.game_manager:
			text += "[b][color=yellow]Ã‰tat[/color][/b]\n"
			text += "  Pause: %s\n\n" % _status_icon(GameRoot.game_manager.is_paused, "â¸ï¸", "â–¶ï¸")
	
	# Variables surveillÃ©es
	if not watched_variables.is_empty():
		text += "[b][color=yellow]Variables[/color][/b]\n"
		
		for key in watched_variables:
			var entry = watched_variables[key]
			var obj = entry.object
			var prop = entry.property
			
			if is_instance_valid(obj):
				var value = obj.get(prop)
				if value != null:
					text += "  [color=cyan]%s:[/color] %s\n" % [key, _format_value(value)]
		
		text += "\n"
	
	info_label.text = text
	
	# Logs rÃ©cents
	if show_logs and GameRoot and GameRoot.global_logger:
		var log_text = ""
		var recent_logs = GameRoot.global_logger.get_recent_logs(10)
		
		for entry in recent_logs:
			var color = "white"
			match entry.level:
				GlobalLoggerClass.LogLevel.DEBUG:
					color = "gray"
				GlobalLoggerClass.LogLevel.WARNING:
					color = "yellow"
				GlobalLoggerClass.LogLevel.ERROR:
					color = "red"
			
			log_text += "[color=%s][%s] %s[/color]\n" % [color, entry.category, entry.message]
		
		log_label.text = log_text

func _status_icon(condition: bool, true_icon: String = "âœ…", false_icon: String = "âŒ") -> String:
	return true_icon if condition else false_icon

func _format_value(value: Variant) -> String:
	"""Formate une valeur pour l'affichage"""
	
	if value is Array:
		return "Array[%d]" % value.size()
	elif value is Dictionary:
		return "Dict[%d]" % value.size()
	elif value is Vector2 or value is Vector2i:
		return "(%s, %s)" % [value.x, value.y]
	elif value is Vector3:
		return "(%.1f, %.1f, %.1f)" % [value.x, value.y, value.z]
	else:
		return str(value)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func watch_variable(key: String, object: Node, property: String) -> void:
	"""Surveille une variable pour l'afficher dans l'overlay"""
	watched_variables[key] = {"object": object, "property": property}

func unwatch_variable(key: String) -> void:
	"""ArrÃªte de surveiller une variable"""
	watched_variables.erase(key)

func clear_watched() -> void:
	"""Supprime toutes les variables surveillÃ©es"""
	watched_variables.clear()

func set_show_logs(show: bool) -> void:
	"""Active/dÃ©sactive l'affichage des logs"""
	show_logs = show

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	# Le toggle est gÃ©rÃ© par GameRoot
	pass
```

## core/autoloads/dialogue_manager.gd

```text
extends Node
## DialogueManager - Gestionnaire central du systÃ¨me de dialogue
## Autoload qui orchestre tous les dialogues du jeu
##
## Utilise la DialogueBox persistante de UIManager (toujours en mÃ©moire)
## Les scÃ¨nes n'ont plus besoin d'embarquer leur propre DialogueBox
##
## AccÃ¨s via : GameRoot.dialogue_manager

class_name DialogueManagerClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal dialogue_started(dialogue_id: String)
signal dialogue_line_shown(line_data: Dictionary)
signal dialogue_choices_shown(choices: Array)
signal dialogue_choice_selected(choice_index: int)
signal dialogue_ended(dialogue_id: String)
signal bark_requested(speaker: String, text: String, position: Vector2)

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var default_text_speed: float = 50.0
@export var default_auto_advance_delay: float = 2.0
@export var enable_skip: bool = true
@export var enable_auto_mode: bool = false
@export var dialogue_sfx_volume: float = 0.0

@export var reading_speed_chars_per_second: float = 15.0
@export var minimum_reading_time: float = 1.5
@export var maximum_reading_time: float = 8.0

# ============================================================================
# Ã‰TAT
# ============================================================================

var current_dialogue = null  # DialogueData
var current_line_index: int = 0
var is_dialogue_active: bool = false

## DialogueBox persistante (assignÃ©e par GameRoot depuis UIManager)
var persistent_dialogue_box: DialogueBoxClass = null

## DialogueBox active (persistante ou override temporaire)
var dialogue_box: DialogueBoxClass = null

var bark_system = null

var text_speed: float = 50.0
var auto_mode: bool = false
var is_skippable: bool = true

var dialogue_history: Array[Dictionary] = []
var max_history_size: int = 100

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	text_speed = default_text_speed
	auto_mode = enable_auto_mode
	
	if ClassDB.class_exists("BarkSystem"):
		bark_system = ClassDB.instantiate("BarkSystem")
		add_child(bark_system)
	
	call_deferred("_connect_to_event_bus")
	
	print("[DialogueManager] âœ… InitialisÃ©")

func _connect_to_event_bus() -> void:
	await get_tree().process_frame
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("dialogue_started", _on_eventbus_dialogue_started)
		GameRoot.event_bus.safe_connect("dialogue_ended", _on_eventbus_dialogue_ended)

## AppelÃ© par GameRoot aprÃ¨s la crÃ©ation de UIManager
func set_persistent_dialogue_box(box: DialogueBoxClass) -> void:
	"""Configure la DialogueBox persistante de UIManager"""
	persistent_dialogue_box = box
	print("[DialogueManager] ðŸ”— DialogueBox persistante connectÃ©e")

# ============================================================================
# DÃ‰MARRAGE DE DIALOGUE
# ============================================================================

## DÃ©marre un dialogue (utilise la DialogueBox persistante par dÃ©faut)
func start_dialogue(dialogue, override_dialogue_box: DialogueBoxClass = null) -> void:
	"""
	DÃ©marre un nouveau dialogue.
	
	@param dialogue : DialogueData Ã  afficher
	@param override_dialogue_box : DialogueBox spÃ©cifique (optionnel)
		Si null, utilise la DialogueBox persistante de UIManager
	"""
	
	if is_dialogue_active:
		push_warning("[DialogueManager] Un dialogue est dÃ©jÃ  en cours")
		return
	
	if not dialogue or dialogue.lines.is_empty():
		push_error("[DialogueManager] Dialogue invalide ou vide")
		return
	
	current_dialogue = dialogue
	current_line_index = 0
	is_dialogue_active = true
	
	# SÃ©lectionner la DialogueBox Ã  utiliser
	if override_dialogue_box:
		dialogue_box = override_dialogue_box
	elif persistent_dialogue_box:
		dialogue_box = persistent_dialogue_box
	else:
		push_error("[DialogueManager] Aucune DialogueBox disponible")
		end_dialogue()
		return
	
	# Configurer la DialogueBox
	dialogue_box.dialogue_manager = self
	dialogue_box.show_dialogue_box()
	
	# Se connecter au signal de rÃ©vÃ©lation du texte
	if dialogue_box.has_signal("text_reveal_completed"):
		if not dialogue_box.text_reveal_completed.is_connected(_on_text_reveal_completed):
			dialogue_box.text_reveal_completed.connect(_on_text_reveal_completed)
	
	# Ã‰mettre les signaux
	dialogue_started.emit(dialogue.dialogue_id)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.dialogue_started.emit(dialogue.dialogue_id)
	
	# Afficher la premiÃ¨re ligne
	show_current_line()
	
	print("[DialogueManager] âœ… Dialogue dÃ©marrÃ© : %s" % dialogue.dialogue_id)

func start_dialogue_from_id(dialogue_id: String, override_dialogue_box: DialogueBoxClass = null) -> void:
	"""DÃ©marre un dialogue Ã  partir de son ID"""
	# TODO: ImplÃ©menter un systÃ¨me de registre de dialogues
	push_warning("[DialogueManager] start_dialogue_from_id non implÃ©mentÃ©")

# ============================================================================
# AFFICHAGE DES LIGNES
# ============================================================================

func show_current_line() -> void:
	if not current_dialogue or current_line_index >= current_dialogue.lines.size():
		end_dialogue()
		return
	
	var line = current_dialogue.lines[current_line_index]
	
	print("[DialogueManager] ðŸ“– Ligne %d/%d" % [current_line_index + 1, current_dialogue.lines.size()])
	
	_add_to_history(line)
	
	if line.has("choices") and not line.choices.is_empty():
		show_choices(line.choices)
		return
	
	if line.has("event"):
		_trigger_event(line.event)
		advance_dialogue()
		return
	
	dialogue_box.display_line(line)
	dialogue_line_shown.emit(line)

func _calculate_reading_time(line: Dictionary) -> float:
	if line.has("auto_delay"):
		return line.auto_delay
	
	var text = line.get("text", "")
	var text_key = line.get("text_key", "")
	
	if text_key:
		text = tr(text_key)
	
	var clean_text = _strip_bbcode(text)
	var char_count = clean_text.length()
	
	var reveal_speed = line.get("speed", default_text_speed)
	var reveal_time = char_count / reveal_speed
	var reading_time = char_count / reading_speed_chars_per_second
	var total_time = reveal_time + reading_time
	
	total_time = clamp(total_time, minimum_reading_time, maximum_reading_time)
	return total_time

func _strip_bbcode(text: String) -> String:
	var regex = RegEx.new()
	regex.compile("\\[[\\/]?[^\\]]*\\]")
	return regex.sub(text, "", true)

func show_choices(choices: Array) -> void:
	dialogue_box.display_choices(choices)
	dialogue_choices_shown.emit(choices)

func select_choice(choice_index: int) -> void:
	var line = current_dialogue.lines[current_line_index]
	
	if not line.has("choices") or choice_index >= line.choices.size():
		push_error("[DialogueManager] Index de choix invalide")
		return
	
	var choice = line.choices[choice_index]
	
	dialogue_choice_selected.emit(choice_index)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.choice_made.emit(current_dialogue.dialogue_id, choice_index)
	
	if choice.has("next_line"):
		current_line_index = choice.next_line
		show_current_line()
	elif choice.has("end_dialogue") and choice.end_dialogue:
		end_dialogue()
	else:
		advance_dialogue()

# ============================================================================
# NAVIGATION
# ============================================================================

func advance_dialogue() -> void:
	if not is_dialogue_active:
		return
	
	if dialogue_box and dialogue_box.is_text_revealing:
		dialogue_box.complete_text()
		return
	
	current_line_index += 1
	
	if current_line_index >= current_dialogue.lines.size():
		end_dialogue()
	else:
		show_current_line()

func skip_dialogue() -> void:
	if not is_skippable or not enable_skip:
		return
	end_dialogue()

func end_dialogue() -> void:
	if not is_dialogue_active:
		return
	
	var dialogue_id = current_dialogue.dialogue_id if current_dialogue else ""
	is_dialogue_active = false
	
	# DÃ©connecter les signaux
	if dialogue_box and dialogue_box.has_signal("text_reveal_completed"):
		if dialogue_box.text_reveal_completed.is_connected(_on_text_reveal_completed):
			dialogue_box.text_reveal_completed.disconnect(_on_text_reveal_completed)
	
	if dialogue_box:
		dialogue_box.hide_dialogue_box()
	
	# Ã‰mettre les signaux
	dialogue_ended.emit(dialogue_id)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.dialogue_ended.emit(dialogue_id)
	
	# Nettoyer
	current_dialogue = null
	current_line_index = 0
	
	# Remettre la DialogueBox par dÃ©faut (persistante)
	dialogue_box = persistent_dialogue_box
	
	print("[DialogueManager] ðŸ Dialogue terminÃ© : %s" % dialogue_id)

# ============================================================================
# BARKS
# ============================================================================

func show_bark(speaker: String, text_key: String, world_position: Vector2, duration: float = 2.0) -> void:
	if not bark_system:
		push_warning("[DialogueManager] BarkSystem non initialisÃ©")
		return
	
	var translated_text = tr(text_key)
	bark_system.show_bark(speaker, translated_text, world_position, duration)
	bark_requested.emit(speaker, translated_text, world_position)

# ============================================================================
# Ã‰VÃ‰NEMENTS
# ============================================================================

func _trigger_event(event_data: Dictionary) -> void:
	var event_type = event_data.get("type", "")
	
	match event_type:
		"set_variable":
			var key = event_data.get("key", "")
			var value = event_data.get("value", null)
			if key:
				print("[DialogueManager] Variable set : %s = %s" % [key, value])
		
		"play_sound":
			var sound_path = event_data.get("sound", "")
			if sound_path:
				print("[DialogueManager] Play sound : %s" % sound_path)
		
		"trigger_battle":
			var battle_id = event_data.get("battle_id", "")
			if battle_id and GameRoot and GameRoot.campaign_manager:
				GameRoot.campaign_manager.start_battle(battle_id)
		
		_:
			print("[DialogueManager] Ã‰vÃ©nement inconnu : %s" % event_type)

# ============================================================================
# HISTORIQUE
# ============================================================================

func _add_to_history(line: Dictionary) -> void:
	dialogue_history.append(line.duplicate())
	while dialogue_history.size() > max_history_size:
		dialogue_history.pop_front()

func get_history() -> Array[Dictionary]:
	return dialogue_history.duplicate()

func clear_history() -> void:
	dialogue_history.clear()

# ============================================================================
# CONFIGURATION
# ============================================================================

func set_text_speed(speed: float) -> void:
	text_speed = clamp(speed, 10.0, 200.0)

func set_auto_mode(enabled: bool) -> void:
	auto_mode = enabled

func toggle_auto_mode() -> void:
	auto_mode = not auto_mode
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Mode auto: " + ("ON" if auto_mode else "OFF"), "info")

func is_active() -> bool:
	return is_dialogue_active

# ============================================================================
# CALLBACKS
# ============================================================================

func _on_eventbus_dialogue_started(_dialogue_id: String) -> void:
	pass

func _on_eventbus_dialogue_ended(_dialogue_id: String) -> void:
	pass

func _on_text_reveal_completed() -> void:
	if not is_dialogue_active or not current_dialogue:
		return
	
	var line = current_dialogue.lines[current_line_index]
	
	if auto_mode and line.get("auto_advance", false):
		var delay = _calculate_reading_time(line)
		
		get_tree().create_timer(delay).timeout.connect(
			func():
				if is_dialogue_active and current_line_index < current_dialogue.lines.size():
					advance_dialogue()
		)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## core/autoloads/event_bus.gd

```text
extends Node
## EventBus - Hub de communication global dÃ©couplÃ©
## Permet aux scÃ¨nes de communiquer sans dÃ©pendances directes
##
## AccÃ¨s via : GameRoot.event_bus

class_name EventBusClass

# ============================================================================
# SIGNAUX GLOBAUX DU JEU
# ============================================================================

# --- SystÃ¨me ---
signal game_started()
signal game_paused(paused: bool)
signal game_saved(save_name: String)
signal game_loaded(save_name: String)
signal settings_changed(settings: Dictionary)

# --- Navigation ---
signal scene_change_requested(scene_id: int)
signal return_to_menu_requested()
signal quit_game_requested()

# --- Combat ---
signal battle_started(battle_data: Variant)
signal battle_ended(results: Dictionary)
signal duo_formed(unit_a: Node, unit_b: Node)
signal duo_broken(unit_a: Node, unit_b: Node)
signal unit_attacked(attacker: Node, target: Node, damage: int)
signal unit_died(unit: Node)
signal turn_started(unit: Node)
signal turn_ended(unit: Node)

# --- Statistiques & Progression ---
signal stats_updated(unit: Node, stat_name: String, new_value: float)
signal threat_level_changed(duo: Array, new_threat: float)
signal legend_gained(duo: Array, legend_type: String)
signal title_unlocked(unit: Node, title: String)
signal mvp_awarded(unit: Node, battle_id: String)

# --- DivinitÃ©s (SystÃ¨me de Foi) ---
signal divine_points_gained(god_name: String, points: int)
signal divine_threshold_reached(god_name: String, threshold: int)
signal divine_event_triggered(god_name: String, event_data: Dictionary)

# --- Monde & Narration ---
signal dialogue_started(dialogue_id: String)
signal dialogue_ended(dialogue_id: String)
signal choice_made(choice_id: String, option: int)
signal cutscene_started(cutscene_id: String)
signal cutscene_ended(cutscene_id: String)
signal location_discovered(location_name: String)
signal quest_updated(quest_id: String, status: String)

# --- Ressources ---
signal gold_changed(new_amount: int)
signal item_gained(item_id: String, quantity: int)
signal item_lost(item_id: String, quantity: int)

# --- UI ---
signal notification_posted(message: String, type: String)
signal tooltip_requested(content: String, position: Vector2)
signal tooltip_hidden()

# --- Dialogue ---
signal dialogue_bark_requested(speaker: String, text_key: String, position: Vector2)
signal dialogue_typewriter_completed()
signal dialogue_skip_requested()

# --- Campagne ---
signal campaign_started()
signal campaign_completed()
signal chapter_changed(chapter_id: int)

# --- Data Loading ---
signal data_loaded(data_type: String, data: Dictionary)
signal data_load_warning(data_type: String, warning: String)
signal ability_reloaded(ability_id: String)

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	print("[EventBus] âœ… InitialisÃ©")

# ============================================================================
# MÃ‰THODES UTILITAIRES
# ============================================================================

func emit_event(event_name: String, args: Array = [], debug: bool = false) -> void:
	"""Ã‰met un signal par son nom avec des arguments"""
	
	if not has_signal(event_name):
		push_warning("[EventBus] Signal introuvable : %s" % event_name)
		return
	
	if debug:
		print("[EventBus] Ã‰mission : %s avec args : %s" % [event_name, args])
	
	callv("emit_signal", [event_name] + args)

func safe_connect(signal_name: String, callable: Callable, flags: int = 0) -> void:
	"""Connexion sÃ©curisÃ©e avec vÃ©rification"""
	
	if not has_signal(signal_name):
		push_error("[EventBus] Impossible de connecter Ã  un signal inexistant : %s" % signal_name)
		return
	
	if is_connected(signal_name, callable):
		push_warning("[EventBus] DÃ©jÃ  connectÃ© : %s" % signal_name)
		return
	
	connect(signal_name, callable, flags)

func safe_disconnect(signal_name: String, callable: Callable) -> void:
	"""DÃ©connexion sÃ©curisÃ©e"""
	
	if not has_signal(signal_name):
		return
	
	if is_connected(signal_name, callable):
		disconnect(signal_name, callable)

func disconnect_all(object: Object) -> void:
	"""DÃ©connexion de tous les signaux d'un objet"""
	
	for signal_dict in get_signal_list():
		var sig_name = signal_dict["name"]
		var connections = get_signal_connection_list(sig_name)
		
		for connection in connections:
			if connection["callable"].get_object() == object:
				disconnect(sig_name, connection["callable"])

# ============================================================================
# HELPERS SPÃ‰CIFIQUES AU JEU
# ============================================================================

func notify(message: String, type: String = "info") -> void:
	"""Notification simple"""
	notification_posted.emit(message, type)

func change_scene(scene_id: int) -> void:
	"""Changement de scÃ¨ne via EventBus"""
	scene_change_requested.emit(scene_id)

func add_divine_points(god: String, points: int) -> void:
	"""Mise Ã  jour des statistiques divines"""
	divine_points_gained.emit(god, points)

func form_duo(unit_a: Node, unit_b: Node) -> void:
	"""Formation de duo"""
	duo_formed.emit(unit_a, unit_b)

func break_duo(unit_a: Node, unit_b: Node) -> void:
	"""Rupture de duo"""
	duo_broken.emit(unit_a, unit_b)

func attack(attacker: Node, target: Node, damage: int) -> void:
	"""Attaque d'unitÃ©"""
	unit_attacked.emit(attacker, target, damage)

func end_battle(results: Dictionary) -> void:
	"""Fin de combat"""
	battle_ended.emit(results)

func show_bark(speaker: String, text_key: String, position: Vector2) -> void:
	"""Affiche un bark de dialogue"""
	dialogue_bark_requested.emit(speaker, text_key, position)

func start_battle(battle_id: String) -> void:
	"""Ã‰met le signal de dÃ©but de combat"""
	print("[EventBus] ðŸŽ¬ DÃ©but du combat : %s" % battle_id)
	battle_started.emit(battle_id)

# ============================================================================
# DEBUG
# ============================================================================

func debug_list_connections() -> void:
	"""Liste toutes les connexions actives (debug)"""
	
	print("\n=== EventBus - Connexions actives ===")
	
	for signal_dict in get_signal_list():
		var sig_name = signal_dict["name"]
		var connections = get_signal_connection_list(sig_name)
		
		if connections.size() > 0:
			print("\n[%s] : %d connexions" % [sig_name, connections.size()])
			for connection in connections:
				var target = connection["callable"].get_object()
				var method = connection["callable"].get_method()
				print("  -> %s.%s" % [target.name if target else "null", method])
	
	print("\n=====================================\n")
```

## core/autoloads/game_manager.gd

```text
extends Node
## GameManager - Orchestration du cycle de vie du jeu
## GÃ¨re l'Ã©tat du jeu, les sauvegardes, la pause
##
## Le dÃ©marrage de nouvelle partie est dÃ©lÃ©guÃ© Ã  CampaignManager
## (qui gÃ¨re la sÃ©quence d'intro via DialogueManager + UIManager)
##
## AccÃ¨s via : GameRoot.game_manager

class_name GameManagerClass

# ============================================================================
# RÃ‰FÃ‰RENCES (assignÃ©es par GameRoot)
# ============================================================================

var scene_loader: SceneLoaderClass = null

# ============================================================================
# Ã‰TAT DU JEU
# ============================================================================

var game_state: Dictionary = {}
var is_paused: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	print("[GameManager] âœ… InitialisÃ©")

# ============================================================================
# GESTION DE LA PAUSE
# ============================================================================

func pause_game(paused: bool) -> void:
	is_paused = paused
	get_tree().paused = paused
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.game_paused.emit(paused)
	
	print("[GameManager] Jeu %s" % ("en pause" if paused else "repris"))

func toggle_pause() -> void:
	pause_game(not is_paused)

# ============================================================================
# SAUVEGARDE / CHARGEMENT
# ============================================================================

func save_game(save_name: String) -> void:
	game_state["timestamp"] = Time.get_unix_time_from_system()
	game_state["scene_id"] = scene_loader.current_scene_id if scene_loader else -1
	
	# Sauvegarder l'Ã©tat de la campagne
	if GameRoot and GameRoot.campaign_manager:
		game_state["campaign"] = GameRoot.campaign_manager.get_campaign_state()
	
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("saves"):
		dir.make_dir("saves")
	
	var save_path = "user://saves/%s.save" % save_name
	var file = FileAccess.open(save_path, FileAccess.WRITE)
	
	if file:
		file.store_string(JSON.stringify(game_state, "\t"))
		file.close()
		
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.game_saved.emit(save_name)
			GameRoot.event_bus.notify("Partie sauvegardÃ©e : %s" % save_name, "success")
		
		print("[GameManager] ðŸ’¾ Sauvegarde : %s" % save_name)
	else:
		push_error("[GameManager] Impossible de sauvegarder")

func load_game(save_name: String) -> void:
	var save_path = "user://saves/%s.save" % save_name
	
	if not FileAccess.file_exists(save_path):
		push_error("[GameManager] Sauvegarde introuvable : %s" % save_name)
		return
	
	var file = FileAccess.open(save_path, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		game_state = json.data
		
		var saved_scene_id = game_state.get("scene_id", -1)
		if saved_scene_id != -1 and scene_loader:
			scene_loader.load_scene_by_id(saved_scene_id)
		
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.game_loaded.emit(save_name)
			GameRoot.event_bus.notify("Partie chargÃ©e : %s" % save_name, "success")
		
		print("[GameManager] ðŸ“‚ Chargement : %s" % save_name)
	else:
		push_error("[GameManager] Erreur lors du chargement de la sauvegarde")

func has_save(save_name: String) -> bool:
	return FileAccess.file_exists("user://saves/%s.save" % save_name)

func get_save_list() -> Array[String]:
	var saves: Array[String] = []
	var save_dir = "user://saves/"
	
	if not DirAccess.dir_exists_absolute(save_dir):
		return saves
	
	var dir = DirAccess.open(save_dir)
	dir.list_dir_begin()
	
	var file_name = dir.get_next()
	while file_name != "":
		if file_name.ends_with(".save"):
			saves.append(file_name.get_basename())
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return saves

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_game_started() -> void:
	"""Callback quand une nouvelle partie dÃ©marre.
	La sÃ©quence d'intro est entiÃ¨rement gÃ©rÃ©e par CampaignManager
	(qui utilise DialogueManager + UIManager pour les dialogues et l'UI)."""
	
	print("[GameManager] ðŸŽ® Nouvelle partie dÃ©marrÃ©e")
	
	# CampaignManager reÃ§oit aussi game_started et gÃ¨re la sÃ©quence d'intro
	# Pas besoin de charger une scÃ¨ne intro ici - CampaignManager s'en occupe

func _on_game_paused(paused: bool) -> void:
	if paused != is_paused:
		is_paused = paused
		get_tree().paused = paused
	print("[GameManager] %s" % ("â¸ï¸ Pause" if paused else "â–¶ï¸ Reprise"))

func _on_quit_game_requested() -> void:
	print("[GameManager] ðŸšª Fermeture du jeu...")
	get_tree().quit()

func _on_return_to_menu_requested() -> void:
	print("[GameManager] ðŸ  Retour au menu principal")
	
	is_paused = false
	get_tree().paused = false
	
	if scene_loader:
		scene_loader.load_scene_by_id(SceneRegistry.SceneID.MAIN_MENU)

# ============================================================================
# GETTERS
# ============================================================================

func get_current_scene() -> Node:
	return scene_loader.current_scene if scene_loader else null

func get_current_scene_id() -> int:
	return scene_loader.current_scene_id if scene_loader else -1

func is_loading() -> bool:
	return scene_loader.is_loading if scene_loader else false

# ============================================================================
# DEBUG
# ============================================================================

func _input(event: InputEvent) -> void:
	if OS.is_debug_build():
		if event.is_action_pressed("ui_end"):
			print_status()

func print_status() -> void:
	print("\n=== GameManager Status ===")
	print("  ScÃ¨ne : %s" % (SceneRegistry.get_scene_name(get_current_scene_id()) if get_current_scene_id() != -1 else "N/A"))
	print("  Pause : %s" % is_paused)
	print("  Loading : %s" % is_loading())
	print("===========================\n")
```

## core/autoloads/game_root.gd

```text
extends Node
## GameRoot - Point d'entrÃ©e unique du jeu
## ScÃ¨ne autoload principale qui instancie et expose tous les systÃ¨mes globaux
##
## Configuration : Ajouter GameRoot.tscn comme autoload nommÃ© "GameRoot"
## AccÃ¨s : GameRoot.event_bus, GameRoot.scene_loader, etc.

class_name GameRootClass


# === AUTOLOADS ===
const EventBusClass        = preload("res://core/autoloads/event_bus.gd")
const SceneLoaderClass     = preload("res://core/autoloads/scene_loader.gd")
const UIManagerClass       = preload("res://core/autoloads/ui_manager.gd")
const DialogueManagerClass = preload("res://core/autoloads/dialogue_manager.gd")
const TeamManagerClass     = preload("res://core/autoloads/team_manager.gd")
const BattleDataManagerClass = preload("res://core/autoloads/battle_data_manager.gd")
const CampaignManagerClass = preload("res://core/autoloads/campaign_manager.gd")
const GlobalLoggerClass    = preload("res://core/autoloads/global_logger.gd")
const VersionManagerClass  = preload("res://core/autoloads/version_manager.gd")
const GameManagerClass     = preload("res://core/autoloads/game_manager.gd")
const DebugOverlayClass    = preload("res://core/autoloads/debug_overlay.gd")

# === DATA / HELPERS ===
const SceneRegistry        = preload("res://core/data/scene_registry.gd")
const JSONDataLoader       = preload("res://core/data/json_data_loader.gd")
const ModelValidator       = preload("res://core/data/model_validator.gd")
const ValidationResult     = preload("res://core/data/validation_result.gd")
const AbilityDataLoader    = preload("res://core/data/ability_data_loader.gd")

# === DIALOGUE SYSTEM ===
const DialogueData         = preload("res://core/dialogue/dialogue_data.gd")
const DialogueDataLoader   = preload("res://core/dialogue/dialogue_data_loader.gd")
const DialogueBoxClass     = preload("res://core/dialogue/dialogue_box.gd")
const BarkSystem           = preload("res://core/dialogue/bark_system.gd")

# === FEATURES ===
const DebugVersionPanel    = preload("res://features/debug/debug_version_panel.gd")
const MainMenuClass        = preload("res://features/menu/main_menu.gd")
const WorldMapClass        = preload("res://features/world_map/logic/world_map.gd")


# ============================================================================
# RÃ‰FÃ‰RENCES EXPOSÃ‰ES (accÃ¨s via GameRoot.xxx)
# ============================================================================

var event_bus: EventBusClass = null
var scene_loader: SceneLoaderClass = null
var game_manager: GameManagerClass = null
var ui_manager: UIManagerClass = null
var debug_overlay: DebugOverlayClass = null
var global_logger: GlobalLoggerClass = null
var battle_data_manager: BattleDataManagerClass = null
var dialogue_manager: DialogueManagerClass = null
var version_manager: VersionManagerClass = null
var campaign_manager: CampaignManagerClass = null
var team_manager = null  # TeamManager n'a pas de class_name typÃ©

# ============================================================================
# CONTENEUR DE SCÃˆNES
# ============================================================================

var scene_container: Node = null
var current_scene: Node = null

# ============================================================================
# CONFIGURATION DES SCRIPTS
# ============================================================================

const SCRIPTS = {
	"event_bus": "res://core/autoloads/event_bus.gd",
	"global_logger": "res://core/autoloads/global_logger.gd",
	"scene_loader": "res://core/autoloads/scene_loader.gd",
	"game_manager": "res://core/autoloads/game_manager.gd",
	"ui_manager": "res://core/autoloads/ui_manager.gd",
	"debug_overlay": "res://core/autoloads/debug_overlay.gd",
	"battle_data_manager": "res://core/autoloads/battle_data_manager.gd",
	"dialogue_manager": "res://core/autoloads/dialogue_manager.gd",
	"version_manager": "res://core/autoloads/version_manager.gd",
	"campaign_manager": "res://core/autoloads/campaign_manager.gd",
	"team_manager": "res://core/autoloads/team_manager.gd"
}




# ============================================================================
# Ã‰TAT
# ============================================================================

var _is_initialized: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	if _is_initialized:
		push_warning("[GameRoot] DÃ©jÃ  initialisÃ©, skip")
		return
	
	name = "GameRoot"
	
	print("========================================")
	print("  GAME ROOT - Initialisation")
	print("========================================")
	
	# Ordre d'initialisation important !
	_setup_scene_container()
	_initialize_core_systems()
	_initialize_managers()
	_initialize_ui_systems()
	_connect_systems()
	_check_migrations()
	
	_is_initialized = true
	
	print("========================================")
	print("  GAME ROOT - PrÃªt !")
	print("========================================")
	
	# Charger la scÃ¨ne initiale
	call_deferred("_load_initial_scene")

func _setup_scene_container() -> void:
	"""Configure le conteneur de scÃ¨nes (crÃ©Ã© dans la .tscn ou dynamiquement)"""
	scene_container = get_node_or_null("SceneContainer")
	
	if not scene_container:
		scene_container = Node.new()
		scene_container.name = "SceneContainer"
		add_child(scene_container)
		print("[GameRoot]   â†’ SceneContainer crÃ©Ã© dynamiquement")
	else:
		print("[GameRoot]   â†’ SceneContainer trouvÃ© dans la scÃ¨ne")

func _initialize_core_systems() -> void:
	"""Initialise les systÃ¨mes de base (EventBus, Logger)"""
	global_logger = _create_system("global_logger", "GlobalLogger") as GlobalLoggerClass
	event_bus = _create_system("event_bus", "EventBus") as EventBusClass
	print("[GameRoot] âœ… SystÃ¨mes de base initialisÃ©s")

func _initialize_managers() -> void:
	"""Initialise les managers principaux"""
	
	# SceneLoader
	scene_loader = _create_system("scene_loader", "SceneLoader") as SceneLoaderClass
	scene_loader.scene_container = scene_container
	
	# GameManager
	game_manager = _create_system("game_manager", "GameManager") as GameManagerClass
	game_manager.scene_loader = scene_loader
	
	# BattleDataManager
	battle_data_manager = _create_system("battle_data_manager", "BattleDataManager") as BattleDataManagerClass
	
	# DialogueManager
	dialogue_manager = _create_system("dialogue_manager", "DialogueManager") as DialogueManagerClass
	
	# VersionManager
	version_manager = _create_system("version_manager", "VersionManager") as VersionManagerClass
	
	# TeamManager
	team_manager = _create_system("team_manager", "TeamManager")
	
	# CampaignManager (aprÃ¨s les autres car il les utilise)
	campaign_manager = _create_system("campaign_manager", "CampaignManager") as CampaignManagerClass
	
	print("[GameRoot] âœ… Managers initialisÃ©s")

func _initialize_ui_systems() -> void:
	"""Initialise les systÃ¨mes UI (au-dessus des scÃ¨nes)"""
	ui_manager = _create_system("ui_manager", "UIManager") as UIManagerClass
	
	if OS.is_debug_build():
		debug_overlay = _create_system("debug_overlay", "DebugOverlay") as DebugOverlayClass
	
	# Connecter DialogueManager Ã  la DialogueBox persistante de UIManager
	if dialogue_manager and ui_manager:
		GameRoot.dialogue_manager.set_persistent_dialogue_box(ui_manager.get_dialogue_box())
	
	print("[GameRoot] âœ… SystÃ¨mes UI initialisÃ©s")

func _create_system(key: String, node_name: String) -> Node:
	"""CrÃ©e et ajoute un systÃ¨me depuis son script."""
	var script_path = SCRIPTS.get(key, "")
	
	if script_path == "":
		push_error("[GameRoot] ClÃ© de script introuvable : %s" % key)
		return null
	
	if not ResourceLoader.exists(script_path):
		push_error("[GameRoot] Script introuvable : %s" % script_path)
		return null
	
	var script = load(script_path)
	if not script:
		push_error("[GameRoot] Ã‰chec du chargement du script : %s" % script_path)
		return null
	
	var base_type: String = script.get_instance_base_type()
	var instance: Node
	
	match base_type:
		"CanvasLayer":
			instance = CanvasLayer.new()
		"Control":
			instance = Control.new()
		"Node2D":
			instance = Node2D.new()
		"Node3D":
			instance = Node3D.new()
		_:
			instance = Node.new()
	
	instance.set_script(script)
	instance.name = node_name
	add_child(instance)
	
	print("[GameRoot]   â†’ %s chargÃ© (%s)" % [node_name, base_type])
	return instance

func _connect_systems() -> void:
	"""Connecte les systÃ¨mes entre eux via l'EventBus"""
	if not event_bus:
		push_error("[GameRoot] EventBus non initialisÃ©")
		return
	
	# SceneLoader
	if scene_loader:
		event_bus.safe_connect("scene_change_requested", scene_loader._on_scene_change_requested)
	
	# GameManager
	if game_manager:
		event_bus.safe_connect("game_started", game_manager._on_game_started)
		event_bus.safe_connect("game_paused", game_manager._on_game_paused)
		event_bus.safe_connect("quit_game_requested", game_manager._on_quit_game_requested)
		event_bus.safe_connect("return_to_menu_requested", game_manager._on_return_to_menu_requested)
	
	# UIManager
	if ui_manager:
		event_bus.safe_connect("notification_posted", ui_manager._on_notification_posted)
	
	# CampaignManager
	if campaign_manager:
		event_bus.safe_connect("game_started", campaign_manager._on_game_started)
		event_bus.safe_connect("battle_ended", campaign_manager._on_battle_ended)
	
	print("[GameRoot] âœ… SystÃ¨mes connectÃ©s")

func _check_migrations() -> void:
	if version_manager:
		version_manager.check_and_migrate()

func _load_initial_scene() -> void:
	"""Charge la scÃ¨ne initiale (menu principal)"""
	if scene_loader:
		if SceneRegistry.scene_exists(SceneRegistry.SceneID.MAIN_MENU):
			scene_loader.load_scene_by_id(SceneRegistry.SceneID.MAIN_MENU, false)
		else:
			push_warning("[GameRoot] Menu principal non trouvÃ©")

# ============================================================================
# CALLBACKS SCÃˆNE
# ============================================================================

func _on_scene_loaded(scene: Node) -> void:
	current_scene = scene
	if global_logger:
		global_logger.info("SCENE", "ScÃ¨ne chargÃ©e : %s" % scene.name)

func _on_scene_unloaded() -> void:
	current_scene = null

# ============================================================================
# API PUBLIQUE
# ============================================================================

func change_scene(scene_id: int, transition: bool = true) -> void:
	if scene_loader:
		scene_loader.load_scene_by_id(scene_id, transition)

func change_scene_by_path(scene_path: String, transition: bool = true) -> void:
	if scene_loader:
		scene_loader.load_scene(scene_path, transition)

func notify(message: String, type: String = "info") -> void:
	if event_bus:
		event_bus.notify(message, type)

func log_info(category: String, message: String) -> void:
	if global_logger:
		global_logger.info(category, message)

func log_debug(category: String, message: String) -> void:
	if global_logger:
		global_logger.debug(category, message)

func log_warning(category: String, message: String) -> void:
	if global_logger:
		global_logger.warning(category, message)

func log_error(category: String, message: String) -> void:
	if global_logger:
		global_logger.error(category, message)

# ============================================================================
# GETTERS
# ============================================================================

func get_current_scene() -> Node:
	return current_scene

func get_current_scene_id() -> int:
	return scene_loader.current_scene_id if scene_loader else -1

func is_loading() -> bool:
	return scene_loader.is_loading if scene_loader else false

func is_initialized() -> bool:
	return _is_initialized

func get_event_bus() -> EventBusClass:
	return event_bus

func get_scene_loader() -> SceneLoaderClass:
	return scene_loader

func get_game_manager() -> GameManagerClass:
	return game_manager

func get_ui_manager() -> UIManagerClass:
	return ui_manager

func get_global_logger() -> GlobalLoggerClass:
	return global_logger

func get_battle_data_manager() -> BattleDataManagerClass:
	return battle_data_manager

func get_dialogue_manager() -> DialogueManagerClass:
	return dialogue_manager

func get_campaign_manager() -> CampaignManagerClass:
	return campaign_manager

# ============================================================================
# DEBUG
# ============================================================================

func _input(event: InputEvent) -> void:
	if OS.is_debug_build():
		if event.is_action_pressed("debug_toggle") and debug_overlay:
			debug_overlay.toggle_visibility()

func print_status() -> void:
	print("\n=== GameRoot Status ===")
	print("  Initialized: ", _is_initialized)
	print("  EventBus: ", "OK" if event_bus else "NULL")
	print("  GlobalLogger: ", "OK" if global_logger else "NULL")
	print("  SceneLoader: ", "OK" if scene_loader else "NULL")
	print("  GameManager: ", "OK" if game_manager else "NULL")
	print("  UIManager: ", "OK" if ui_manager else "NULL")
	print("  BattleDataManager: ", "OK" if battle_data_manager else "NULL")
	print("  DialogueManager: ", "OK" if dialogue_manager else "NULL")
	print("  CampaignManager: ", "OK" if campaign_manager else "NULL")
	print("  VersionManager: ", "OK" if version_manager else "NULL")
	print("  TeamManager: ", "OK" if team_manager else "NULL")
	print("  DebugOverlay: ", "OK" if debug_overlay else "N/A (release)")
	print("  SceneContainer: ", "OK" if scene_container else "NULL")
	print("  CurrentScene: ", current_scene.name if current_scene else "None")
	print("========================\n")
```

## core/autoloads/game_root.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://gameroot001"]

[ext_resource type="Script" path="res://core/autoloads/game_root.gd" id="1_gameroot"]

[node name="GameRoot" type="Node"]
script = ExtResource("1_gameroot")

[node name="SceneContainer" type="Node" parent="."]
```

## core/autoloads/global_logger.gd

```text
extends Node
## GlobalLogger - SystÃ¨me de logging centralisÃ©
## GÃ¨re les logs avec catÃ©gories, niveaux et formatage
##
## AccÃ¨s via : GameRoot.global_logger

class_name GlobalLoggerClass

# ============================================================================
# CONFIGURATION
# ============================================================================

enum LogLevel {
	DEBUG = 0,
	INFO = 1,
	WARNING = 2,
	ERROR = 3,
	NONE = 4
}

const LOG_COLORS = {
	LogLevel.DEBUG: "gray",
	LogLevel.INFO: "white",
	LogLevel.WARNING: "yellow",
	LogLevel.ERROR: "red"
}

const LOG_PREFIXES = {
	LogLevel.DEBUG: "ðŸ”",
	LogLevel.INFO: "â„¹ï¸",
	LogLevel.WARNING: "âš ï¸",
	LogLevel.ERROR: "âŒ"
}

# ============================================================================
# Ã‰TAT
# ============================================================================

var min_log_level: LogLevel = LogLevel.DEBUG
var enabled_categories: Dictionary = {}  # category -> bool
var log_to_file: bool = false
var log_file_path: String = "user://logs/game.log"
var log_file: FileAccess = null

# Historique des logs (pour debug overlay)
var log_history: Array[Dictionary] = []
var max_history: int = 100

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# En release, ne logger que les warnings et erreurs
	if not OS.is_debug_build():
		min_log_level = LogLevel.WARNING
	
	# Activer toutes les catÃ©gories par dÃ©faut
	_enable_default_categories()
	
	print("[GlobalLogger] âœ… InitialisÃ© (niveau: %s)" % LogLevel.keys()[min_log_level])

func _enable_default_categories() -> void:
	"""Active les catÃ©gories de log par dÃ©faut"""
	
	var categories = [
		"GAME", "BATTLE", "UI", "SCENE", "SAVE",
		"AUDIO", "NETWORK", "AI", "DIALOGUE", "EVENT",
		"BATTLE_DATA", "TEAM"
	]
	
	for cat in categories:
		enabled_categories[cat] = true

# ============================================================================
# API PUBLIQUE
# ============================================================================

func debug(category: String, message: String) -> void:
	"""Log de niveau DEBUG"""
	_log(LogLevel.DEBUG, category, message)

func info(category: String, message: String) -> void:
	"""Log de niveau INFO"""
	_log(LogLevel.INFO, category, message)

func warning(category: String, message: String) -> void:
	"""Log de niveau WARNING"""
	_log(LogLevel.WARNING, category, message)

func error(category: String, message: String) -> void:
	"""Log de niveau ERROR"""
	_log(LogLevel.ERROR, category, message)

# ============================================================================
# LOGGING INTERNE
# ============================================================================

func _log(level: LogLevel, category: String, message: String) -> void:
	"""Fonction de logging principale"""
	
	# VÃ©rifier le niveau minimum
	if level < min_log_level:
		return
	
	# VÃ©rifier si la catÃ©gorie est activÃ©e (sauf pour ERROR)
	if level != LogLevel.ERROR:
		if enabled_categories.has(category) and not enabled_categories[category]:
			return
	
	# Formater le message
	var timestamp = Time.get_time_string_from_system()
	var prefix = LOG_PREFIXES.get(level, "")
	var formatted = "[%s] %s [%s] %s" % [timestamp, prefix, category, message]
	
	# Afficher dans la console
	match level:
		LogLevel.DEBUG:
			print(formatted)
		LogLevel.INFO:
			print(formatted)
		LogLevel.WARNING:
			push_warning(formatted)
		LogLevel.ERROR:
			push_error(formatted)
	
	# Ajouter Ã  l'historique
	_add_to_history(level, category, message, timestamp)
	
	# Ã‰crire dans le fichier si activÃ©
	if log_to_file:
		_write_to_file(formatted)

func _add_to_history(level: LogLevel, category: String, message: String, timestamp: String) -> void:
	"""Ajoute un log Ã  l'historique"""
	
	log_history.append({
		"level": level,
		"category": category,
		"message": message,
		"timestamp": timestamp
	})
	
	# Limiter la taille
	while log_history.size() > max_history:
		log_history.pop_front()

func _write_to_file(message: String) -> void:
	"""Ã‰crit un message dans le fichier de log"""
	
	if not log_file:
		_open_log_file()
	
	if log_file:
		log_file.store_line(message)
		log_file.flush()

func _open_log_file() -> void:
	"""Ouvre le fichier de log"""
	
	# CrÃ©er le dossier si nÃ©cessaire
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("logs"):
		dir.make_dir("logs")
	
	log_file = FileAccess.open(log_file_path, FileAccess.WRITE)
	
	if log_file:
		log_file.store_line("=== Game Log - %s ===" % Time.get_datetime_string_from_system())
		log_file.store_line("")

# ============================================================================
# CONFIGURATION
# ============================================================================

func set_log_level(level: LogLevel) -> void:
	"""DÃ©finit le niveau minimum de log"""
	min_log_level = level
	info("GAME", "Niveau de log changÃ© : %s" % LogLevel.keys()[level])

func enable_category(category: String, enabled: bool = true) -> void:
	"""Active ou dÃ©sactive une catÃ©gorie"""
	enabled_categories[category] = enabled

func enable_file_logging(enabled: bool = true, path: String = "") -> void:
	"""Active ou dÃ©sactive le logging dans un fichier"""
	
	log_to_file = enabled
	
	if path != "":
		log_file_path = path
	
	if enabled:
		_open_log_file()
		info("GAME", "Logging fichier activÃ© : %s" % log_file_path)
	elif log_file:
		log_file.close()
		log_file = null

# ============================================================================
# UTILITAIRES
# ============================================================================

func get_recent_logs(count: int = 20, level_filter: LogLevel = LogLevel.DEBUG) -> Array[Dictionary]:
	"""Retourne les logs rÃ©cents filtrÃ©s par niveau"""
	
	var filtered: Array[Dictionary] = []
	
	for i in range(log_history.size() - 1, -1, -1):
		var entry = log_history[i]
		if entry.level >= level_filter:
			filtered.append(entry)
			if filtered.size() >= count:
				break
	
	filtered.reverse()
	return filtered

func get_logs_by_category(category: String, count: int = 20) -> Array[Dictionary]:
	"""Retourne les logs d'une catÃ©gorie spÃ©cifique"""
	
	var filtered: Array[Dictionary] = []
	
	for i in range(log_history.size() - 1, -1, -1):
		var entry = log_history[i]
		if entry.category == category:
			filtered.append(entry)
			if filtered.size() >= count:
				break
	
	filtered.reverse()
	return filtered

func clear_history() -> void:
	"""Vide l'historique des logs"""
	log_history.clear()

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if log_file:
		log_file.store_line("")
		log_file.store_line("=== Session terminÃ©e ===")
		log_file.close()
```

## core/autoloads/scene_loader.gd

```text
extends Node
## SceneLoader - Chargement et transition de scÃ¨nes
## Charge les scÃ¨nes dans le SceneContainer de GameRoot
##
## AccÃ¨s via : GameRoot.scene_loader

class_name SceneLoaderClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal scene_loading_started(scene_path: String)
signal scene_loading_progress(progress: float)
signal scene_loaded(scene: Node)
signal scene_transition_finished()

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var fade_duration: float = 0.3
@export var debug_mode: bool = true

# ============================================================================
# RÃ‰FÃ‰RENCES
# ============================================================================

var scene_container: Node = null  # AssignÃ© par GameRoot
var transition_overlay: ColorRect = null

# ============================================================================
# Ã‰TAT
# ============================================================================

var current_scene: Node = null
var current_scene_id: int = -1
var is_loading: bool = false
var loading_progress: float = 0.0

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	call_deferred("_setup_transition_overlay")
	print("[SceneLoader] âœ… InitialisÃ©")

func _setup_transition_overlay() -> void:
	"""CrÃ©e l'overlay de transition dans l'UIManager"""
	
	# Attendre que l'UIManager soit prÃªt
	await get_tree().process_frame
	
	if GameRoot and GameRoot.ui_manager:
		transition_overlay = GameRoot.ui_manager.create_transition_overlay()
	else:
		# Fallback : crÃ©er localement
		_create_local_overlay()
	
	if debug_mode:
		print("[SceneLoader] âœ… Overlay de transition configurÃ©")

func _create_local_overlay() -> void:
	"""CrÃ©e un overlay local (fallback)"""
	
	var canvas = CanvasLayer.new()
	canvas.layer = 100
	add_child(canvas)
	
	transition_overlay = ColorRect.new()
	transition_overlay.color = Color.BLACK
	transition_overlay.set_anchors_preset(Control.PRESET_FULL_RECT)
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	transition_overlay.modulate.a = 0.0
	canvas.add_child(transition_overlay)

# ============================================================================
# CHARGEMENT DE SCÃˆNE
# ============================================================================

func load_scene_by_id(scene_id: int, transition: bool = true) -> void:
	"""Charge une scÃ¨ne via son ID du registre"""
	
	if not SceneRegistry.scene_exists(scene_id):
		push_error("[SceneLoader] ScÃ¨ne introuvable : %d" % scene_id)
		return
	
	var scene_path = SceneRegistry.get_scene_path(scene_id)
	current_scene_id = scene_id
	
	if debug_mode:
		print("[SceneLoader] ðŸŽ¬ Chargement : %s" % SceneRegistry.get_scene_name(scene_id))
	
	await load_scene(scene_path, transition)

func load_scene(scene_path: String, transition: bool = true) -> void:
	"""Charge une scÃ¨ne par son chemin"""
	
	if is_loading:
		push_warning("[SceneLoader] Chargement dÃ©jÃ  en cours")
		return
	
	if not ResourceLoader.exists(scene_path):
		push_error("[SceneLoader] ScÃ¨ne introuvable : %s" % scene_path)
		return
	
	is_loading = true
	scene_loading_started.emit(scene_path)
	
	if debug_mode:
		print("[SceneLoader] ðŸŽ¬ DÃ©but du chargement : %s" % scene_path)
	
	# Transition sortante
	if transition:
		await _fade_out()
	
	# Nettoyer la scÃ¨ne actuelle
	_cleanup_current_scene()
	
	# Charger la nouvelle scÃ¨ne
	var new_scene = await _load_scene_async(scene_path)
	
	if new_scene == null:
		push_error("[SceneLoader] Ã‰chec du chargement : %s" % scene_path)
		is_loading = false
		if transition:
			await _fade_in()
		return
	
	# Ajouter la scÃ¨ne au container
	if scene_container:
		scene_container.add_child(new_scene)
	else:
		push_error("[SceneLoader] SceneContainer non dÃ©fini !")
		get_tree().root.add_child(new_scene)
	
	current_scene = new_scene
	
	# Mettre Ã  jour la rÃ©fÃ©rence dans GameRoot
	if GameRoot:
		GameRoot.current_scene = new_scene
		GameRoot._on_scene_loaded(new_scene)
	
	scene_loaded.emit(new_scene)
	
	# Transition entrante
	if transition:
		await _fade_in()
	
	is_loading = false
	scene_transition_finished.emit()
	
	if debug_mode:
		print("[SceneLoader] âœ… ScÃ¨ne chargÃ©e : %s" % scene_path)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _cleanup_current_scene() -> void:
	"""Supprime la scÃ¨ne actuelle"""
	
	if not scene_container:
		return
	
	for child in scene_container.get_children():
		if debug_mode:
			print("[SceneLoader] ðŸ—‘ï¸ Suppression : %s" % child.name)
		child.queue_free()
	
	current_scene = null
	
	# Notifier GameRoot
	if GameRoot:
		GameRoot._on_scene_unloaded()
	
	# Attendre le nettoyage
	await get_tree().process_frame

# ============================================================================
# CHARGEMENT ASYNCHRONE
# ============================================================================

func _load_scene_async(scene_path: String) -> Node:
	"""Chargement asynchrone avec progression"""
	
	var status = ResourceLoader.load_threaded_request(scene_path)
	
	if status != OK:
		push_error("[SceneLoader] Erreur lors de la requÃªte de chargement")
		return null
	
	while true:
		var progress_array = []
		status = ResourceLoader.load_threaded_get_status(scene_path, progress_array)
		
		if status == ResourceLoader.THREAD_LOAD_LOADED:
			var packed_scene = ResourceLoader.load_threaded_get(scene_path)
			return packed_scene.instantiate()
		
		elif status == ResourceLoader.THREAD_LOAD_FAILED:
			push_error("[SceneLoader] Ã‰chec du chargement threaded")
			return null
		
		elif status == ResourceLoader.THREAD_LOAD_INVALID_RESOURCE:
			push_error("[SceneLoader] Ressource invalide")
			return null
		
		# Mettre Ã  jour la progression
		if progress_array.size() > 0:
			loading_progress = progress_array[0]
			scene_loading_progress.emit(loading_progress)
			
			# Notifier l'UIManager
			if GameRoot and GameRoot.ui_manager:
				GameRoot.ui_manager.update_loading_progress(loading_progress)
		
		await get_tree().process_frame
	
	return null

# ============================================================================
# TRANSITIONS VISUELLES
# ============================================================================

func _fade_out() -> void:
	"""Fondu vers le noir"""
	
	if not transition_overlay:
		return
	
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_STOP
	
	var tween = create_tween()
	tween.tween_property(transition_overlay, "modulate:a", 1.0, fade_duration)
	await tween.finished

func _fade_in() -> void:
	"""Fondu depuis le noir"""
	
	if not transition_overlay:
		return
	
	var tween = create_tween()
	tween.tween_property(transition_overlay, "modulate:a", 0.0, fade_duration)
	await tween.finished
	
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_scene_change_requested(scene_id: int) -> void:
	"""RÃ©action Ã  une demande de changement de scÃ¨ne"""
	load_scene_by_id(scene_id)

# ============================================================================
# UTILITAIRES
# ============================================================================

func reload_current_scene(transition: bool = true) -> void:
	"""Recharge la scÃ¨ne actuelle"""
	
	if current_scene_id != -1:
		load_scene_by_id(current_scene_id, transition)
	elif current_scene:
		var scene_path = current_scene.scene_file_path
		load_scene(scene_path, transition)

func get_current_scene_name() -> String:
	"""Retourne le nom de la scÃ¨ne actuelle"""
	
	if current_scene_id != -1:
		return SceneRegistry.get_scene_name(current_scene_id)
	elif current_scene:
		return current_scene.name
	return "Aucune"
```

## core/autoloads/team_manager.gd

```text
extends Node
## TeamManager - Gestion de l'Ã©quipe du joueur
## Autoload pour gÃ©rer le roster, le recrutement, l'XP
##
## AccÃ¨s via : GameRoot.team_manager

signal team_changed()
signal unit_recruited(unit_id: String)
signal unit_dismissed(unit_id: String)
signal unit_leveled_up(unit_id: String, new_level: int)

# ============================================================================
# CONFIGURATION
# ============================================================================

const MAX_TEAM_SIZE: int = 8
const TEAM_SAVE_PATH: String = "user://team_data.json"
const AVAILABLE_UNITS_PATH: String = "res://data/team/available_units.json"

# ============================================================================
# DONNÃ‰ES
# ============================================================================

var current_team: Array[Dictionary] = []  # Ã‰quipe active (max 4 en combat)
var roster: Array[Dictionary] = []  # Toutes les unitÃ©s recrutÃ©es
var available_units: Dictionary = {}  # UnitÃ©s recrutables

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_load_available_units()
	_load_team_from_save()
	print("[TeamManager] âœ… InitialisÃ© - Ã‰quipe : ", current_team.size(), " / Roster : ", roster.size())

func _load_available_units() -> void:
	if not FileAccess.file_exists(AVAILABLE_UNITS_PATH):
		push_warning("[TeamManager] Fichier d'unitÃ©s disponibles non trouvÃ©")
		return
	
	var file = FileAccess.open(AVAILABLE_UNITS_PATH, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		available_units = json.data
	else:
		push_warning("[TeamManager] Erreur de parsing des unitÃ©s disponibles")

# ============================================================================
# GESTION DE L'Ã‰QUIPE
# ============================================================================

func add_to_team(unit_data: Dictionary) -> bool:
	"""Ajoute une unitÃ© Ã  l'Ã©quipe active"""
	
	if current_team.size() >= 4:
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.notify("Ã‰quipe complÃ¨te (max 4 en combat)", "warning")
		return false
	
	current_team.append(unit_data)
	team_changed.emit()
	_save_team()
	
	print("[TeamManager] âœ… AjoutÃ© : ", unit_data.get("name"))
	return true

func remove_from_team(unit_id: String) -> bool:
	"""Retire une unitÃ© de l'Ã©quipe active"""
	
	for i in range(current_team.size()):
		if current_team[i].get("id") == unit_id:
			current_team.remove_at(i)
			team_changed.emit()
			_save_team()
			return true
	
	return false

func recruit_unit(unit_id: String) -> bool:
	"""Recrute une unitÃ© (l'ajoute au roster)"""
	
	if roster.size() >= MAX_TEAM_SIZE:
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.notify("Roster complet (max " + str(MAX_TEAM_SIZE) + ")", "warning")
		return false
	
	# VÃ©rifier si dÃ©jÃ  recrutÃ©e
	for unit in roster:
		if unit.get("id") == unit_id:
			if GameRoot and GameRoot.event_bus:
				GameRoot.event_bus.notify("UnitÃ© dÃ©jÃ  recrutÃ©e", "warning")
			return false
	
	# CrÃ©er l'instance depuis les donnÃ©es disponibles
	if not available_units.has(unit_id):
		push_error("[TeamManager] UnitÃ© introuvable : ", unit_id)
		return false
	
	var unit_template = available_units[unit_id]
	var new_unit = _create_unit_instance(unit_template)
	
	roster.append(new_unit)
	unit_recruited.emit(unit_id)
	_save_team()
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("RecrutÃ© : " + new_unit.get("name"), "success")
	return true

func _create_unit_instance(template: Dictionary) -> Dictionary:
	"""CrÃ©e une instance d'unitÃ© depuis un template"""
	
	var instance = template.duplicate(true)
	instance["instance_id"] = str(Time.get_ticks_msec())  # ID unique
	instance["level"] = 1
	instance["xp"] = 0
	instance["current_hp"] = instance.get("stats", {}).get("hp", 100)
	
	return instance

# ============================================================================
# GETTERS
# ============================================================================

func get_current_team() -> Array[Dictionary]:
	return current_team.duplicate()

func get_roster() -> Array[Dictionary]:
	return roster.duplicate()

func get_unit_by_id(unit_id: String) -> Dictionary:
	for unit in roster:
		if unit.get("id") == unit_id:
			return unit
	return {}

func is_team_full() -> bool:
	return current_team.size() >= 4

# ============================================================================
# XP & LEVEL UP
# ============================================================================

func add_xp(unit_id: String, xp_amount: int) -> void:
	"""Ajoute de l'XP Ã  une unitÃ©"""
	
	var unit = get_unit_by_id(unit_id)
	
	if unit.is_empty():
		return
	
	unit.xp += xp_amount
	
	# Check level up
	var xp_needed = _calculate_xp_for_level(unit.level + 1)
	
	if unit.xp >= xp_needed:
		_level_up(unit)

func _level_up(unit: Dictionary) -> void:
	"""Level up d'une unitÃ©"""
	
	unit.level += 1
	unit.xp = 0  # Reset XP
	
	# Augmenter les stats (exemple simple)
	var stats = unit.get("stats", {})
	stats.hp = int(stats.get("hp", 100) * 1.1)
	stats.attack = int(stats.get("attack", 20) * 1.1)
	stats.defense = int(stats.get("defense", 10) * 1.1)
	
	unit_leveled_up.emit(unit.get("id"), unit.level)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify(unit.get("name") + " atteint le niveau " + str(unit.level) + " !", "success")
	
	_save_team()

func _calculate_xp_for_level(level: int) -> int:
	"""Calcul XP nÃ©cessaire pour un niveau"""
	return 100 * level  # Formule simple

# ============================================================================
# SAUVEGARDE / CHARGEMENT
# ============================================================================

func _save_team() -> void:
	"""Sauvegarde l'Ã©quipe"""
	
	var save_data = {
		"current_team": current_team,
		"roster": roster,
		"timestamp": Time.get_unix_time_from_system()
	}
	
	var file = FileAccess.open(TEAM_SAVE_PATH, FileAccess.WRITE)
	
	if not file:
		push_error("[TeamManager] Impossible de sauvegarder")
		return
	
	file.store_string(JSON.stringify(save_data, "\t"))
	file.close()
	
	print("[TeamManager] ðŸ’¾ Ã‰quipe sauvegardÃ©e")

func _load_team_from_save() -> void:
	"""Charge l'Ã©quipe depuis la sauvegarde"""
	
	if not FileAccess.file_exists(TEAM_SAVE_PATH):
		# CrÃ©er une Ã©quipe par dÃ©faut
		_create_default_team()
		return
	
	var file = FileAccess.open(TEAM_SAVE_PATH, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) != OK:
		push_error("[TeamManager] Erreur de parsing de la sauvegarde")
		_create_default_team()
		return
	
	var data = json.data
	current_team.clear()
	for unit in data.get("current_team", []):
		current_team.append(unit as Dictionary)
	
	roster.clear()
	for unit in data.get("roster", []):
		roster.append(unit as Dictionary)
	
	print("[TeamManager] ðŸ“‚ Ã‰quipe chargÃ©e depuis sauvegarde")

func _create_default_team() -> void:
	"""CrÃ©e une Ã©quipe de dÃ©part"""
	
	print("[TeamManager] ðŸ†• CrÃ©ation Ã©quipe par dÃ©faut")
	
	# Recruter 2 unitÃ©s de base si disponibles
	if available_units.has("starter_knight"):
		recruit_unit("starter_knight")
		if roster.size() > 0:
			add_to_team(roster[0])
	
	if available_units.has("starter_mage"):
		recruit_unit("starter_mage")
		if roster.size() > 1:
			add_to_team(roster[1])
```

## core/autoloads/ui_manager.gd

```text
extends CanvasLayer
## UIManager - Gestion de l'interface utilisateur globale
## GÃ¨re les notifications, l'Ã©cran de chargement, les menus globaux
## et la DialogueBox persistante (toujours en mÃ©moire)
##
## AccÃ¨s via : GameRoot.ui_manager

class_name UIManagerClass

# ============================================================================
# CONFIGURATION
# ============================================================================

const NOTIFICATION_DURATION: float = 3.0
const NOTIFICATION_FADE: float = 0.3
const MAX_NOTIFICATIONS: int = 5

# ============================================================================
# RÃ‰FÃ‰RENCES UI
# ============================================================================

var notification_container: VBoxContainer = null
var loading_screen: Control = null
var loading_progress_bar: ProgressBar = null
var loading_label: Label = null
var pause_menu: Control = null
var transition_overlay: ColorRect = null
var dialogue_box: DialogueBoxClass = null  # â† NOUVEAU : DialogueBox persistante

# ============================================================================
# Ã‰TAT
# ============================================================================

var active_notifications: Array[Control] = []
var is_loading_visible: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	layer = 90
	name = "UIManager"
	
	_create_transition_layer()
	_create_notification_system()
	_create_loading_screen()
	_create_pause_menu()
	_create_dialogue_box()  # â† NOUVEAU
	
	print("[UIManager] âœ… InitialisÃ© (avec DialogueBox persistante)")

# ============================================================================
# DIALOGUE BOX PERSISTANTE
# ============================================================================

func _create_dialogue_box() -> void:
	"""CrÃ©e la DialogueBox persistante accessible par DialogueManager"""
	
	# Charger depuis .tscn si disponible
	var dialogue_box_scene_path = "res://shared/ui/dialogue_box.tscn"
	
	if ResourceLoader.exists(dialogue_box_scene_path):
		var packed = load(dialogue_box_scene_path)
		dialogue_box = packed.instantiate() as DialogueBoxClass
		print("[UIManager]   â†’ DialogueBox chargÃ©e depuis .tscn")
	else:
		# Fallback : crÃ©er programmatiquement
		dialogue_box = DialogueBoxClass.new()
		print("[UIManager]   â†’ DialogueBox crÃ©Ã©e dynamiquement")
	
	dialogue_box.name = "PersistentDialogueBox"
	dialogue_box.visible = false
	dialogue_box.z_index = 60  # Au-dessus des scÃ¨nes, sous le pause menu
	add_child(dialogue_box)

func get_dialogue_box() -> DialogueBoxClass:
	"""Retourne la DialogueBox persistante"""
	return dialogue_box

func show_dialogue_box() -> void:
	"""Affiche la DialogueBox"""
	if dialogue_box:
		dialogue_box.show_dialogue_box()

func hide_dialogue_box() -> void:
	"""Cache la DialogueBox"""
	if dialogue_box:
		dialogue_box.hide_dialogue_box()

# ============================================================================
# TRANSITION LAYER
# ============================================================================

func _create_transition_layer() -> void:
	transition_overlay = ColorRect.new()
	transition_overlay.name = "TransitionOverlay"
	transition_overlay.color = Color.BLACK
	transition_overlay.set_anchors_preset(Control.PRESET_FULL_RECT)
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	transition_overlay.modulate.a = 0.0
	transition_overlay.z_index = 100
	add_child(transition_overlay)

# ============================================================================
# NOTIFICATIONS
# ============================================================================

func _create_notification_system() -> void:
	notification_container = VBoxContainer.new()
	notification_container.name = "NotificationContainer"
	notification_container.set_anchors_preset(Control.PRESET_TOP_RIGHT)
	notification_container.anchor_left = 1.0
	notification_container.anchor_right = 1.0
	notification_container.offset_left = -320
	notification_container.offset_top = 20
	notification_container.offset_right = -20
	notification_container.add_theme_constant_override("separation", 10)
	add_child(notification_container)

func _create_loading_screen() -> void:
	loading_screen = Control.new()
	loading_screen.name = "LoadingScreen"
	loading_screen.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.visible = false
	loading_screen.z_index = 50
	add_child(loading_screen)
	
	var bg = ColorRect.new()
	bg.color = Color(0.05, 0.05, 0.08, 0.95)
	bg.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.add_child(bg)
	
	var center = CenterContainer.new()
	center.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.add_child(center)
	
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 20)
	center.add_child(vbox)
	
	loading_label = Label.new()
	loading_label.text = "Chargement..."
	loading_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	loading_label.add_theme_font_size_override("font_size", 32)
	vbox.add_child(loading_label)
	
	loading_progress_bar = ProgressBar.new()
	loading_progress_bar.custom_minimum_size = Vector2(400, 30)
	loading_progress_bar.value = 0
	vbox.add_child(loading_progress_bar)

func _create_pause_menu() -> void:
	pause_menu = Control.new()
	pause_menu.name = "PauseMenu"
	pause_menu.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.visible = false
	pause_menu.z_index = 80
	add_child(pause_menu)
	
	var bg = ColorRect.new()
	bg.color = Color(0, 0, 0, 0.7)
	bg.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.add_child(bg)
	
	var center = CenterContainer.new()
	center.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.add_child(center)
	
	var panel = PanelContainer.new()
	center.add_child(panel)
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 40)
	margin.add_theme_constant_override("margin_top", 40)
	margin.add_theme_constant_override("margin_right", 40)
	margin.add_theme_constant_override("margin_bottom", 40)
	panel.add_child(margin)
	
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 15)
	margin.add_child(vbox)
	
	var title = Label.new()
	title.text = "PAUSE"
	title.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title.add_theme_font_size_override("font_size", 48)
	vbox.add_child(title)
	
	var resume_btn = Button.new()
	resume_btn.text = "Reprendre"
	resume_btn.custom_minimum_size = Vector2(200, 50)
	resume_btn.pressed.connect(_on_resume_pressed)
	vbox.add_child(resume_btn)
	
	var options_btn = Button.new()
	options_btn.text = "Options"
	options_btn.custom_minimum_size = Vector2(200, 50)
	options_btn.pressed.connect(_on_options_pressed)
	vbox.add_child(options_btn)
	
	var menu_btn = Button.new()
	menu_btn.text = "Menu Principal"
	menu_btn.custom_minimum_size = Vector2(200, 50)
	menu_btn.pressed.connect(_on_main_menu_pressed)
	vbox.add_child(menu_btn)
	
	var quit_btn = Button.new()
	quit_btn.text = "Quitter"
	quit_btn.custom_minimum_size = Vector2(200, 50)
	quit_btn.pressed.connect(_on_quit_pressed)
	vbox.add_child(quit_btn)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func create_transition_overlay() -> ColorRect:
	return transition_overlay

func show_notification(message: String, type: String = "info", duration: float = NOTIFICATION_DURATION) -> void:
	while active_notifications.size() >= MAX_NOTIFICATIONS:
		var oldest = active_notifications.pop_front()
		if oldest and is_instance_valid(oldest):
			oldest.queue_free()
	
	var notif = _create_notification_panel(message, type)
	notification_container.add_child(notif)
	active_notifications.append(notif)
	
	notif.modulate.a = 0.0
	notif.position.x = 50
	
	var tween = create_tween()
	tween.set_parallel(true)
	tween.tween_property(notif, "modulate:a", 1.0, NOTIFICATION_FADE)
	tween.tween_property(notif, "position:x", 0.0, NOTIFICATION_FADE)
	
	await get_tree().create_timer(duration).timeout
	
	if is_instance_valid(notif):
		var fade_tween = create_tween()
		fade_tween.tween_property(notif, "modulate:a", 0.0, NOTIFICATION_FADE)
		fade_tween.tween_callback(func():
			if is_instance_valid(notif):
				active_notifications.erase(notif)
				notif.queue_free()
		)

func _create_notification_panel(message: String, type: String) -> PanelContainer:
	var panel = PanelContainer.new()
	panel.custom_minimum_size = Vector2(300, 0)
	
	var style = StyleBoxFlat.new()
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	style.border_width_left = 4
	
	match type:
		"success":
			style.bg_color = Color(0.1, 0.3, 0.1, 0.95)
			style.border_color = Color(0.3, 0.8, 0.3)
		"warning":
			style.bg_color = Color(0.3, 0.25, 0.1, 0.95)
			style.border_color = Color(0.9, 0.7, 0.2)
		"error":
			style.bg_color = Color(0.3, 0.1, 0.1, 0.95)
			style.border_color = Color(0.9, 0.3, 0.3)
		_:
			style.bg_color = Color(0.1, 0.15, 0.25, 0.95)
			style.border_color = Color(0.4, 0.6, 0.9)
	
	panel.add_theme_stylebox_override("panel", style)
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 15)
	margin.add_theme_constant_override("margin_top", 10)
	margin.add_theme_constant_override("margin_right", 15)
	margin.add_theme_constant_override("margin_bottom", 10)
	panel.add_child(margin)
	
	var label = Label.new()
	label.text = message
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	margin.add_child(label)
	
	return panel

func show_loading(text: String = "Chargement...") -> void:
	loading_label.text = text
	loading_progress_bar.value = 0
	loading_screen.visible = true
	is_loading_visible = true

func hide_loading() -> void:
	loading_screen.visible = false
	is_loading_visible = false

func update_loading_progress(progress: float) -> void:
	loading_progress_bar.value = progress * 100

func show_pause_menu() -> void:
	pause_menu.visible = true

func hide_pause_menu() -> void:
	pause_menu.visible = false

func toggle_pause_menu() -> void:
	if pause_menu.visible:
		hide_pause_menu()
	else:
		show_pause_menu()

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_notification_posted(message: String, type: String) -> void:
	show_notification(message, type)

# ============================================================================
# CALLBACKS MENU PAUSE
# ============================================================================

func _on_resume_pressed() -> void:
	hide_pause_menu()
	if GameRoot and GameRoot.game_manager:
		GameRoot.game_manager.pause_game(false)

func _on_options_pressed() -> void:
	show_notification("Options (Ã  implÃ©menter)", "info")

func _on_main_menu_pressed() -> void:
	hide_pause_menu()
	if GameRoot:
		if GameRoot.game_manager:
			GameRoot.game_manager.pause_game(false)
		if GameRoot.event_bus:
			GameRoot.event_bus.return_to_menu_requested.emit()

func _on_quit_pressed() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.quit_game_requested.emit()

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_cancel"):
		if GameRoot and GameRoot.game_manager:
			var current_id = GameRoot.game_manager.get_current_scene_id()
			if current_id != SceneRegistry.SceneID.MAIN_MENU:
				GameRoot.game_manager.toggle_pause()
				toggle_pause_menu()
```

## core/autoloads/version_manager.gd

```text
extends Node
class_name VersionManagerClass
## Gestion des versions de donnÃ©es et migrations
##
## AccÃ¨s via : GameRoot.version_manager

const CURRENT_VERSION = "1.0.0"
const VERSION_FILE = "user://version.json"

signal migration_started(from_version: String, to_version: String)
signal migration_completed(from_version: String, to_version: String)
signal migration_failed(from_version: String, to_version: String, error: String)

var migrations: Dictionary = {}  # "0.9.0" -> Callable

func _ready() -> void:
	_register_migrations()
	print("[VersionManager] âœ… InitialisÃ© (version: %s)" % CURRENT_VERSION)

func _register_migrations() -> void:
	# Exemple de migration 0.9.0 -> 1.0.0
	register_migration("0.9.0", _migrate_0_9_to_1_0)

func register_migration(from_version: String, migration_func: Callable) -> void:
	migrations[from_version] = migration_func

func check_and_migrate() -> bool:
	var installed_version = _get_installed_version()
	
	if installed_version == CURRENT_VERSION:
		print("[VersionManager] âœ… Version Ã  jour : ", CURRENT_VERSION)
		return true
	
	print("[VersionManager] ðŸ”„ Migration nÃ©cessaire : ", installed_version, " -> ", CURRENT_VERSION)
	
	return migrate_from(installed_version)

func migrate_from(from_version: String) -> bool:
	if not migrations.has(from_version):
		# Pas de migration nÃ©cessaire, mettre Ã  jour la version
		_set_installed_version(CURRENT_VERSION)
		return true
	
	migration_started.emit(from_version, CURRENT_VERSION)
	
	var migration_func = migrations[from_version]
	var success = migration_func.call()
	
	if success:
		_set_installed_version(CURRENT_VERSION)
		migration_completed.emit(from_version, CURRENT_VERSION)
		print("[VersionManager] âœ… Migration rÃ©ussie")
		return true
	else:
		migration_failed.emit(from_version, CURRENT_VERSION, "Ã‰chec de la migration")
		return false

func _get_installed_version() -> String:
	if not FileAccess.file_exists(VERSION_FILE):
		return "0.0.0"
	
	var file = FileAccess.open(VERSION_FILE, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		return json.data.get("version", "0.0.0")
	
	return "0.0.0"

func _set_installed_version(version: String) -> void:
	var data = {"version": version, "timestamp": Time.get_unix_time_from_system()}
	
	var file = FileAccess.open(VERSION_FILE, FileAccess.WRITE)
	file.store_string(JSON.stringify(data, "\t"))
	file.close()

func get_current_version() -> String:
	return CURRENT_VERSION

func get_installed_version() -> String:
	return _get_installed_version()

# ============================================================================
# MIGRATIONS SPÃ‰CIFIQUES
# ============================================================================

func _migrate_0_9_to_1_0() -> bool:
	print("[VersionManager] Migration 0.9.0 -> 1.0.0")
	
	var save_dir = "user://saves/"
	
	if not DirAccess.dir_exists_absolute(save_dir):
		return true  # Pas de sauvegardes
	
	var dir = DirAccess.open(save_dir)
	dir.list_dir_begin()
	
	var file_name = dir.get_next()
	while file_name != "":
		if file_name.ends_with(".save"):
			var full_path = save_dir + file_name
			_migrate_save_file(full_path)
		
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return true

func _migrate_save_file(path: String) -> void:
	var file = FileAccess.open(path, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) != OK:
		return
	
	var data = json.data
	data["version"] = "1.0.0"
	
	file = FileAccess.open(path, FileAccess.WRITE)
	file.store_string(JSON.stringify(data, "\t"))
	file.close()
```

## core/data/ability_data_loader.gd

```text
class_name AbilityDataLoader
extends Node
## Charge les donnÃ©es d'abilities depuis JSON
## Format: data/abilities/*.json

const ABILITIES_DIR = "res://data/abilities/"

var _json_loader: JSONDataLoader
var abilities: Dictionary = {}

func _init():
	_json_loader = JSONDataLoader.new()

func _ready() -> void:
	load_all_abilities()

func load_all_abilities() -> void:
	abilities = _json_loader.load_json_directory(ABILITIES_DIR, false)
	
	if abilities.is_empty():
		push_warning("No abilities loaded from " + ABILITIES_DIR)
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.data_load_warning.emit("abilities", "No data found")
	else:
		print("[AbilityDataLoader] Loaded %d abilities" % abilities.size())
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.data_loaded.emit("abilities", abilities)

func get_ability(ability_id: String) -> Dictionary:
	if abilities.has(ability_id):
		return abilities[ability_id]
	
	push_error("Ability not found: " + ability_id)
	return {}

func reload_ability(ability_id: String) -> void:
	var file_path = ABILITIES_DIR.path_join(ability_id + ".json")
	_json_loader.clear_cache(file_path)
	var data = _json_loader.load_json_file(file_path)
	
	if data:
		abilities[ability_id] = data
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.ability_reloaded.emit(ability_id)

## Valide les champs requis d'une ability
func validate_ability(data: Dictionary) -> bool:
	var required = ["id", "name", "type", "cost"]
	return _json_loader.validate_schema(data, required)
```

## core/data/json_data_loader.gd

```text
class_name JSONDataLoader
extends RefCounted
## Chargeur JSON gÃ©nÃ©rique avec validation et cache

signal data_loaded(data_type: String, data: Dictionary)
signal data_load_failed(data_type: String, error: String)

var _cache: Dictionary = {}
var _schema_validators: Dictionary = {}

## Charge un fichier JSON avec cache optionnel
func load_json_file(file_path: String, use_cache: bool = true) -> Variant:
	if use_cache and _cache.has(file_path):
		return _cache[file_path]
	
	if not FileAccess.file_exists(file_path):
		push_error("JSON file not found: " + file_path)
		return null
	
	var file = FileAccess.open(file_path, FileAccess.READ)
	if not file:
		push_error("Failed to open JSON file: " + file_path)
		return null
	
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	var parse_result = json.parse(json_string)
	
	if parse_result != OK:
		var error_msg = "JSON parse error at line %d: %s" % [json.get_error_line(), json.get_error_message()]
		push_error(error_msg)
		return null
	
	var data = json.data
	
	if use_cache:
		_cache[file_path] = data
	
	return data

## Charge tous les fichiers JSON d'un dossier
func load_json_directory(dir_path: String, recursive: bool = false) -> Dictionary:
	var result = {}
	var dir = DirAccess.open(dir_path)
	
	if not dir:
		push_error("Failed to open directory: " + dir_path)
		return result
	
	dir.list_dir_begin()
	var file_name = dir.get_next()
	
	while file_name != "":
		if file_name.begins_with("."):
			file_name = dir.get_next()
			continue
		
		var full_path = dir_path.path_join(file_name)
		
		if dir.current_is_dir():
			if recursive:
				var subdir_data = load_json_directory(full_path, true)
				result[file_name] = subdir_data
		elif file_name.ends_with(".json"):
			var data = load_json_file(full_path)
			if data != null:
				var key = file_name.get_basename()
				result[key] = data
		
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return result

## Valide la structure d'un objet JSON selon un schÃ©ma basique
func validate_schema(data: Dictionary, required_fields: Array) -> bool:
	for field in required_fields:
		if not data.has(field):
			push_error("Missing required field: " + field)
			return false
	return true

## Charge et valide un fichier avec schÃ©ma
func load_validated_json(file_path: String, required_fields: Array = []) -> Variant:
	var data = load_json_file(file_path)
	
	if data == null:
		return null
	
	if data is Dictionary and required_fields.size() > 0:
		if not validate_schema(data, required_fields):
			return null
	
	return data

## Nettoie le cache (utile pour rechargement Ã  chaud)
func clear_cache(file_path: String = "") -> void:
	if file_path.is_empty():
		_cache.clear()
	else:
		_cache.erase(file_path)

## Sauvegarde des donnÃ©es en JSON (pour Ã©diteurs/outils)
func save_json_file(file_path: String, data: Variant) -> bool:
	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if not file:
		push_error("Failed to save JSON file: " + file_path)
		return false
	
	var json_string = JSON.stringify(data, "\t")
	file.store_string(json_string)
	file.close()
	return true
```

## core/data/model_validator.gd

```text
extends Node
class_name ModelValidator
## Validateur de modÃ¨les de donnÃ©es JSON

static var _models: Dictionary = {}

# ======================================================
# PUBLIC API
# ======================================================

static func validate(data: Variant, model_id: String) -> ValidationResult:
	var result := ValidationResult.new()
	var model := _load_model(model_id)

	if model.is_empty():
		result.add_error("Model not found: %s" % model_id)
		return result

	_validate_value(data, model, "", result)

	result.data = data
	return result


# ======================================================
# MODEL LOADING
# ======================================================

static func _load_model(model_id: String) -> Dictionary:
	if _models.has(model_id):
		return _models[model_id]

	var path := "res://data/models/%s_model.json" % model_id
	if not FileAccess.file_exists(path):
		push_error("[ModelValidator] Model file not found: " + path)
		return {}

	var file := FileAccess.open(path, FileAccess.READ)
	var parsed = JSON.parse_string(file.get_as_text())
	file.close()

	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("[ModelValidator] Invalid model format: " + model_id)
		return {}

	_models[model_id] = parsed
	return parsed


# ======================================================
# CORE VALIDATION
# ======================================================

static func _validate_value(value: Variant, model: Dictionary, path: String, result: ValidationResult) -> void:
	match model.get("type"):
		"object":
			_validate_object(value, model, path, result)

		"array":
			_validate_array(value, model, path, result)

		"vector2i":
			_validate_vector2i(value, path, result)

		_:
			result.add_error("%s: Unknown model type" % path)


# ======================================================
# OBJECT
# ======================================================

static func _validate_object(value, model, path, result):
	if typeof(value) != TYPE_DICTIONARY:
		result.add_error("%s must be an object" % path)
		return

	var fields: Dictionary = model.get("fields", {})

	for field_name in fields.keys():
		var rule = fields[field_name]
		var field_path = field_name if path == "" else "%s.%s" % [path, field_name]

		if rule.get("required", false) and not value.has(field_name):
			result.add_error("Missing field: %s" % field_path)
			continue

		if not value.has(field_name):
			continue

		_validate_field(value, field_name, rule, field_path, result)


# ======================================================
# ARRAY
# ======================================================

static func _validate_array(value, model, path, result):
	if typeof(value) != TYPE_ARRAY:
		result.add_error("%s must be an array" % path)
		return

	var item_model_id = model.get("items", {}).get("model", "")
	if item_model_id == "":
		return

	var item_model = _load_model(item_model_id)

	for i in range(value.size()):
		var item_path = "%s[%d]" % [path, i]
		_validate_value(value[i], item_model, item_path, result)


# ======================================================
# VECTOR2I
# ======================================================

static func _validate_vector2i(value, path, result):
	if typeof(value) != TYPE_DICTIONARY or not value.has("x") or not value.has("y"):
		result.add_error("%s must be a Vector2i-like object" % path)
		return

	value.x = int(value.x)
	value.y = int(value.y)


# ======================================================
# FIELD
# ======================================================

static func _validate_field(obj, key, rule, path, result):
	var v = obj[key]

	match rule.get("type"):
		"string":
			if typeof(v) != TYPE_STRING:
				result.add_error("%s must be a string" % path)

		"number":
			if typeof(v) != TYPE_FLOAT and typeof(v) != TYPE_INT:
				result.add_error("%s must be a number" % path)
				return

			if rule.get("integer", false) and typeof(v) == TYPE_FLOAT and v != int(v):
				result.add_error("%s must be an integer (got %s)" % [path, v])

			if rule.has("min") and v < rule.min:
				result.add_error("%s < min (%s)" % [path, rule.min])

			if rule.has("max") and v > rule.max:
				result.add_error("%s > max (%s)" % [path, rule.max])

			if rule.get("normalize") == "int":
				obj[key] = int(v)

		"object":
			var sub_model = rule.get("model", "")
			if sub_model != "":
				_validate_value(v, _load_model(sub_model), path, result)

		"array":
			if typeof(v) != TYPE_ARRAY:
				result.add_error("%s must be an array" % path)
				return
			
			var item_rule = rule.get("items", {})
			if not item_rule.is_empty():
				for i in range(v.size()):
					var item_path = "%s[%d]" % [path, i]
					if item_rule.has("model"):
						var item_model = _load_model(item_rule.model)
						_validate_value(v[i], item_model, item_path, result)

		"boolean":
			if typeof(v) != TYPE_BOOL:
				result.add_error("%s must be a boolean" % path)

# ======================================================
# CACHE MANAGEMENT
# ======================================================

static func clear_cache() -> void:
	"""Vide le cache des modÃ¨les"""
	_models.clear()

static func reload_model(model_id: String) -> void:
	"""Recharge un modÃ¨le spÃ©cifique"""
	_models.erase(model_id)
	_load_model(model_id)
```

## core/data/scene_registry.gd

```text
extends Node
## SceneRegistry - Registre centralisÃ© de toutes les scÃ¨nes du jeu
## Permet un accÃ¨s dÃ©couplÃ© aux chemins de scÃ¨nes
##
## NOTE : INTRO_DIALOGUE a Ã©tÃ© retirÃ© car la sÃ©quence d'intro
## est maintenant gÃ©rÃ©e par CampaignManager + DialogueManager + UIManager
## sans scÃ¨ne dÃ©diÃ©e.

class_name SceneRegistry

enum SceneID {
	# Menus
	MAIN_MENU,
	OPTIONS_MENU,
	PAUSE_MENU,
	SAVE_LOAD_MENU,
	
	# Monde
	WORLD_MAP,
	TOWN,
	CASTLE,
	
	# Combat
	BATTLE,
	BATTLE_PREPARATION,
	BATTLE_RESULTS,
	
	# Narration
	CUTSCENE,
	DIALOGUE,
	
	# SystÃ¨me
	LOADING_SCREEN,
	CREDITS,
}

const SCENE_PATHS: Dictionary = {
	# Menus
	SceneID.MAIN_MENU: "res://features/menu/main_menu.tscn",
	SceneID.OPTIONS_MENU: "res://features/menu/options_menu.tscn",
	SceneID.PAUSE_MENU: "res://features/menu/pause_menu.tscn",
	SceneID.SAVE_LOAD_MENU: "res://features/menu/save_load_menu.tscn",
	
	# Monde
	SceneID.WORLD_MAP: "res://features/world_map/visuals/world_map.tscn",
	SceneID.TOWN: "res://features/world_map/visuals/town.tscn",
	SceneID.CASTLE: "res://features/world_map/visuals/castle.tscn",
	
	# Combat
	SceneID.BATTLE: "res://features/combat/visuals/battle_3d.tscn",
	SceneID.BATTLE_PREPARATION: "res://features/combat/visuals/battle_preparation.tscn",
	SceneID.BATTLE_RESULTS: "res://features/Duo/ui/battle_results.tscn",
	
	# Narration
	SceneID.CUTSCENE: "res://features/narrative/cutscene.tscn",
	SceneID.DIALOGUE: "res://features/narrative/dialogue.tscn",
	
	# SystÃ¨me
	SceneID.LOADING_SCREEN: "res://shared/system/loading_screen.tscn",
	SceneID.CREDITS: "res://shared/credits/credits.tscn",
}

const SCENE_METADATA: Dictionary = {
	SceneID.MAIN_MENU: {
		"category": "menu",
		"requires_save": false,
		"pausable": false,
	},
	SceneID.WORLD_MAP: {
		"category": "world",
		"requires_save": true,
		"pausable": true,
		"music": "res://audio/music/world_theme.ogg",
	},
	SceneID.BATTLE: {
		"category": "battle",
		"requires_save": true,
		"pausable": true,
		"music": "res://audio/music/battle_theme.ogg",
	},
}

static func get_scene_path(scene_id: SceneID) -> String:
	if SCENE_PATHS.has(scene_id):
		return SCENE_PATHS[scene_id]
	push_error("[SceneRegistry] SceneID introuvable : ", scene_id)
	return ""

static func get_scene_metadata(scene_id: SceneID) -> Dictionary:
	if SCENE_METADATA.has(scene_id):
		return SCENE_METADATA[scene_id]
	return {}

static func scene_exists(scene_id: SceneID) -> bool:
	var path = get_scene_path(scene_id)
	return path != "" and ResourceLoader.exists(path)

static func get_scenes_by_category(category: String) -> Array[SceneID]:
	var result: Array[SceneID] = []
	for scene_id in SCENE_METADATA:
		var metadata = SCENE_METADATA[scene_id]
		if metadata.get("category") == category:
			result.append(scene_id)
	return result

static func get_scene_name(scene_id: SceneID) -> String:
	var scene_names = {
		SceneID.MAIN_MENU: "Menu Principal",
		SceneID.OPTIONS_MENU: "Options",
		SceneID.PAUSE_MENU: "Pause",
		SceneID.SAVE_LOAD_MENU: "Sauvegarder/Charger",
		SceneID.WORLD_MAP: "Carte du Monde",
		SceneID.TOWN: "Ville",
		SceneID.CASTLE: "ChÃ¢teau",
		SceneID.BATTLE: "Combat",
		SceneID.BATTLE_PREPARATION: "PrÃ©paration Combat",
		SceneID.BATTLE_RESULTS: "RÃ©sultats Combat",
		SceneID.CUTSCENE: "CinÃ©matique",
		SceneID.DIALOGUE: "Dialogue",
		SceneID.LOADING_SCREEN: "Chargement",
		SceneID.CREDITS: "CrÃ©dits",
	}
	return scene_names.get(scene_id, "Inconnu")

static func validate_registry() -> bool:
	var all_valid = true
	for scene_id in SCENE_PATHS:
		var path = SCENE_PATHS[scene_id]
		if not ResourceLoader.exists(path):
			push_warning("[SceneRegistry] ScÃ¨ne manquante : ", get_scene_name(scene_id), " (", path, ")")
			all_valid = false
	return all_valid
```

## core/data/validation_result.gd

```text
extends RefCounted
class_name ValidationResult
## RÃ©sultat d'une validation de donnÃ©es

var is_valid: bool = true
var errors: Array[String] = []
var data: Variant = null

func add_error(message: String) -> void:
	"""Ajoute une erreur et marque le rÃ©sultat comme invalide"""
	errors.append(message)
	is_valid = false

func has_errors() -> bool:
	"""VÃ©rifie si des erreurs sont prÃ©sentes"""
	return not errors.is_empty()

func get_errors_string() -> String:
	"""Retourne toutes les erreurs en une seule chaÃ®ne"""
	return "\n".join(errors)

func clear() -> void:
	"""RÃ©initialise le rÃ©sultat"""
	is_valid = true
	errors.clear()
	data = null
```

## core/dialogue/bark_system.gd

```text
extends Node
class_name BarkSystem
## SystÃ¨me de "barks" - messages courts au-dessus des personnages

signal bark_shown(speaker: String, text: String)
signal bark_hidden(speaker: String)

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var default_duration: float = 2.0
@export var fade_duration: float = 0.3
@export var max_barks: int = 5
@export var bark_offset: Vector2 = Vector2(0, -50)

# ============================================================================
# Ã‰TAT
# ============================================================================

var active_barks: Dictionary = {}  # speaker -> BarkLabel
var bark_container: CanvasLayer = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_create_bark_container()
	print("[BarkSystem] âœ… InitialisÃ©")

func _create_bark_container() -> void:
	"""CrÃ©e le conteneur pour les barks"""
	bark_container = CanvasLayer.new()
	bark_container.layer = 50
	bark_container.name = "BarkContainer"
	add_child(bark_container)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func show_bark(speaker: String, text: String, world_position: Vector2, duration: float = -1.0) -> void:
	"""Affiche un bark au-dessus d'une position"""
	
	if duration < 0:
		duration = default_duration
	
	# Supprimer le bark existant pour ce speaker
	if active_barks.has(speaker):
		_remove_bark(speaker)
	
	# Limiter le nombre de barks
	while active_barks.size() >= max_barks:
		var oldest = active_barks.keys()[0]
		_remove_bark(oldest)
	
	# CrÃ©er le nouveau bark
	var bark_label = _create_bark_label(text, world_position)
	active_barks[speaker] = bark_label
	bark_container.add_child(bark_label)
	
	# Animation d'apparition
	bark_label.modulate.a = 0.0
	var tween = create_tween()
	tween.tween_property(bark_label, "modulate:a", 1.0, fade_duration)
	
	bark_shown.emit(speaker, text)
	
	# Timer de disparition
	await get_tree().create_timer(duration).timeout
	
	if active_barks.has(speaker) and is_instance_valid(active_barks[speaker]):
		_fade_out_bark(speaker)

func hide_bark(speaker: String) -> void:
	"""Cache immÃ©diatement un bark"""
	_remove_bark(speaker)

func hide_all_barks() -> void:
	"""Cache tous les barks"""
	for speaker in active_barks.keys():
		_remove_bark(speaker)

# ============================================================================
# CRÃ‰ATION UI
# ============================================================================

func _create_bark_label(text: String, world_position: Vector2) -> PanelContainer:
	"""CrÃ©e un label de bark stylisÃ©"""
	
	var panel = PanelContainer.new()
	
	# Style du panel
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.1, 0.1, 0.15, 0.9)
	style.border_width_left = 2
	style.border_width_top = 2
	style.border_width_right = 2
	style.border_width_bottom = 2
	style.border_color = Color(0.5, 0.5, 0.6)
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	style.content_margin_left = 10
	style.content_margin_top = 5
	style.content_margin_right = 10
	style.content_margin_bottom = 5
	panel.add_theme_stylebox_override("panel", style)
	
	# Label
	var label = Label.new()
	label.text = text
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	label.custom_minimum_size = Vector2(50, 0)
	panel.add_child(label)
	
	# Position (convertir world Ã  screen si nÃ©cessaire)
	panel.position = world_position + bark_offset
	
	return panel

func _fade_out_bark(speaker: String) -> void:
	"""Fait disparaÃ®tre un bark avec animation"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	if not is_instance_valid(bark):
		active_barks.erase(speaker)
		return
	
	var tween = create_tween()
	tween.tween_property(bark, "modulate:a", 0.0, fade_duration)
	tween.tween_callback(func(): _remove_bark(speaker))

func _remove_bark(speaker: String) -> void:
	"""Supprime un bark"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	active_barks.erase(speaker)
	
	if is_instance_valid(bark):
		bark.queue_free()
	
	bark_hidden.emit(speaker)

# ============================================================================
# MISE Ã€ JOUR POSITION
# ============================================================================

func update_bark_position(speaker: String, world_position: Vector2) -> void:
	"""Met Ã  jour la position d'un bark (pour suivre un personnage)"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	if is_instance_valid(bark):
		bark.position = world_position + bark_offset
```

## core/dialogue/dialogue_box.gd

```text
extends Control
class_name DialogueBoxClass
## BoÃ®te de dialogue UI - Ã  Ã©tendre ou utiliser directement

# ============================================================================
# SIGNAUX
# ============================================================================

signal text_reveal_completed()
signal choice_selected(index: int)
signal dialogue_box_shown()
signal dialogue_box_hidden()

# ============================================================================
# RÃ‰FÃ‰RENCES (Ã  connecter dans l'inspecteur ou via code)
# ============================================================================

@export var speaker_label: Label
@export var text_label: RichTextLabel
@export var portrait_texture: TextureRect
@export var choices_container: VBoxContainer
@export var continue_indicator: Control

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var typewriter_speed: float = 50.0  # CaractÃ¨res par seconde
@export var show_continue_indicator: bool = true
@export var auto_size: bool = true

# ============================================================================
# Ã‰TAT
# ============================================================================

var dialogue_manager = null  # RÃ©fÃ©rence au DialogueManager
var is_text_revealing: bool = false
var current_text: String = ""
var revealed_characters: int = 0
var _typewriter_timer: float = 0.0

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# CrÃ©er l'UI si pas de rÃ©fÃ©rences
	if not speaker_label or not text_label:
		_create_default_ui()
	
	# Cacher par dÃ©faut
	visible = false
	
	if continue_indicator:
		continue_indicator.visible = false

func _create_default_ui() -> void:
	"""CrÃ©e une UI de dialogue par dÃ©faut"""
	
	# Panel principal
	var panel = PanelContainer.new()
	panel.set_anchors_preset(Control.PRESET_BOTTOM_WIDE)
	panel.anchor_top = 0.7
	panel.offset_top = 0
	panel.offset_bottom = -20
	panel.offset_left = 20
	panel.offset_right = -20
	add_child(panel)
	
	# Style
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.08, 0.08, 0.12, 0.95)
	style.border_width_left = 3
	style.border_width_top = 3
	style.border_width_right = 3
	style.border_width_bottom = 3
	style.border_color = Color(0.4, 0.4, 0.6)
	style.corner_radius_top_left = 12
	style.corner_radius_top_right = 12
	style.corner_radius_bottom_left = 12
	style.corner_radius_bottom_right = 12
	panel.add_theme_stylebox_override("panel", style)
	
	# Margin
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 20)
	margin.add_theme_constant_override("margin_top", 15)
	margin.add_theme_constant_override("margin_right", 20)
	margin.add_theme_constant_override("margin_bottom", 15)
	panel.add_child(margin)
	
	# VBox
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 10)
	margin.add_child(vbox)
	
	# Speaker
	speaker_label = Label.new()
	speaker_label.add_theme_font_size_override("font_size", 24)
	speaker_label.add_theme_color_override("font_color", Color(0.9, 0.8, 0.5))
	vbox.add_child(speaker_label)
	
	# Text
	text_label = RichTextLabel.new()
	text_label.bbcode_enabled = true
	text_label.fit_content = true
	text_label.scroll_active = false
	text_label.size_flags_vertical = Control.SIZE_EXPAND_FILL
	text_label.add_theme_font_size_override("normal_font_size", 20)
	vbox.add_child(text_label)
	
	# Choices container
	choices_container = VBoxContainer.new()
	choices_container.add_theme_constant_override("separation", 8)
	choices_container.visible = false
	vbox.add_child(choices_container)
	
	# Continue indicator
	continue_indicator = Label.new()
	continue_indicator.text = "â–¼"
	continue_indicator.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	continue_indicator.visible = false
	vbox.add_child(continue_indicator)

# ============================================================================
# AFFICHAGE
# ============================================================================

func show_dialogue_box() -> void:
	"""Affiche la boÃ®te de dialogue"""
	visible = true
	dialogue_box_shown.emit()

func hide_dialogue_box() -> void:
	"""Cache la boÃ®te de dialogue"""
	visible = false
	is_text_revealing = false
	dialogue_box_hidden.emit()

func display_line(line: Dictionary) -> void:
	"""Affiche une ligne de dialogue"""
	
	# Speaker
	var speaker = line.get("speaker", "")
	if speaker_label:
		speaker_label.text = speaker
		speaker_label.visible = speaker != ""
	
	# Portrait
	if portrait_texture and line.has("portrait"):
		var portrait_path = line.get("portrait", "")
		if portrait_path != "" and ResourceLoader.exists(portrait_path):
			portrait_texture.texture = load(portrait_path)
			portrait_texture.visible = true
		else:
			portrait_texture.visible = false
	
	# Texte
	var text = line.get("text", "")
	var text_key = line.get("text_key", "")
	
	if text_key != "":
		text = tr(text_key)
	
	current_text = text
	
	# Cacher les choix
	if choices_container:
		choices_container.visible = false
		_clear_choices()
	
	# Cacher l'indicateur de continuation
	if continue_indicator:
		continue_indicator.visible = false
	
	# DÃ©marrer le typewriter
	var speed = line.get("speed", typewriter_speed)
	_start_typewriter(text, speed)

func display_choices(choices: Array) -> void:
	"""Affiche les choix"""
	
	if not choices_container:
		return
	
	_clear_choices()
	
	for i in range(choices.size()):
		var choice = choices[i]
		var button = Button.new()
		
		var choice_text = choice.get("text", "")
		var choice_key = choice.get("text_key", "")
		
		if choice_key != "":
			choice_text = tr(choice_key)
		
		button.text = choice_text
		button.custom_minimum_size = Vector2(0, 40)
		button.pressed.connect(func(): _on_choice_pressed(i))
		
		choices_container.add_child(button)
	
	choices_container.visible = true

func _clear_choices() -> void:
	"""Supprime tous les boutons de choix"""
	if choices_container:
		for child in choices_container.get_children():
			child.queue_free()

func _on_choice_pressed(index: int) -> void:
	"""Callback quand un choix est sÃ©lectionnÃ©"""
	choice_selected.emit(index)
	
	if dialogue_manager:
		dialogue_manager.select_choice(index)

# ============================================================================
# TYPEWRITER
# ============================================================================

func _start_typewriter(text: String, speed: float) -> void:
	"""DÃ©marre l'effet typewriter"""
	
	current_text = text
	revealed_characters = 0
	is_text_revealing = true
	typewriter_speed = speed
	_typewriter_timer = 0.0
	
	if text_label:
		text_label.text = ""

func _process(delta: float) -> void:
	if not is_text_revealing:
		return
	
	_typewriter_timer += delta * typewriter_speed
	
	var chars_to_show = int(_typewriter_timer)
	
	if chars_to_show > revealed_characters:
		revealed_characters = chars_to_show
		
		if text_label:
			if revealed_characters >= current_text.length():
				text_label.text = current_text
				complete_text()
			else:
				text_label.text = current_text.substr(0, revealed_characters)

func complete_text() -> void:
	"""ComplÃ¨te immÃ©diatement le texte"""
	
	if text_label:
		text_label.text = current_text
	
	revealed_characters = current_text.length()
	is_text_revealing = false
	
	# Afficher l'indicateur de continuation
	if continue_indicator and show_continue_indicator:
		continue_indicator.visible = true
	
	text_reveal_completed.emit()

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	if not visible:
		return
	
	# Avancer le dialogue
	if event.is_action_pressed("ui_accept") or event.is_action_pressed("ui_select"):
		if dialogue_manager:
			dialogue_manager.advance_dialogue()
		get_viewport().set_input_as_handled()
```

## core/dialogue/dialogue_box.tscn

```text
[gd_scene load_steps=3 format=3 uid="uid://byp8xytm75beo"]

[ext_resource type="Script" uid="uid://d0bmm781h8rqb" path="res://core/dialogue/dialogue_box.gd" id="1_fd1y2"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_panel"]
bg_color = Color(0.1, 0.1, 0.12, 0.95)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.7, 0.7, 0.8, 1)
corner_radius_top_left = 12
corner_radius_top_right = 12
corner_radius_bottom_right = 12
corner_radius_bottom_left = 12

[node name="DialogueBox" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_fd1y2")

[node name="DialoguePanel" type="PanelContainer" parent="."]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -700.0
offset_top = -250.0
offset_right = 700.0
offset_bottom = -50.0
grow_horizontal = 2
grow_vertical = 0
theme_override_styles/panel = SubResource("StyleBoxFlat_panel")

[node name="MarginContainer" type="MarginContainer" parent="DialoguePanel"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="HBoxContainer" type="HBoxContainer" parent="DialoguePanel/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="Portrait" type="TextureRect" parent="DialoguePanel/MarginContainer/HBoxContainer"]
custom_minimum_size = Vector2(128, 128)
layout_mode = 2
size_flags_vertical = 0
expand_mode = 1
stretch_mode = 5

[node name="VBoxContainer" type="VBoxContainer" parent="DialoguePanel/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="SpeakerLabel" type="Label" parent="DialoguePanel/MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.85, 0.5, 1)
theme_override_font_sizes/font_size = 24
text = "Speaker Name"

[node name="TextLabel" type="RichTextLabel" parent="DialoguePanel/MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Dialogue text goes here..."
fit_content = true
scroll_active = false

[node name="ChoicesContainer" type="VBoxContainer" parent="DialoguePanel/MarginContainer/VBoxContainer"]
visible = false
layout_mode = 2
theme_override_constants/separation = 10

[node name="ContinueIndicator" type="Label" parent="DialoguePanel"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 1, 0.5, 1)
text = "â–¼ Appuyez"
horizontal_alignment = 2
vertical_alignment = 2

[node name="VoicePlayer" type="AudioStreamPlayer" parent="."]

[node name="AdvanceSFX" type="AudioStreamPlayer" parent="."]
```

## core/dialogue/dialogue_data.gd

```text
extends Resource
class_name DialogueData
## Structure de donnÃ©es pour un dialogue

@export var dialogue_id: String = ""
@export var lines: Array[Dictionary] = []
@export var metadata: Dictionary = {}

## Structure d'une ligne de dialogue :
## {
##   "speaker": "nom_du_personnage",
##   "text": "Texte du dialogue",
##   "text_key": "DIALOGUE_KEY",  # ClÃ© de traduction (optionnel)
##   "portrait": "res://path/to/portrait.png",  # (optionnel)
##   "emotion": "happy",  # (optionnel)
##   "speed": 50.0,  # Vitesse du texte (optionnel)
##   "auto_advance": false,  # Auto-avance (optionnel)
##   "auto_delay": 2.0,  # DÃ©lai avant auto-avance (optionnel)
##   "choices": [],  # Choix possibles (optionnel)
##   "event": {},  # Ã‰vÃ©nement Ã  dÃ©clencher (optionnel)
## }

func _init(id: String = "", dialogue_lines: Array = []) -> void:
	dialogue_id = id
	for line in dialogue_lines:
		lines.append(line)

func add_line(line_data: Dictionary) -> void:
	"""Ajoute une ligne de dialogue"""
	lines.append(line_data)

func get_line(index: int) -> Dictionary:
	"""RÃ©cupÃ¨re une ligne par son index"""
	if index >= 0 and index < lines.size():
		return lines[index]
	return {}

func get_line_count() -> int:
	"""Retourne le nombre de lignes"""
	return lines.size()

## CrÃ©e un DialogueData depuis un dictionnaire JSON
static func from_dict(data: Dictionary) -> DialogueData:
	var dialogue = DialogueData.new()
	dialogue.dialogue_id = data.get("dialogue_id", "")
	dialogue.metadata = data.get("metadata", {})
	
	var raw_lines = data.get("lines", [])
	for line in raw_lines:
		dialogue.lines.append(line)
	
	return dialogue

## Convertit en dictionnaire pour sauvegarde
func to_dict() -> Dictionary:
	return {
		"dialogue_id": dialogue_id,
		"lines": lines,
		"metadata": metadata
	}
```

## core/dialogue/dialogue_data_loader.gd

```text
# addons/core/data/dialogue_data_loader.gd
class_name DialogueDataLoader
extends Node

const DIALOGUES_DIR = "res://data/dialogues/"

var _json_loader: JSONDataLoader
var dialogues: Dictionary = {}

func _init():
	_json_loader = JSONDataLoader.new()

func load_all_dialogues() -> void:
	dialogues = _json_loader.load_json_directory(DIALOGUES_DIR, true)
	
	if dialogues.is_empty():
		push_warning("No dialogues loaded")
	else:
		print("Loaded %d dialogue sets" % dialogues.size())
		GameRoot.event_bus.emit_signal("data_loaded", "dialogues", dialogues)

# âœ… NOUVELLE MÃ‰THODE : Charge un dialogue spÃ©cifique
func load_dialogue(dialogue_id: String) -> Dictionary:
	"""
	Charge un dialogue depuis un fichier JSON
	
	@param dialogue_id : ID du dialogue (nom du fichier sans .json)
	@return Dictionary contenant le dialogue, ou {} si introuvable
	"""
	var file_path = DIALOGUES_DIR.path_join(dialogue_id + ".json")
	
	if not FileAccess.file_exists(file_path):
		push_error("[DialogueDataLoader] Fichier introuvable : ", file_path)
		return {}
	
	var data = _json_loader.load_json_file(file_path)
	
	if typeof(data) != TYPE_DICTIONARY or data.is_empty():
		push_error("[DialogueDataLoader] Format invalide pour : ", dialogue_id)
		return {}
	
	# Stocker en cache
	dialogues[dialogue_id] = data
	
	return data

func get_dialogue(dialogue_id: String) -> Dictionary:
	# VÃ©rifier le cache d'abord
	if dialogues.has(dialogue_id):
		return dialogues[dialogue_id]
	
	# Sinon, charger depuis le fichier
	return load_dialogue(dialogue_id)

func get_dialogue_node(dialogue_id: String, node_id: String) -> Dictionary:
	var dialogue = get_dialogue(dialogue_id)
	if dialogue.has("nodes") and dialogue.nodes.has(node_id):
		return dialogue.nodes[node_id]
	return {}

func reload_dialogue(dialogue_id: String) -> void:
	var file_path = DIALOGUES_DIR.path_join(dialogue_id + ".json")
	_json_loader.clear_cache(file_path)
	var data = load_dialogue(dialogue_id)
	
	if not data.is_empty():
		GameRoot.event_bus.emit_signal("dialogue_reloaded", dialogue_id)
```

## core/game_root.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://gameroot001"]

[ext_resource type="Script" path="res://core/autoloads/game_root.gd" id="1_gameroot"]

[node name="GameRoot" type="Node"]
script = ExtResource("1_gameroot")

[node name="SceneContainer" type="Node" parent="."]
```

## features/debug/debug_version_panel.gd

```text
extends Control

@onready var label = self


func _ready():
	var text := "=== DEBUG VERSION INFO ===\n\n"
	text += load_build_info()
	text += "\n"
	text += load_doc_status()

	label.text = text


func load_build_info() -> String:
	var path = "res://documentation/build_info.json"
	if not FileAccess.file_exists(path):
		return "Build info: NOT AVAILABLE\n"

	var file = FileAccess.open(path, FileAccess.READ)
	if file == null:
		return "Build info: FAILED TO OPEN\n"

	var content = file.get_as_text()
	var data = JSON.parse_string(content)

	if typeof(data) != TYPE_DICTIONARY:
		return "Build info: INVALID JSON\n"

	var text := "=== BUILD INFO ===\n"
	text += "Game Version : %s\n" % data.get("game_version", "unknown")
	text += "Git Commit   : %s\n" % data.get("git_commit", "unknown")
	text += "Git Branch   : %s\n" % data.get("git_branch", "unknown")
	text += "Build Date   : %s\n" % data.get("build_date", "unknown")

	if data.get("git_dirty", false):
		text += "Working Tree : DIRTY âš ï¸\n"
	else:
		text += "Working Tree : CLEAN\n"

	return text


func load_doc_status() -> String:
	var path = "res://documentation/DOCUMENTATION_STATUS.md"
	if not FileAccess.file_exists(path):
		return "Documentation status: NOT AVAILABLE\n"

	var file = FileAccess.open(path, FileAccess.READ)
	if file == null:
		return "Documentation status: FAILED TO OPEN\n"

	return "Documentation status: AVAILABLE\n"
```

## features/menu/main_menu.gd

```text
extends Control
## Menu Principal - Point d'entrÃ©e du jeu
##
## Le bouton "Nouvelle Partie" Ã©met game_started via EventBus.
## CampaignManager reÃ§oit ce signal et orchestre la sÃ©quence d'intro
## (dialogues via DialogueManager, UI via UIManager, puis transition vers WorldMap)

class_name MainMenu

# RÃ©fÃ©rences aux nÅ“uds UI
@onready var start_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/StartButton
@onready var continue_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/ContinueButton
@onready var options_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/OptionsButton
@onready var credits_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/CreditsButton
@onready var quit_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/QuitButton
@onready var title_label: Label = $MarginContainer/VBoxContainer/TitleLabel
@onready var version_label: Label = $MarginContainer/VBoxContainer/VersionLabel

var has_save: bool = false

func _ready() -> void:
	_check_save_availability()
	_connect_buttons()
	_play_intro_animation()
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("game_started", _on_game_started)
		GameRoot.event_bus.safe_connect("game_loaded", _on_game_loaded)
	
	print("[MainMenu] âœ… InitialisÃ©")

func _connect_buttons() -> void:
	"""Connecte les boutons manuellement"""
	start_button.pressed.connect(_on_start_pressed)
	continue_button.pressed.connect(_on_continue_pressed)
	options_button.pressed.connect(_on_options_pressed)
	credits_button.pressed.connect(_on_credits_pressed)
	quit_button.pressed.connect(_on_quit_pressed)

func _check_save_availability() -> void:
	has_save = false
	if GameRoot and GameRoot.game_manager:
		has_save = GameRoot.game_manager.has_save("auto_save")
	
	continue_button.disabled = not has_save
	if not has_save:
		continue_button.modulate.a = 0.5

func _play_intro_animation() -> void:
	title_label.modulate.a = 0.0
	
	var tween = create_tween()
	tween.set_parallel(true)
	tween.tween_property(title_label, "modulate:a", 1.0, 0.8).set_ease(Tween.EASE_OUT)
	tween.tween_property(title_label, "position:y", title_label.position.y, 0.8).from(title_label.position.y - 50).set_ease(Tween.EASE_OUT)

# ============================================================================
# CALLBACKS BOUTONS
# ============================================================================

func _on_start_pressed() -> void:
	"""Nouvelle partie : Ã©met game_started, CampaignManager gÃ¨re la suite"""
	print("[MainMenu] â–¶ Nouvelle partie")
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("DÃ©marrage d'une nouvelle partie...", "info")
		# CampaignManager Ã©coute ce signal et lance la sÃ©quence d'intro
		# puis transite vers la WorldMap automatiquement
		GameRoot.event_bus.game_started.emit()

func _on_continue_pressed() -> void:
	if not has_save:
		return
	
	print("[MainMenu] â†» Chargement de la derniÃ¨re sauvegarde")
	
	if GameRoot:
		GameRoot.event_bus.notify("Chargement de la partie...", "info")
		GameRoot.game_manager.load_game("auto_save")

func _on_options_pressed() -> void:
	print("[MainMenu] âš™ Options")
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Options (Ã  implÃ©menter)", "info")

func _on_credits_pressed() -> void:
	print("[MainMenu] â„¹ CrÃ©dits")
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("CrÃ©dits (Ã  implÃ©menter)", "info")

func _on_quit_pressed() -> void:
	print("[MainMenu] âœ• Quitter le jeu")
	
	var tween = create_tween()
	tween.tween_property(self, "modulate:a", 0.0, 0.3)
	await tween.finished
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.quit_game_requested.emit()

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_game_started() -> void:
	print("[MainMenu] Le jeu dÃ©marre (EventBus)")

func _on_game_loaded(save_name: String) -> void:
	print("[MainMenu] Sauvegarde chargÃ©e : %s" % save_name)

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	if OS.is_debug_build():
		if event.is_action_pressed("ui_accept") and not event.is_echo():
			_on_start_pressed()

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## features/menu/main_menu.tscn

```text
[gd_scene load_steps=4 format=3 uid="uid://ceiip1bmiqtbi"]

[ext_resource type="Script" uid="uid://cj5p8ylemcqq8" path="res://features/menu/main_menu.gd" id="1_main_menu"]
[ext_resource type="Script" uid="uid://bqr3y5fer6hv3" path="res://features/debug/debug_version_panel.gd" id="2_3rkf3"]
[ext_resource type="Texture2D" uid="uid://c2wwmbmqrjpes" path="res://asset/twinbound_bg.png" id="2_xlk05"]

[node name="MainMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_main_menu")

[node name="Background" type="Sprite2D" parent="."]
position = Vector2(1033.2, 541.8)
scale = Vector2(1.3460938, 1.053125)
texture = ExtResource("2_xlk05")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 100
theme_override_constants/margin_top = 80
theme_override_constants/margin_right = 100
theme_override_constants/margin_bottom = 80

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 30
alignment = 1

[node name="TitleLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 6
theme_override_colors/font_color = Color(0.9, 0.85, 0.7, 1)
theme_override_font_sizes/font_size = 72
horizontal_alignment = 1

[node name="SubtitleLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 0
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_colors/font_shadow_color = Color(1, 1, 1, 1)
theme_override_colors/font_outline_color = Color(1, 1, 1, 1)
theme_override_font_sizes/font_size = 24
text = "documentation status"
horizontal_alignment = 1
script = ExtResource("2_3rkf3")

[node name="Spacer1" type="Control" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2

[node name="ButtonsContainer" type="VBoxContainer" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 20

[node name="StartButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "â–¶ Nouvelle Partie"

[node name="ContinueButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "â†» Continuer"

[node name="OptionsButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "âš™ Options"

[node name="CreditsButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "â„¹ CrÃ©dits"

[node name="QuitButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "âœ• Quitter"

[node name="Spacer2" type="Control" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2

[node name="VersionLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.7, 0.65, 0.5, 1)
theme_override_font_sizes/font_size = 24
text = "documentation status"
horizontal_alignment = 1
```

## features/world_map/logic/world_map.gd

```text
# features/world_map/logic/world_map.gd
extends Node2D
## World Map - Carte du monde
## ScÃ¨ne chargÃ©e dans le SceneContainer par SceneLoader
##
## Les dialogues utilisent DialogueManager + UIManager (persistants)
## Les combats sont dÃ©lÃ©guÃ©s Ã  CampaignManager

class_name WorldMap

# ============================================================================
# RÃ‰FÃ‰RENCES
# ============================================================================

@onready var camera: Camera2D = $Camera2D
@onready var ui_layer: CanvasLayer = $UI
@onready var locations_container: Node2D = $LocationsContainer
@onready var connections_container: Node2D = $ConnectionsContainer
@onready var player_container: Node2D = $PlayerContainer

# Labels UI existants
@onready var info_label: Label = $UI/BottomBar/MarginContainer/HBoxContainer/InfoLabel
@onready var party_button: Button = $UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer/PartyButton
@onready var inventory_button: Button = $UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer/InventoryButton
@onready var menu_button: Button = $UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer/MenuButton
@onready var notification_panel: PanelContainer = $UI/NotificationPanel
@onready var notification_label: Label = $UI/NotificationPanel/MarginContainer/NotificationLabel

# ============================================================================
# DONNÃ‰ES
# ============================================================================

var world_map_data: Dictionary = {}
var locations: Dictionary = {}  # location_id -> WorldMapLocation
var player: WorldMapPlayer = null
var connections: Dictionary = {}  # connection_id -> WorldMapConnection

# ============================================================================
# Ã‰TAT
# ============================================================================

var current_step: int = 0
var selected_location: WorldMapLocation = null

# Menu d'actions
var action_menu: PopupPanel = null
var action_menu_container: VBoxContainer = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_create_action_menu()
	_connect_ui_buttons()
	_load_world_map_data()
	_generate_map()
	_spawn_player()
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("notification_posted", _on_notification_posted)
	
	print("[WorldMap] âœ… Carte gÃ©nÃ©rÃ©e")

func _create_action_menu() -> void:
	action_menu = PopupPanel.new()
	action_menu.name = "ActionMenu"
	action_menu.visible = false
	action_menu.popup_window = false
	action_menu.transparent_bg = false
	action_menu.borderless = false
	
	var stylebox = StyleBoxFlat.new()
	stylebox.bg_color = Color(0.1, 0.1, 0.15, 0.95)
	stylebox.border_width_left = 2
	stylebox.border_width_top = 2
	stylebox.border_width_right = 2
	stylebox.border_width_bottom = 2
	stylebox.border_color = Color(0.9, 0.9, 0.9)
	stylebox.corner_radius_top_left = 8
	stylebox.corner_radius_top_right = 8
	stylebox.corner_radius_bottom_left = 8
	stylebox.corner_radius_bottom_right = 8
	action_menu.add_theme_stylebox_override("panel", stylebox)
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 10)
	margin.add_theme_constant_override("margin_top", 10)
	margin.add_theme_constant_override("margin_right", 10)
	margin.add_theme_constant_override("margin_bottom", 10)
	action_menu.add_child(margin)
	
	action_menu_container = VBoxContainer.new()
	action_menu_container.custom_minimum_size = Vector2(220, 100)
	action_menu_container.add_theme_constant_override("separation", 5)
	margin.add_child(action_menu_container)
	
	ui_layer.add_child(action_menu)

func _connect_ui_buttons() -> void:
	if party_button:
		party_button.pressed.connect(_on_party_pressed)
	if inventory_button:
		inventory_button.pressed.connect(_on_inventory_pressed)
	if menu_button:
		menu_button.pressed.connect(_on_menu_pressed)

# ============================================================================
# CHARGEMENT DES DONNÃ‰ES
# ============================================================================

func _load_world_map_data() -> void:
	world_map_data = WorldMapDataLoader.load_world_map_data("world_map_data", true)
	
	if world_map_data.is_empty():
		push_error("[WorldMap] âŒ Impossible de charger les donnÃ©es de la carte")
		return
	
	print("[WorldMap] ðŸ“¦ DonnÃ©es chargÃ©es : %s" % world_map_data.get("name", "???"))

# ============================================================================
# GÃ‰NÃ‰RATION DE LA CARTE
# ============================================================================

func _generate_map() -> void:
	if world_map_data.is_empty():
		return
	
	_create_locations()
	_create_connections()
	
	print("[WorldMap] âœ… Carte gÃ©nÃ©rÃ©e : %d locations" % locations.size())

func _create_locations() -> void:
	var locations_data = world_map_data.get("locations", [])
	
	for location_data in locations_data:
		var location = WorldMapLocation.new()
		locations_container.add_child(location)
		location.setup(location_data)
		
		var unlocked = location_data.get("unlocked_at_step", 0) <= current_step
		location.set_unlocked(unlocked)
		
		location.clicked.connect(_on_location_clicked)
		location.hovered.connect(_on_location_hovered)
		location.unhovered.connect(_on_location_unhovered)
		
		locations[location_data.id] = location

func _create_connections() -> void:
	var visual_config = world_map_data.get("connections_visual", {})
	
	if visual_config.has("width"):
		WorldMapConnection.default_line_width = visual_config.width
	if visual_config.has("dash_length"):
		WorldMapConnection.default_dash_length = visual_config.dash_length
	
	if visual_config.has("color"):
		var c = visual_config.color
		WorldMapConnection.default_color_unlocked = Color(
			c.get("r", 0.7), c.get("g", 0.7), c.get("b", 0.7), c.get("a", 0.8)
		)
	
	if visual_config.has("color_locked"):
		var c = visual_config.color_locked
		WorldMapConnection.default_color_locked = Color(
			c.get("r", 0.3), c.get("g", 0.3), c.get("b", 0.3), c.get("a", 0.4)
		)
	
	var connection_states = world_map_data.get("connection_states", {})
	
	for location_id in locations:
		var location = locations[location_id]
		var location_connections = location.get_connections()
		
		for target_id in location_connections:
			if not locations.has(target_id):
				continue
			
			var target_location = locations[target_id]
			var connection_id = _get_connection_id(location_id, target_id)
			if connections.has(connection_id):
				continue
			
			var connection = WorldMapConnection.new()
			var initial_state = _get_connection_state(location_id, target_id, connection_states)
			connection.setup(location, target_location, initial_state)
			connections_container.add_child(connection)
			connections[connection_id] = connection
	
	print("[WorldMap] âœ… %d connexions crÃ©Ã©es" % connections.size())

# ============================================================================
# HELPERS CONNEXIONS
# ============================================================================

func _get_connection_id(from_id: String, to_id: String) -> String:
	var ids = [from_id, to_id]
	ids.sort()
	return ids[0] + "_to_" + ids[1]

func _get_connection_state(from_id: String, to_id: String, states: Dictionary) -> WorldMapConnection.ConnectionState:
	var connection_id = _get_connection_id(from_id, to_id)
	
	if states.has(connection_id):
		var state_str = states[connection_id]
		match state_str:
			"unlocked":
				return WorldMapConnection.ConnectionState.UNLOCKED
			"locked":
				return WorldMapConnection.ConnectionState.LOCKED
			"hidden":
				return WorldMapConnection.ConnectionState.HIDDEN
	
	var from_loc = locations.get(from_id)
	var to_loc = locations.get(to_id)
	
	if from_loc and to_loc and from_loc.is_unlocked and to_loc.is_unlocked:
		return WorldMapConnection.ConnectionState.UNLOCKED
	
	return WorldMapConnection.ConnectionState.HIDDEN

# ============================================================================
# API CONNEXIONS
# ============================================================================

func unlock_connection(from_id: String, to_id: String) -> void:
	var connection_id = _get_connection_id(from_id, to_id)
	if connections.has(connection_id):
		connections[connection_id].unlock()

func lock_connection(from_id: String, to_id: String) -> void:
	var connection_id = _get_connection_id(from_id, to_id)
	if connections.has(connection_id):
		connections[connection_id].lock()

func hide_connection(from_id: String, to_id: String) -> void:
	var connection_id = _get_connection_id(from_id, to_id)
	if connections.has(connection_id):
		connections[connection_id].hide_connection()

func reveal_connection(from_id: String, to_id: String, locked: bool = true) -> void:
	var connection_id = _get_connection_id(from_id, to_id)
	if connections.has(connection_id):
		if locked:
			connections[connection_id].lock()
		else:
			connections[connection_id].unlock()

# ============================================================================
# JOUEUR
# ============================================================================

func _spawn_player() -> void:
	player = WorldMapPlayer.new()
	player_container.add_child(player)
	
	var player_config = world_map_data.get("player", {})
	player.setup(player_config)
	
	var start_location_id = player_config.get("start_location", "")
	
	if locations.has(start_location_id):
		player.set_location(locations[start_location_id])
	else:
		push_warning("[WorldMap] Location de dÃ©part introuvable : %s" % start_location_id)
		for loc_id in locations:
			if locations[loc_id].is_unlocked:
				player.set_location(locations[loc_id])
				break
	
	player.movement_completed.connect(_on_player_movement_completed)

# ============================================================================
# INTERACTIONS LOCATIONS
# ============================================================================

func _on_location_clicked(location: WorldMapLocation) -> void:
	if player.current_location_id == location.location_id:
		_open_location_menu(location)
		return
	
	var current_loc = locations.get(player.current_location_id)
	if not current_loc:
		return
	
	var location_connections = current_loc.get_connections()
	
	if location.location_id in location_connections:
		player.move_to_location(location)
	else:
		show_notification("Impossible d'aller directement Ã  " + location.location_name, 2.0)

func _on_player_movement_completed() -> void:
	var current_loc = locations.get(player.current_location_id)
	if current_loc:
		show_notification("ArrivÃ©e Ã  " + current_loc.location_name, 2.0)
		await get_tree().create_timer(0.5).timeout
		_open_location_menu(current_loc)

func _on_location_hovered(location: WorldMapLocation) -> void:
	info_label.text = location.location_name

func _on_location_unhovered(_location: WorldMapLocation) -> void:
	info_label.text = ""

# ============================================================================
# MENU D'ACTIONS
# ============================================================================

func _open_location_menu(location: WorldMapLocation) -> void:
	selected_location = location
	
	var location_data = WorldMapDataLoader.load_location_data(location.location_id)
	if location_data.is_empty():
		show_notification("Aucune action disponible ici", 2.0)
		return
	
	for child in action_menu_container.get_children():
		child.queue_free()
	
	var actions = location_data.get("actions", [])
	
	for action in actions:
		if action.has("unlocked_at_step") and action.unlocked_at_step > current_step:
			continue
		
		var button = Button.new()
		button.text = action.get("label", "Action")
		button.custom_minimum_size = Vector2(200, 40)
		
		if action.has("icon"):
			var icon_path = action.icon
			if ResourceLoader.exists(icon_path):
				button.icon = load(icon_path)
		
		var action_data = action.duplicate()
		button.pressed.connect(func(): _on_action_selected(action_data))
		action_menu_container.add_child(button)
	
	var close_button = Button.new()
	close_button.text = "âœ• Fermer"
	close_button.custom_minimum_size = Vector2(200, 40)
	close_button.pressed.connect(_close_location_menu)
	action_menu_container.add_child(close_button)
	
	action_menu.popup_centered()

func _close_location_menu() -> void:
	action_menu.hide()
	selected_location = null

func _on_action_selected(action: Dictionary) -> void:
	_close_location_menu()
	
	match action.get("type"):
		"team_management":
			_handle_team_management_action()
		"battle":
			_handle_battle_action(action)
		"exploration":
			_handle_exploration_action(action)
		"building":
			_handle_building_action(action)
		"shop":
			_handle_shop_action(action)
		"quest_board":
			_handle_quest_board_action(action)
		"dialogue":
			_handle_dialogue_action(action)
		"custom":
			_handle_custom_action(action)
		_:
			show_notification("Type d'action non gÃ©rÃ© : " + action.get("type"), 2.0)

# ============================================================================
# GESTION DES ACTIONS
# ============================================================================

func _handle_battle_action(action: Dictionary) -> void:
	"""DÃ©lÃ¨gue au CampaignManager pour le lancement de combat"""
	var battle_id = action.get("battle_id", "")
	
	if battle_id == "":
		show_notification("ID de combat manquant", 2.0)
		return
	
	print("[WorldMap] âš”ï¸ Lancement du combat : %s" % battle_id)
	
	# DÃ©lÃ©guer Ã  CampaignManager (gÃ¨re chargement JSON, merge team, stockage)
	if GameRoot and GameRoot.campaign_manager:
		GameRoot.campaign_manager.start_battle(battle_id)
	else:
		push_error("[WorldMap] CampaignManager non disponible")

func _handle_dialogue_action(action: Dictionary) -> void:
	"""Utilise DialogueManager + UIManager (DialogueBox persistante)"""
	var dialogue_id = action.get("dialogue_id", "")
	
	if dialogue_id == "":
		show_notification("ID de dialogue manquant", 2.0)
		return
	
	print("[WorldMap] ðŸ’¬ Lancement du dialogue : %s" % dialogue_id)
	
	var dialogue_loader = DialogueDataLoader.new()
	var dialogue_data_dict = dialogue_loader.load_dialogue(dialogue_id)
	
	if dialogue_data_dict.is_empty():
		show_notification("Dialogue introuvable : " + dialogue_id, 2.0)
		return
	
	# Convertir en DialogueData
	var dialogue_data = _convert_dialogue_dict_to_data(dialogue_data_dict)
	
	# DÃ©marrer via DialogueManager (utilise la DialogueBox persistante de UIManager)
	if GameRoot and GameRoot.dialogue_manager:
		GameRoot.dialogue_manager.start_dialogue(dialogue_data)

func _handle_team_management_action() -> void:
	var roster_ui = load("res://scenes/team/team_roster_ui.tscn").instantiate()
	ui_layer.add_child(roster_ui)

func _handle_exploration_action(action: Dictionary) -> void:
	show_notification("Exploration (Ã  implÃ©menter)", 2.0)
	if action.has("event"):
		var event_data = action.event
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.emit_event(event_data.get("type"), [event_data])

func _handle_building_action(action: Dictionary) -> void:
	if action.has("scene"):
		show_notification("EntrÃ©e dans " + action.get("label"), 1.5)

func _handle_shop_action(action: Dictionary) -> void:
	var shop_id = action.get("shop_id", "")
	show_notification("Magasin : " + shop_id + " (Ã  implÃ©menter)", 2.0)

func _handle_quest_board_action(action: Dictionary) -> void:
	show_notification("Panneau de quÃªtes (Ã  implÃ©menter)", 2.0)

func _handle_custom_action(action: Dictionary) -> void:
	if action.has("event"):
		var event_data = action.event
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.emit_event(event_data.get("type"), [event_data])

# ============================================================================
# CONVERSIONS
# ============================================================================

func _convert_dialogue_dict_to_data(data_dict: Dictionary) -> DialogueData:
	var dialogue = DialogueData.new(data_dict.get("id", ""))
	
	if data_dict.has("sequences"):
		for sequence in data_dict.sequences:
			if sequence.has("lines"):
				for line in sequence.lines:
					dialogue.add_line({
						"speaker": line.get("speaker", ""),
						"text": line.get("text", ""),
						"emotion": line.get("emotion", "neutral"),
						"auto_advance": false
					})
	
	if data_dict.has("lines"):
		for line in data_dict.lines:
			dialogue.add_line(line)
	
	return dialogue

# ============================================================================
# PROGRESSION
# ============================================================================

func set_current_step(step: int) -> void:
	if step == current_step:
		return
	current_step = step
	_update_unlocked_locations()

func _update_unlocked_locations() -> void:
	for location_id in locations:
		var location = locations[location_id]
		var location_ref = _get_location_ref(location_id)
		if location_ref.is_empty():
			continue
		var unlocked = location_ref.get("unlocked_at_step", 0) <= current_step
		location.set_unlocked(unlocked)
	_refresh_connections()

func _get_location_ref(location_id: String) -> Dictionary:
	var locations_data = world_map_data.get("locations", [])
	for loc in locations_data:
		if loc.get("id") == location_id:
			return loc
	return {}

func _refresh_connections() -> void:
	for child in connections_container.get_children():
		child.queue_free()
	_create_connections()

# ============================================================================
# UI CALLBACKS
# ============================================================================

func _on_party_pressed() -> void:
	show_notification("Menu Ã‰quipe (Ã  implÃ©menter)", 2.0)

func _on_inventory_pressed() -> void:
	show_notification("Inventaire (Ã  implÃ©menter)", 2.0)

func _on_menu_pressed() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.game_paused.emit(true)

# ============================================================================
# NOTIFICATIONS
# ============================================================================

func show_notification(message: String, duration: float = 2.0) -> void:
	notification_label.text = message
	notification_panel.visible = true
	notification_panel.modulate.a = 0.0
	
	var tween = create_tween()
	tween.tween_property(notification_panel, "modulate:a", 1.0, 0.3)
	tween.tween_interval(duration)
	tween.tween_property(notification_panel, "modulate:a", 0.0, 0.3)
	tween.tween_callback(func(): notification_panel.visible = false)

func _on_notification_posted(message: String, type: String) -> void:
	var duration = 2.0
	if type == "warning":
		duration = 3.0
	elif type == "error":
		duration = 4.0
	show_notification(message, duration)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## features/world_map/logic/world_map_connection.gd

```text
# scenes/world/world_map_connection.gd
extends Node2D
class_name WorldMapConnection

## ReprÃ©sente une connexion entre deux locations avec Ã©tat (unlocked/locked/hidden)

signal state_changed(new_state: ConnectionState)

enum ConnectionState {
	UNLOCKED,   # Accessible, pointillÃ©s normaux
	LOCKED,     # Visible mais bloquÃ©, pointillÃ©s ternes + croix rouge
	HIDDEN      # Invisible, ne s'affiche pas
}

# ============================================================================
# CONFIGURATION GLOBALE (VARIABLES DE CLASSE)
# ============================================================================

# âœ… AJOUT : Variables de classe statiques pour configuration globale
static var default_line_width: float = 4.0
static var default_dash_length: float = 15.0
static var default_gap_length: float = 10.0
static var default_cross_size: float = 20.0
static var default_color_unlocked: Color = Color(0.7, 0.7, 0.7, 0.8)
static var default_color_locked: Color = Color(0.3, 0.3, 0.3, 0.4)

# ============================================================================
# CONFIGURATION D'INSTANCE
# ============================================================================

@export var line_width: float = 4.0
@export var dash_length: float = 15.0
@export var gap_length: float = 10.0
@export var cross_size: float = 20.0

# Couleurs
var color_unlocked: Color = Color(0.7, 0.7, 0.7, 0.8)
var color_locked: Color = Color(0.3, 0.3, 0.3, 0.4)

# ============================================================================
# Ã‰TAT
# ============================================================================

var connection_id: String = ""
var from_location: WorldMapLocation = null
var to_location: WorldMapLocation = null
var current_state: ConnectionState = ConnectionState.HIDDEN

# Visuels
var line_segments: Array[Line2D] = []
var cross_sprite: Polygon2D = null

# ============================================================================
# INITIALISATION
# ============================================================================

func setup(from: WorldMapLocation, to: WorldMapLocation, state: ConnectionState = ConnectionState.UNLOCKED) -> void:
	from_location = from
	to_location = to
	current_state = state
	
	connection_id = from.location_id + "_to_" + to.location_id
	
	# âœ… AJOUT : Appliquer les valeurs par dÃ©faut globales
	line_width = default_line_width
	dash_length = default_dash_length
	gap_length = default_gap_length
	cross_size = default_cross_size
	color_unlocked = default_color_unlocked
	color_locked = default_color_locked
	
	_create_visuals()

func _create_visuals() -> void:
	_clear_visuals()
	
	if current_state == ConnectionState.HIDDEN:
		visible = false
		return
	
	visible = true
	
	# CrÃ©er les segments de ligne pointillÃ©e
	_create_dashed_line()
	
	# Ajouter la croix si bloquÃ©
	if current_state == ConnectionState.LOCKED:
		_create_cross()

# ============================================================================
# LIGNE POINTILLÃ‰E
# ============================================================================

func _create_dashed_line() -> void:
	if not from_location or not to_location:
		return
	
	var start_pos = from_location.position
	var end_pos = to_location.position
	var direction = (end_pos - start_pos).normalized()
	var total_distance = start_pos.distance_to(end_pos)
	
	# Couleur selon l'Ã©tat
	var line_color = color_unlocked if current_state == ConnectionState.UNLOCKED else color_locked
	
	# Calculer le nombre de segments
	var segment_length = dash_length + gap_length
	var num_segments = int(total_distance / segment_length) + 1
	
	var current_distance = 0.0
	
	for i in range(num_segments):
		# Position de dÃ©but du segment
		var segment_start = start_pos + direction * current_distance
		
		# Position de fin du segment (sans dÃ©passer l'arrivÃ©e)
		var dash_end_distance = min(current_distance + dash_length, total_distance)
		var segment_end = start_pos + direction * dash_end_distance
		
		# CrÃ©er le segment Line2D
		var line = Line2D.new()
		line.add_point(segment_start)
		line.add_point(segment_end)
		line.width = line_width
		line.default_color = line_color
		line.antialiased = true
		
		# Style arrondi pour les extrÃ©mitÃ©s
		line.begin_cap_mode = Line2D.LINE_CAP_ROUND
		line.end_cap_mode = Line2D.LINE_CAP_ROUND
		
		add_child(line)
		line_segments.append(line)
		
		# Avancer pour le prochain segment
		current_distance += segment_length
		
		# ArrÃªter si on a atteint la fin
		if current_distance >= total_distance:
			break

# ============================================================================
# CROIX ROUGE (pour chemins bloquÃ©s)
# ============================================================================

func _create_cross() -> void:
	if not from_location or not to_location:
		return
	
	# Position au centre de la ligne
	var center = (from_location.position + to_location.position) / 2.0
	
	# CrÃ©er un Polygon2D en forme de croix
	cross_sprite = Polygon2D.new()
	cross_sprite.color = Color(0.9, 0.2, 0.2, 0.9)
	
	# DÃ©finir les points de la croix (forme de "+")
	var half_size = cross_size / 2.0
	var thickness = cross_size / 5.0
	
	var points = PackedVector2Array([
		# Barre verticale
		Vector2(-thickness, -half_size),
		Vector2(thickness, -half_size),
		Vector2(thickness, -thickness),
		Vector2(half_size, -thickness),
		# Barre horizontale droite
		Vector2(half_size, thickness),
		Vector2(thickness, thickness),
		Vector2(thickness, half_size),
		Vector2(-thickness, half_size),
		# Barre horizontale gauche
		Vector2(-thickness, thickness),
		Vector2(-half_size, thickness),
		Vector2(-half_size, -thickness),
		Vector2(-thickness, -thickness),
	])
	
	cross_sprite.polygon = points
	cross_sprite.position = center
	
	# Contour noir pour meilleure visibilitÃ©
	var outline = Line2D.new()
	outline.points = points
	outline.closed = true
	outline.width = 2.0
	outline.default_color = Color.BLACK
	cross_sprite.add_child(outline)
	
	add_child(cross_sprite)

# ============================================================================
# GESTION D'Ã‰TAT
# ============================================================================

func set_state(new_state: ConnectionState) -> void:
	if current_state == new_state:
		return
	
	current_state = new_state
	_create_visuals()
	state_changed.emit(new_state)

func is_accessible() -> bool:
	return current_state == ConnectionState.UNLOCKED

func unlock() -> void:
	set_state(ConnectionState.UNLOCKED)

func lock() -> void:
	set_state(ConnectionState.LOCKED)

func hide_connection() -> void:
	set_state(ConnectionState.HIDDEN)

func reveal() -> void:
	if current_state == ConnectionState.HIDDEN:
		set_state(ConnectionState.LOCKED)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _clear_visuals() -> void:
	# Supprimer les segments de ligne
	for segment in line_segments:
		segment.queue_free()
	line_segments.clear()
	
	# Supprimer la croix
	if cross_sprite:
		cross_sprite.queue_free()
		cross_sprite = null
```

## features/world_map/logic/world_map_data_loader.gd

```text
# scripts/core/world_map_data_loader.gd
extends Node
class_name WorldMapDataLoader

const WORLD_MAP_PATH := "res://data/maps/"

static var _map_cache: Dictionary = {}
static var _location_cache: Dictionary = {}

# ============================================================================
# CHARGEMENT DE LA CARTE PRINCIPALE
# ============================================================================

## Charge les donnÃ©es complÃ¨tes de la world map
static func load_world_map_data(map_id: String = "world_map_data", use_cache: bool = true) -> Dictionary:
	var json_path = WORLD_MAP_PATH + map_id + ".json"
	
	var json_loader = JSONDataLoader.new()
	var raw_data = json_loader.load_json_file(json_path, use_cache)
	
	if typeof(raw_data) != TYPE_DICTIONARY or raw_data.is_empty():
		push_error("[WorldMapDataLoader] âŒ Impossible de charger : ", json_path)
		return {}
	
	# Convertir les positions
	raw_data = _convert_map_positions(raw_data)
	
	return raw_data

# ============================================================================
# CHARGEMENT DES LOCATIONS
# ============================================================================

## Charge les donnÃ©es d'une location spÃ©cifique
static func load_location_data(location_id: String, use_cache: bool = true) -> Dictionary:
	var json_path = WORLD_MAP_PATH + "locations/" + location_id + ".json"
	
	var json_loader = JSONDataLoader.new()
	var raw_data = json_loader.load_json_file(json_path, use_cache)
	
	if typeof(raw_data) != TYPE_DICTIONARY or raw_data.is_empty():
		push_error("[WorldMapDataLoader] âŒ Impossible de charger location : ", json_path)
		return {}
	
	return raw_data

static func _convert_map_positions(data: Dictionary) -> Dictionary:
	var result = data.duplicate(true)
	
	if result.has("locations"):
		for location in result.locations:
			if location.has("position"):
				var pos = location.position
				location.position = Vector2i(pos.x, pos.y)
	
	return result

# ============================================================================
# QUERIES
# ============================================================================

## Retourne toutes les locations d'une carte
static func get_all_locations(map_id: String = "world_map_data") -> Array:
	var map_data = load_world_map_data(map_id)
	return map_data.get("locations", [])

## Retourne une location spÃ©cifique par ID
static func get_location_by_id(location_id: String, map_id: String = "world_map_data") -> Dictionary:
	var locations = get_all_locations(map_id)
	
	for location in locations:
		if location.get("id") == location_id:
			return location
	
	return {}

## Retourne les locations dÃ©verrouillÃ©es jusqu'Ã  un certain step
static func get_unlocked_locations(current_step: int, map_id: String = "world_map_data") -> Array:
	var all_locations = get_all_locations(map_id)
	var unlocked: Array = []
	
	for location in all_locations:
		if location.get("unlocked_at_step", 0) <= current_step:
			unlocked.append(location)
	
	return unlocked

## VÃ©rifie si une location est dÃ©verrouillÃ©e
static func is_location_unlocked(location_id: String, current_step: int, map_id: String = "world_map_data") -> bool:
	var location = get_location_by_id(location_id, map_id)
	
	if location.is_empty():
		return false
	
	return location.get("unlocked_at_step", 0) <= current_step

# ============================================================================
# NPCs
# ============================================================================

## Trouve un NPC dans une location et retourne oÃ¹ il se trouve
static func find_npc_location(npc_id: String, location_id: String) -> Dictionary:
	var location_data = load_location_data(location_id)
	var npcs = location_data.get("npcs", [])
	
	for npc in npcs:
		if npc.get("id") == npc_id:
			# Calculer oÃ¹ le NPC se trouve (probabilitÃ©)
			return _calculate_npc_position(npc)
	
	return {}

## Calcule oÃ¹ se trouve un NPC selon les probabilitÃ©s
static func _calculate_npc_position(npc: Dictionary) -> Dictionary:
	var locations = npc.get("locations", [])
	
	if locations.is_empty():
		return {}
	
	# GÃ©nÃ©rer un nombre alÃ©atoire
	var roll = randf() * 100.0
	var cumulative = 0.0
	
	for loc in locations:
		cumulative += loc.get("chance", 0)
		
		if roll <= cumulative:
			return {
				"npc": npc,
				"place_id": loc.get("place_id"),
				"place_name": loc.get("place_name")
			}
	
	# Fallback : premiÃ¨re location
	return {
		"npc": npc,
		"place_id": locations[0].get("place_id"),
		"place_name": locations[0].get("place_name")
	}

# ============================================================================
# CACHE
# ============================================================================

static func clear_cache() -> void:
	_map_cache.clear()
	_location_cache.clear()
	print("[WorldMapDataLoader] Cache vidÃ©")

static func clear_location_cache(location_id: String) -> void:
	_location_cache.erase(location_id)
```

## features/world_map/logic/world_map_location.gd

```text
# scenes/world/world_map_location.gd
extends Node2D
## WorldMapLocation - ReprÃ©sente un point d'intÃ©rÃªt sur la carte
## GÃ¨re l'affichage, l'interaction et le menu d'actions

class_name WorldMapLocation

signal clicked(location: WorldMapLocation)
signal hovered(location: WorldMapLocation)
signal unhovered(location: WorldMapLocation)

# ============================================================================
# PROPRIÃ‰TÃ‰S
# ============================================================================

var location_id: String = ""
var location_name: String = ""
var location_data: Dictionary = {}
var is_unlocked: bool = false
var is_hovered: bool = false

# Visuel
var sprite: Sprite2D
var label: Label
var area: Area2D

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	pass

func setup(data: Dictionary) -> void:
	"""Configure la location avec ses donnÃ©es"""
	
	location_data = data
	location_id = data.get("id", "")
	location_name = data.get("name", "")
	
	# Position
	if data.has("position"):
		var pos = data.position
		if typeof(pos) == TYPE_VECTOR2I:
			position = Vector2(pos.x, pos.y)
		else:
			position = Vector2(pos.get("x", 0), pos.get("y", 0))
	
	# DÃ©verrouillage
	is_unlocked = true
	
	# âœ… CrÃ©er les visuels MAINTENANT (avec les bonnes donnÃ©es)
	if not sprite:  # Seulement si pas dÃ©jÃ  crÃ©Ã©s
		_create_visuals()
	
	_update_visuals()
	
	print("[WorldMapLocation] ðŸ“ Setup terminÃ© : ", location_name, " Ã  ", position)
	
func _create_visuals() -> void:
	"""CrÃ©e les Ã©lÃ©ments visuels"""
	
	# âœ… Rectangle de debug avec Polygon2D
	var debug_rect = Polygon2D.new()
	debug_rect.polygon = PackedVector2Array([
		Vector2(-32, -32),
		Vector2(32, -32),
		Vector2(32, 32),
		Vector2(-32, 32)
	])
	debug_rect.color = Color(1, 0, 0, 0.3)  # Rouge transparent
	add_child(debug_rect)
	print("[WorldMapLocation] ðŸ”´ Rectangle debug crÃ©Ã© pour ", location_name)
	
	# Sprite principal avec texture de rond jaune
	sprite = Sprite2D.new()
	sprite.centered = true
	sprite.texture = _create_yellow_circle_texture()
	add_child(sprite)
	print("[WorldMapLocation] ðŸŸ¡ Sprite crÃ©Ã© pour ", location_name)
	
	# Label avec le nom
	label = Label.new()
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.position = Vector2(-50, 50)
	label.custom_minimum_size = Vector2(100, 0)
	label.add_theme_font_size_override("font_size", 16)
	add_child(label)
	print("[WorldMapLocation] ðŸ·ï¸ Label crÃ©Ã© pour ", location_name)
	
	# Zone de collision pour le clic
	area = Area2D.new()
	area.collision_layer = 2
	area.collision_mask = 0
	area.input_pickable = true
	
	var collision = CollisionShape2D.new()
	var shape = CircleShape2D.new()
	shape.radius = 64  # â† Plus gros pour debug
	collision.shape = shape
	area.add_child(collision)
	add_child(area)
	print("[WorldMapLocation] ðŸ“ Area2D crÃ©Ã©e pour ", location_name, " avec radius=64")
	
	# Signaux
	area.input_event.connect(_on_area_input_event)
	area.mouse_entered.connect(_on_mouse_entered)
	area.mouse_exited.connect(_on_mouse_exited)
	print("[WorldMapLocation] ðŸ”— Signaux connectÃ©s pour ", location_name)
	
# âœ… NOUVELLE FONCTION : CrÃ©er un rond jaune programmatiquement
func _create_yellow_circle_texture() -> ImageTexture:
	"""CrÃ©e une texture de cercle jaune"""
	var size = 64
	var image = Image.create(size, size, false, Image.FORMAT_RGBA8)
	image.fill(Color.TRANSPARENT)
	
	var center = size / 2
	var radius = 28
	
	# Dessiner le cercle jaune
	for y in range(size):
		for x in range(size):
			var dx = x - center
			var dy = y - center
			var dist = sqrt(dx*dx + dy*dy)
			
			if dist < radius:
				# DÃ©gradÃ© du centre vers les bords
				var alpha = 1.0 - (dist / radius) * 0.3
				image.set_pixel(x, y, Color(1.0, 0.9, 0.2, alpha))
			
			# Contour plus foncÃ©
			if dist >= radius - 3 and dist < radius:
				image.set_pixel(x, y, Color(0.8, 0.7, 0.0, 1.0))
	
	return ImageTexture.create_from_image(image)

func _update_visuals() -> void:
	"""Met Ã  jour l'apparence selon l'Ã©tat"""
	
	if not sprite or not label or not area:
		push_warning("[WorldMapLocation] Visuels non initialisÃ©s pour: ", location_name)
		return
	
	# âœ… CHANGEMENT : Utiliser un rond jaune par dÃ©faut
	var icon_path = location_data.get("icon", "")
	
	if icon_path != "" and ResourceLoader.exists(icon_path):
		sprite.texture = load(icon_path)
	else:
		# Pas d'icÃ´ne spÃ©cifiÃ©e â†’ utiliser le rond jaune
		sprite.texture = _create_yellow_circle_texture()
	
	# Scale
	var scale_value = location_data.get("scale", 1.5)  # âœ… Un peu plus grand par dÃ©faut
	sprite.scale = Vector2(scale_value, scale_value)
	
	# Couleur (si spÃ©cifiÃ©e dans les donnÃ©es)
	if location_data.has("color"):
		var c = location_data.color
		sprite.modulate = Color(c.get("r", 1), c.get("g", 1), c.get("b", 1), c.get("a", 1))
	else:
		# âœ… Jaune par dÃ©faut
		sprite.modulate = Color(1.0, 0.9, 0.2, 1.0)
	
	# Nom
	label.text = location_name
	
	# VisibilitÃ© selon dÃ©verrouillage
	visible = is_unlocked
	
	# Effet hover
	if is_hovered:
		sprite.scale *= 1.2  # âœ… Plus gros au survol
		label.add_theme_color_override("font_color", Color.YELLOW)
	else:
		label.add_theme_color_override("font_color", Color.WHITE)

func set_unlocked(unlocked: bool) -> void:
	"""DÃ©finit si la location est dÃ©verrouillÃ©e"""
	is_unlocked = unlocked
	_update_visuals()

# ============================================================================
# EVENTS
# ============================================================================

func _on_area_input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	print("[WorldMapLocation] ðŸ–±ï¸ Input event reÃ§u sur : ", location_name)
	print("  - Type event: ", event.get_class())
	print("  - is_unlocked: ", is_unlocked)
	
	if event is InputEventMouseButton:
		print("  - MouseButton: ", event.button_index, " pressed: ", event.pressed)
		
		if event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
			print("  - Clic gauche dÃ©tectÃ©!")
			if is_unlocked:
				print("  - Location dÃ©verrouillÃ©e, Ã©mission signal clicked")
				clicked.emit(self)
			else:
				print("  - âŒ Location verrouillÃ©e, pas de signal")

func _on_mouse_entered() -> void:
	if is_unlocked:
		is_hovered = true
		_update_visuals()
		hovered.emit(self)

func _on_mouse_exited() -> void:
	is_hovered = false
	_update_visuals()
	unhovered.emit(self)

# ============================================================================
# GETTERS
# ============================================================================

func get_location_id() -> String:
	return location_id

func get_location_name() -> String:
	return location_name

func get_connections() -> Array:
	return location_data.get("connections", [])
```

## features/world_map/logic/world_map_player.gd

```text
# scenes/world/world_map_player.gd
extends Node2D
## WorldMapPlayer - Sprite du joueur sur la world map avec animation bounce

class_name WorldMapPlayer

signal movement_started()
signal movement_completed()

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var bounce_speed: float = 1.5
@export var bounce_amount: float = 10.0
@export var bounce_offset: float = 75.0 
@export var scale_variation: float = 0.1  # Variation de scale pour l'effet respiration
@export var move_speed: float = 300.0

# ============================================================================
# Ã‰TAT
# ============================================================================

var sprite: Sprite2D
var is_moving: bool = false
var current_location_id: String = ""

var bounce_tween: Tween = null
var move_tween: Tween = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_create_sprite()
	_start_bounce_animation()

func _create_sprite() -> void:
	"""CrÃ©e le sprite du joueur"""
	
	sprite = Sprite2D.new()
	sprite.texture = load("res://icon.svg")
	sprite.centered = true
	add_child(sprite)

func setup(player_config: Dictionary) -> void:
	"""Configure le joueur avec les donnÃ©es Lua"""
	
	if player_config.has("icon"):
		var icon_path = player_config.icon
		if ResourceLoader.exists(icon_path):
			sprite.texture = load(icon_path)
	
	if player_config.has("scale"):
		sprite.scale = Vector2.ONE * player_config.scale
	
	bounce_speed = player_config.get("bounce_speed", 1.5)
	bounce_amount = player_config.get("bounce_amount", 10.0)
	move_speed = player_config.get("move_speed", 300.0)

# ============================================================================
# ANIMATION BOUNCE
# ============================================================================

func _start_bounce_animation() -> void:
	"""DÃ©marre l'animation de bounce continue"""
	
	if bounce_tween and bounce_tween.is_valid():
		bounce_tween.kill()
	
	bounce_tween = create_tween()
	bounce_tween.set_loops()
	bounce_tween.set_parallel(true)
	
	# âœ… CHANGEMENT : Bounce entre -bounce_amount-bounce_offset et -bounce_offset
	# (au lieu de -bounce_amount Ã  0)
	# Cela place le sprite plus haut de faÃ§on permanente
	
	var min_y = -bounce_offset  # Position basse du bounce
	var max_y = -bounce_offset - bounce_amount  # Position haute du bounce
	
	# Variation de position Y (bounce)
	bounce_tween.tween_property(
		sprite,
		"position:y",
		max_y,
		bounce_speed / 2.0
	).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
	
	bounce_tween.tween_property(
		sprite,
		"position:y",
		min_y,
		bounce_speed / 2.0
	).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE).set_delay(bounce_speed / 2.0)
	
	# Variation de scale (respiration) - inchangÃ©
	var base_scale = sprite.scale
	var scale_min = base_scale * (1.0 - scale_variation)
	var scale_max = base_scale * (1.0 + scale_variation)
	
	bounce_tween.tween_property(
		sprite,
		"scale",
		scale_max,
		bounce_speed / 2.0
	).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
	
	bounce_tween.tween_property(
		sprite,
		"scale",
		scale_min,
		bounce_speed / 2.0
	).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE).set_delay(bounce_speed / 2.0)

# ============================================================================
# MOUVEMENT
# ============================================================================

func move_to_location(target_location: WorldMapLocation) -> void:
	"""DÃ©place le joueur vers une location"""
	
	if is_moving:
		return
	
	is_moving = true
	movement_started.emit()
	
	var target_pos = target_location.position
	var distance = position.distance_to(target_pos)
	var duration = distance / move_speed
	
	if move_tween and move_tween.is_valid():
		move_tween.kill()
	
	move_tween = create_tween()
	move_tween.tween_property(self, "position", target_pos, duration).set_ease(Tween.EASE_IN_OUT)
	await move_tween.finished
	
	current_location_id = target_location.location_id
	is_moving = false
	movement_completed.emit()

func set_location(location: WorldMapLocation) -> void:
	"""Place directement le joueur Ã  une location (sans animation)"""
	
	position = location.position
	current_location_id = location.location_id
```

## features/world_map/visuals/world_map.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://cnb8xh4y5qw7m"]

[ext_resource type="Script" uid="uid://h5mdwo6mlbe" path="res://features/world_map/logic/world_map.gd" id="1_world_map"]

[node name="WorldMap" type="Node2D"]
script = ExtResource("1_world_map")

[node name="Background" type="ColorRect" parent="."]
offset_right = 1920.0
offset_bottom = 1080.0
mouse_filter = 2
color = Color(0.15, 0.2, 0.15, 1)

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(960, 540)
zoom = Vector2(0.8, 0.8)

[node name="ConnectionsContainer" type="Node2D" parent="."]

[node name="LocationsContainer" type="Node2D" parent="."]

[node name="PlayerContainer" type="Node2D" parent="."]

[node name="UI" type="CanvasLayer" parent="."]

[node name="TopBar" type="PanelContainer" parent="UI"]
offset_right = 1920.0
offset_bottom = 80.0

[node name="TopBarBg" type="ColorRect" parent="UI/TopBar"]
layout_mode = 2
color = Color(0.1, 0.1, 0.12, 0.9)

[node name="MarginContainer" type="MarginContainer" parent="UI/TopBar"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 10

[node name="HBoxContainer" type="HBoxContainer" parent="UI/TopBar/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 40

[node name="TitleLabel" type="Label" parent="UI/TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0.9, 0.85, 0.7, 1)
theme_override_font_sizes/font_size = 32
text = "CARTE DU MONDE"

[node name="DivinityPanel" type="HBoxContainer" parent="UI/TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 30

[node name="AstraeonLabel" type="Label" parent="UI/TopBar/MarginContainer/HBoxContainer/DivinityPanel"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 0.8, 1, 1)
theme_override_font_sizes/font_size = 20
text = "âš– Astraeon: 0"

[node name="KharvulLabel" type="Label" parent="UI/TopBar/MarginContainer/HBoxContainer/DivinityPanel"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.5, 0.5, 1)
theme_override_font_sizes/font_size = 20
text = "âš¡ KharvÃ»l: 0"

[node name="BottomBar" type="PanelContainer" parent="UI"]
anchors_preset = 2
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = -120.0
offset_right = 1920.0
grow_vertical = 0

[node name="BottomBarBg" type="ColorRect" parent="UI/BottomBar"]
layout_mode = 2
color = Color(0.1, 0.1, 0.12, 0.9)

[node name="MarginContainer" type="MarginContainer" parent="UI/BottomBar"]
layout_mode = 2
theme_override_constants/margin_left = 30
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 30
theme_override_constants/margin_bottom = 15

[node name="HBoxContainer" type="HBoxContainer" parent="UI/BottomBar/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="InfoLabel" type="Label" parent="UI/BottomBar/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
theme_override_font_sizes/font_size = 22
text = "SÃ©lectionnez une destination pour voyager"
vertical_alignment = 1

[node name="ButtonsContainer" type="HBoxContainer" parent="UI/BottomBar/MarginContainer/HBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="PartyButton" type="Button" parent="UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ðŸ‘¥ Ã‰quipe"

[node name="InventoryButton" type="Button" parent="UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ðŸŽ’ Inventaire"

[node name="MenuButton" type="Button" parent="UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ðŸ“‹ Menu"

[node name="NotificationPanel" type="PanelContainer" parent="UI"]
visible = false
anchors_preset = 5
anchor_left = 0.5
anchor_right = 0.5
offset_left = -250.0
offset_top = 100.0
offset_right = 250.0
offset_bottom = 180.0
grow_horizontal = 2

[node name="NotificationBg" type="ColorRect" parent="UI/NotificationPanel"]
layout_mode = 2
color = Color(0.15, 0.15, 0.2, 0.95)

[node name="MarginContainer" type="MarginContainer" parent="UI/NotificationPanel"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 15

[node name="NotificationLabel" type="Label" parent="UI/NotificationPanel/MarginContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 24
text = "Notification"
horizontal_alignment = 1
vertical_alignment = 1
autowrap_mode = 3

[node name="DebugInfo" type="Label" parent="UI"]
visible = false
offset_left = 10.0
offset_top = 90.0
offset_right = 300.0
offset_bottom = 200.0
theme_override_colors/font_color = Color(0, 1, 0, 1)
theme_override_font_sizes/font_size = 16
text = "[DEBUG]
Camera Pos: (0, 0)
Zoom: 1.0"
```

## Statistics

- Total Files: 33
- Total Characters: 198942
- Total Tokens: 0

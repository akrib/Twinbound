This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-02-06 02:24:41

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
core
  autoloads
    battle_data_manager.gd
    campaign_manager.gd
    debug_overlay.gd
    dialogue_manager.gd
    event_bus.gd
    game_manager.gd
    game_root.gd
    global_logger.gd
    scene_loader.gd
    team_manager.gd
    ui_manager.gd
    version_manager.gd
  data
    ability_data_loader.gd
    json_data_loader.gd
    model_validator.gd
    scene_registry.gd
    validation_result.gd
  dialogue
    bark_system.gd
    dialogue_box.gd
    dialogue_box.tscn
    dialogue_data.gd
    dialogue_data_loader.gd
  game_root.tscn
features
  combat
    logic
      action_module_3d.gd
      ai_module_3d.gd
      battle_commands.gd
      battle_map_manager_3d.gd
      enemy_data_loader.gd
      item_module.gd
      last_man_stand_module.gd
      movement_module_3d.gd
      objective_module.gd
      rest_module.gd
      unit_manager_3d.gd
    visuals
      battle_3d.tscn
      battle_unit_3d.gd
      damage_number.gd
      damage_number.tscn
      terrain_module_3d.gd
  debug
    debug_version_panel.gd
  Duo
    duo_system.gd
    ring_system.gd
    ui
      battle_results.gd
      battle_results.tscn
      character_mini_card.gd
      character_mini_card.tscn
      duo_attack_option.gd
      duo_attack_option.tscn
  menu
    main_menu.gd
    main_menu.tscn
  roster
    team_roster_ui.gd
    team_roster_ui.tscn
  world_map
    logic
      world_map.gd
      world_map_connection.gd
      world_map_data_loader.gd
      world_map_location.gd
      world_map_player.gd
    visuals
      world_map.tscn
shared
  barks
    bark_label.gd
    bark_label.tscn
  battle_state_machine.gd
  battle_stats_tracker.gd
  command.gd
  item_data_loader.gd
  json_scenario_module.gd
  state_machine.gd
  visuals
    effects
      text
        rainbow_effect.gd
        shake_effect.gd
        wave_effect.gd
```

# Repository Files


## core/autoloads/battle_data_manager.gd

```text
# scripts/core/battle_data_manager.gd
extends Node
## BattleDataManager - Gestionnaire centralis√© des donn√©es de combat
## Autoload d√©di√© au stockage et √† la validation des donn√©es de bataille
## 
## Responsabilit√©s :
## - Stocker les donn√©es du combat actuel
## - Valider la structure des donn√©es
## - Fournir un acc√®s thread-safe
## - Nettoyer apr√®s usage
##
## Acc√®s via : GameRoot.battle_data_manager

class_name BattleDataManagerClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal battle_data_stored(battle_id: String)
signal battle_data_cleared()
signal battle_data_invalid(errors: Array)

# ============================================================================
# DONN√âES
# ============================================================================

var _current_battle_data: Dictionary = {}
var _is_data_valid: bool = false
var _battle_id: String = ""

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# Attendre que GameRoot soit pr√™t
	call_deferred("_connect_signals")
	print("[BattleDataManager] ‚úÖ Initialis√©")

func _connect_signals() -> void:
	"""Connexion aux signaux de GameRoot"""
	await get_tree().process_frame
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("battle_ended", _on_battle_ended)

# ============================================================================
# STOCKAGE
# ============================================================================

## Stocke les donn√©es d'un combat
func set_battle_data(data: Dictionary) -> bool:
	"""
	Stocke les donn√©es de combat apr√®s validation
	
	@param data : Dictionnaire contenant les donn√©es de combat
	@return true si stockage r√©ussi, false si donn√©es invalides
	"""
	
	var result = ModelValidator.validate(data, "battle")

	if not result.is_valid:
		if GameRoot and GameRoot.global_logger:
			GameRoot.global_logger.error("BATTLE_DATA", "Validation √©chou√©e : " + str(result.errors))
		push_error("[BattleDataManager] ‚ùå Donn√©es invalides : ", result.errors)
		battle_data_invalid.emit(result.errors)
		return false

	# üî• IMPORTANT : r√©cup√©rer les donn√©es normalis√©es
	_current_battle_data = result.data.duplicate(true)
	_is_data_valid = true
	_battle_id = data.get("battle_id", "unknown_" + str(Time.get_unix_time_from_system()))
	
	print("[BattleDataManager] ‚úÖ Donn√©es stock√©es : ", _battle_id)
	battle_data_stored.emit(_battle_id)
	
	return true

## R√©cup√®re les donn√©es du combat actuel
func get_battle_data() -> Dictionary:
	"""
	Retourne les donn√©es du combat actuel
	
	@return Dictionary avec les donn√©es, ou {} si aucune donn√©e valide
	"""
	
	if not _is_data_valid:
		push_warning("[BattleDataManager] ‚ö†Ô∏è Aucune donn√©e de combat valide")
		return {}
	
	print("[BattleDataManager] üì¶ R√©cup√©ration des donn√©es : ", _battle_id)
	return _current_battle_data.duplicate(true)

## V√©rifie si des donn√©es sont disponibles
func has_battle_data() -> bool:
	"""V√©rifie si des donn√©es de combat valides sont stock√©es"""
	return _is_data_valid and not _current_battle_data.is_empty()

## R√©cup√®re l'ID du combat actuel
func get_battle_id() -> String:
	"""Retourne l'ID du combat actuel"""
	return _battle_id

# ============================================================================
# NETTOYAGE
# ============================================================================

## Efface les donn√©es du combat actuel
func clear_battle_data() -> void:
	"""
	Nettoie les donn√©es de combat
	Appel√© automatiquement apr√®s la bataille
	"""
	
	if _is_data_valid:
		print("[BattleDataManager] üßπ Nettoyage des donn√©es : ", _battle_id)
	
	_current_battle_data.clear()
	_is_data_valid = false
	_battle_id = ""
	
	battle_data_cleared.emit()

## Efface les donn√©es de mani√®re forc√©e (emergency)
func force_clear() -> void:
	"""Nettoyage forc√© en cas d'erreur critique"""
	push_warning("[BattleDataManager] ‚ö†Ô∏è Nettoyage forc√© des donn√©es")
	clear_battle_data()


# ============================================================================
# DEBUG
# ============================================================================

## Affiche les donn√©es actuelles (debug)
func debug_print_data() -> void:
	"""Affiche les donn√©es de combat pour debug"""
	
	if not _is_data_valid:
		print("[BattleDataManager] üêõ Aucune donn√©e √† afficher")
		return
	
	print("\n=== BattleDataManager DEBUG ===")
	print("Battle ID : ", _battle_id)
	print("Player Units : ", _current_battle_data.get("player_units", []).size())
	print("Enemy Units : ", _current_battle_data.get("enemy_units", []).size())
	print("Terrain : ", _current_battle_data.get("terrain", "N/A"))
	print("================================\n")

## Retourne les statistiques du combat actuel
func get_battle_stats() -> Dictionary:
	"""Retourne des statistiques sur le combat actuel"""
	
	if not _is_data_valid:
		return {}
	
	return {
		"battle_id": _battle_id,
		"player_unit_count": _current_battle_data.get("player_units", []).size(),
		"enemy_unit_count": _current_battle_data.get("enemy_units", []).size(),
		"has_objectives": _current_battle_data.has("objectives"),
		"has_scenario": _current_battle_data.has("scenario"),
		"terrain_type": _current_battle_data.get("terrain", "unknown")
	}

# ============================================================================
# CALLBACKS
# ============================================================================

func _on_battle_ended(_results: Dictionary) -> void:
	"""Nettoyage automatique apr√®s la fin du combat"""
	clear_battle_data()

func _exit_tree() -> void:
	"""Nettoyage √† la fermeture"""
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
	
func _normalize_battle_data(data: Dictionary) -> void:
	# Player units
	if data.has("player_units"):
		for unit in data.player_units:
			# HP ‚Üí int
			unit.current_hp = int(unit.current_hp)
			unit.max_hp = int(unit.max_hp)

			# Position [x, y] ‚Üí Vector2i
			if unit.has("position") and unit.position is Array and unit.position.size() == 2:
				unit.position = Vector2i(
					int(unit.position[0]),
					int(unit.position[1])
				)

	# Enemy units
	if data.has("enemy_units"):
		for unit in data.enemy_units:
			unit.current_hp = int(unit.current_hp)
			unit.max_hp = int(unit.max_hp)

			if unit.has("position") and unit.position is Array and unit.position.size() == 2:
				unit.position = Vector2i(
					int(unit.position[0]),
					int(unit.position[1])
				)

	# Obstacles
	if data.has("terrain_obstacles"):
		for obs in data.terrain_obstacles:
			if obs.has("position") and obs.position is Array and obs.position.size() == 2:
				obs.position = Vector2i(
					int(obs.position[0]),
					int(obs.position[1])
				)
```

## core/autoloads/campaign_manager.gd

```text
extends Node
## CampaignManager - Gestion de la campagne et s√©quences narratives
## Autoload qui orchestre la progression, les combats et les s√©quences d'intro
##
## Absorbe la logique de IntroDialogue (s√©quences de d√©marrage)
## Les dialogues sont d√©l√©gu√©s √† DialogueManager
## L'UI (DialogueBox) est g√©r√©e par UIManager (persistante)
##
## Acc√®s via : GameRoot.campaign_manager

class_name CampaignManagerClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal campaign_sequence_started(sequence_id: String)
signal campaign_sequence_ended(sequence_id: String)
signal battle_requested(battle_id: String)

# ============================================================================
# CONFIGURATION
# ============================================================================
const DialogueData = preload("res://core/dialogue/dialogue_data.gd")
const BATTLE_DATA_PATHS: Dictionary = {
	"tutorial": "res://data/battles/tutorial.json",
	"forest_battle": "res://data/battles/forest_battle.json",
	"village_defense": "res://data/battles/village_defense.json",
	"boss_fight": "res://data/battles/boss_fight.json"
}

const CAMPAIGN_START_PATH: String = "res://data/campaign/campaign_start.json"

# ============================================================================
# √âTAT
# ============================================================================

var campaign_state: Dictionary = {
	"current_chapter": 1,
	"current_battle": 1,
	"battles_won": 0
}

var campaign_start_data: Dictionary = {}
var current_sequence_index: int = 0
var is_sequence_running: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	print("[CampaignManager] ‚úÖ Initialis√© (mode JSON)")

# ============================================================================
# CALLBACKS EVENTBUS (connect√©s par GameRoot)
# ============================================================================

func _on_game_started() -> void:
	"""Appel√© quand le joueur lance 'Nouvelle Partie'"""
	print("[CampaignManager] üéÆ Nouvelle partie - d√©marrage campagne")
	start_new_campaign()

func _on_battle_ended(results: Dictionary) -> void:
	"""Appel√© √† la fin d'un combat"""
	print("[CampaignManager] Combat termin√©")
	
	if results.get("victory", false):
		campaign_state.battles_won += 1
		_advance_campaign()

# ============================================================================
# D√âMARRAGE DE CAMPAGNE
# ============================================================================

func start_new_campaign() -> void:
	"""D√©marre une nouvelle campagne avec la s√©quence d'intro"""
	print("[CampaignManager] üé¨ D√©marrage nouvelle campagne")
	
	# Charger les donn√©es de campagne
	campaign_start_data = _load_campaign_start_from_json()
	
	if campaign_start_data.is_empty():
		push_warning("[CampaignManager] Pas de campaign_start.json, fallback direct")
		_fallback_to_world_map()
		return
	
	# Initialiser l'√©tat de la campagne
	if campaign_start_data.has("initial_state"):
		var initial_state = campaign_start_data.initial_state
		campaign_state.current_chapter = initial_state.get("chapter", 1)
		campaign_state.current_battle = initial_state.get("battle_index", 0)
		campaign_state.battles_won = initial_state.get("battles_won", 0)
	
	# √âmettre l'√©v√©nement
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.campaign_started.emit()
	
	# Ex√©cuter la s√©quence de d√©marrage
	if campaign_start_data.has("start_sequence"):
		await _execute_start_sequence()
	else:
		push_warning("[CampaignManager] Pas de start_sequence, fallback")
		_fallback_to_world_map()

# ============================================================================
# EX√âCUTION DE S√âQUENCES (ex-IntroDialogue)
# ============================================================================

func _execute_start_sequence() -> void:
	"""Ex√©cute la s√©quence de d√©marrage d√©finie dans le JSON"""
	
	var sequence = campaign_start_data.start_sequence
	current_sequence_index = 0
	is_sequence_running = true
	
	campaign_sequence_started.emit("campaign_start")
	print("[CampaignManager] üé¨ D√©but de la s√©quence (", sequence.size(), " √©tapes)")
	
	await _execute_next_step()
	
	is_sequence_running = false
	campaign_sequence_ended.emit("campaign_start")

func _execute_next_step() -> void:
	"""Ex√©cute l'√©tape suivante de la s√©quence"""
	
	var sequence = campaign_start_data.start_sequence
	
	if current_sequence_index >= sequence.size():
		print("[CampaignManager] ‚úÖ S√©quence termin√©e")
		return
	
	var step = sequence[current_sequence_index]
	var step_type = step.get("type", "")
	
	print("[CampaignManager] üìã √âtape %d/%d : %s" % [
		current_sequence_index + 1, sequence.size(), step_type
	])
	
	match step_type:
		"dialogue":
			await _execute_dialogue_step(step)
		"transition":
			await _execute_transition_step(step)
		"notification":
			_execute_notification_step(step)
		"unlock_location":
			_execute_unlock_location_step(step)
		_:
			push_warning("[CampaignManager] Type d'√©tape inconnu : %s" % step_type)
	
	current_sequence_index += 1
	await _execute_next_step()

func _execute_dialogue_step(step: Dictionary) -> void:
	"""Ex√©cute une √©tape de dialogue via DialogueManager + UIManager"""
	
	var dialogue_id = step.get("dialogue_id", "")
	var blocking = step.get("blocking", true)
	
	if dialogue_id == "":
		push_warning("[CampaignManager] dialogue_id vide")
		return
	
	print("[CampaignManager] üí¨ Dialogue : %s" % dialogue_id)
	
	# Charger les donn√©es du dialogue
	var dialogue_loader = DialogueDataLoader.new()
	var dialogue_data_dict = dialogue_loader.load_dialogue(dialogue_id)
	
	if dialogue_data_dict.is_empty():
		push_error("[CampaignManager] Dialogue introuvable : %s" % dialogue_id)
		return
	
	# Convertir en DialogueData
	var dialogue_data = _convert_to_dialogue_data(dialogue_data_dict)
	
	# D√©marrer via DialogueManager (utilise la DialogueBox persistante de UIManager)
	if GameRoot and GameRoot.dialogue_manager:
		GameRoot.dialogue_manager.start_dialogue(dialogue_data)
		
		# Attendre la fin si bloquant
		if blocking:
			await GameRoot.dialogue_manager.dialogue_ended
			print("[CampaignManager] ‚úÖ Dialogue termin√©")

func _execute_transition_step(step: Dictionary) -> void:
	"""Ex√©cute une transition vers une autre sc√®ne"""
	
	var target = step.get("target", "")
	var fade_duration = step.get("fade_duration", 1.0)
	
	print("[CampaignManager] üéûÔ∏è Transition vers : %s" % target)
	
	var scene_map = {
		"world_map": SceneRegistry.SceneID.WORLD_MAP,
		"battle": SceneRegistry.SceneID.BATTLE,
		"main_menu": SceneRegistry.SceneID.MAIN_MENU
	}
	
	if not scene_map.has(target):
		push_error("[CampaignManager] Cible de transition inconnue : %s" % target)
		return
	
	# Changer de sc√®ne via SceneLoader (g√®re fade automatiquement)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.change_scene(scene_map[target])

func _execute_notification_step(step: Dictionary) -> void:
	"""Affiche une notification"""
	var message = step.get("message", "")
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify(message, "info")

func _execute_unlock_location_step(step: Dictionary) -> void:
	"""D√©verrouille une location sur la world map"""
	var location = step.get("location", "")
	print("[CampaignManager] üîì D√©verrouillage : %s" % location)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.location_discovered.emit(location)

# ============================================================================
# LANCEMENT DE COMBAT
# ============================================================================

func start_battle(battle_id: String) -> void:
	"""Charge et lance un combat depuis son ID"""
	print("[CampaignManager] üéØ Chargement du combat : %s" % battle_id)
	
	var battle_data = load_battle_data_from_json(battle_id)
	
	if battle_data.is_empty():
		push_error("[CampaignManager] Impossible de charger : %s" % battle_id)
		return
	
	# Merger avec la team du joueur
	battle_data = _merge_player_team(battle_data)
	
	# Ajouter un ID unique
	battle_data["battle_id"] = battle_id + "_" + str(Time.get_unix_time_from_system())
	
	# Stocker dans BattleDataManager
	if not GameRoot or not GameRoot.battle_data_manager:
		push_error("[CampaignManager] BattleDataManager non disponible")
		return
	
	var stored = GameRoot.battle_data_manager.set_battle_data(battle_data)
	
	if stored:
		print("[CampaignManager] ‚úÖ Donn√©es de combat stock√©es")
		GameRoot.event_bus.change_scene(SceneRegistry.SceneID.BATTLE)
	else:
		push_error("[CampaignManager] ‚ùå √âchec du stockage des donn√©es")

func load_battle_data_from_json(battle_id: String) -> Dictionary:
	"""Charge un fichier JSON de donn√©es de combat"""
	
	# Essayer le chemin depuis BATTLE_DATA_PATHS
	var json_path = BATTLE_DATA_PATHS.get(battle_id, "")
	
	# Sinon essayer le chemin g√©n√©rique
	if json_path == "":
		json_path = "res://data/battles/%s.json" % battle_id
	
	if not FileAccess.file_exists(json_path):
		push_error("[CampaignManager] Fichier de combat introuvable : %s" % json_path)
		return {}
	
	var json_loader = JSONDataLoader.new()
	var battle_data = json_loader.load_json_file(json_path)
	
	if typeof(battle_data) != TYPE_DICTIONARY or battle_data.is_empty():
		push_error("[CampaignManager] Donn√©es invalides : %s" % battle_id)
		return {}
	
	# Convertir les positions JSON
	battle_data = _convert_json_positions(battle_data)
	
	print("[CampaignManager] ‚úÖ Battle data charg√©e : %s" % battle_id)
	return battle_data

# ============================================================================
# MERGE TEAM JOUEUR
# ============================================================================

func _merge_player_team(battle_data: Dictionary) -> Dictionary:
	"""Fusionne l'√©quipe du joueur avec les alli√©s du sc√©nario"""
	
	var result = battle_data.duplicate(true)
	
	if not GameRoot or not GameRoot.team_manager:
		return result
	
	var team = GameRoot.team_manager.get_current_team()
	var team_units: Array = []
	
	for i in range(team.size()):
		var unit = team[i]
		var battle_unit = _convert_team_unit_to_battle(unit, i)
		team_units.append(battle_unit)
	
	# D√©caler les alli√©s du sc√©nario
	if result.has("player_units"):
		for ally in result.player_units:
			if ally.has("position"):
				ally.position.x += 2
	else:
		result["player_units"] = []
	
	# Ajouter la team au d√©but
	for unit in team_units:
		result.player_units.insert(0, unit)
	
	print("[CampaignManager] ‚úÖ Team merg√©e : %d + %d alli√©s" % [
		team_units.size(), result.player_units.size() - team_units.size()
	])
	
	return result

func _convert_team_unit_to_battle(unit: Dictionary, index: int) -> Dictionary:
	return {
		"id": unit.get("instance_id", unit.get("id")),
		"name": unit.get("name"),
		"position": Vector2i(2, 6 + index),
		"stats": unit.get("stats", {}).duplicate(),
		"abilities": unit.get("abilities", []).duplicate(),
		"color": unit.get("color", {"r": 0.5, "g": 0.5, "b": 0.8, "a": 1.0}),
		"level": unit.get("level", 1),
		"xp": unit.get("xp", 0),
		"current_hp": unit.get("current_hp", unit.get("stats", {}).get("hp", 100))
	}

# ============================================================================
# CONVERSIONS JSON
# ============================================================================

func _convert_json_positions(data: Dictionary) -> Dictionary:
	var result = data.duplicate(true)
	
	for key in ["player_units", "enemy_units"]:
		if result.has(key):
			for unit in result[key]:
				if unit.has("position"):
					var pos = unit.position
					if pos is Array and pos.size() == 2:
						unit.position = Vector2i(int(pos[0]), int(pos[1]))
					elif pos is Dictionary:
						unit.position = Vector2i(pos.get("x", 0), pos.get("y", 0))
	
	if result.has("terrain_obstacles"):
		for obs in result.terrain_obstacles:
			if obs.has("position"):
				var pos = obs.position
				if pos is Array and pos.size() == 2:
					obs.position = Vector2i(int(pos[0]), int(pos[1]))
				elif pos is Dictionary:
					obs.position = Vector2i(pos.get("x", 0), pos.get("y", 0))
	
	if result.has("grid_size") and result["grid_size"] is Dictionary:
		var grid = result["grid_size"]
		if grid.has("width") and grid.has("height"):
			result["grid_size"] = Vector2i(int(grid["width"]), int(grid["height"]))
	
	return result

func _convert_to_dialogue_data(data_dict: Dictionary) -> DialogueData:
	"""Convertit un dictionnaire JSON en DialogueData"""
	
	var dialogue = DialogueData.new(data_dict.get("id", ""))
	
	# Traiter les s√©quences
	if data_dict.has("sequences"):
		for sequence in data_dict.sequences:
			if sequence.has("lines"):
				for line in sequence.lines:
					dialogue.add_line({
						"speaker": line.get("speaker", ""),
						"text": line.get("text", ""),
						"emotion": line.get("emotion", "neutral"),
						"auto_advance": false
					})
	
	# Traiter les lignes directes
	if data_dict.has("lines"):
		for line in data_dict.lines:
			dialogue.add_line(line)
	
	return dialogue

# ============================================================================
# CHARGEMENT JSON
# ============================================================================

func _load_campaign_start_from_json() -> Dictionary:
	if not FileAccess.file_exists(CAMPAIGN_START_PATH):
		push_warning("[CampaignManager] Fichier introuvable : %s" % CAMPAIGN_START_PATH)
		return {}
	
	var json_loader = JSONDataLoader.new()
	var data = json_loader.load_json_file(CAMPAIGN_START_PATH)
	
	if typeof(data) != TYPE_DICTIONARY or data.is_empty():
		push_error("[CampaignManager] Format invalide pour campaign_start.json")
		return {}
	
	return data

# ============================================================================
# PROGRESSION
# ============================================================================

func _advance_campaign() -> void:
	campaign_state.current_battle += 1
	# TODO: Logique de progression (chapitres, etc.)

func get_campaign_state() -> Dictionary:
	return campaign_state.duplicate()

# ============================================================================
# FALLBACK
# ============================================================================

func _fallback_to_world_map() -> void:
	"""En cas d'erreur, aller directement √† la world map"""
	print("[CampaignManager] ‚ö†Ô∏è Fallback vers World Map")
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Bienvenue dans le jeu !", "info")
	
	await get_tree().create_timer(1.0).timeout
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.change_scene(SceneRegistry.SceneID.WORLD_MAP)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## core/autoloads/debug_overlay.gd

```text
extends CanvasLayer
## DebugOverlay - Interface de debug en jeu (F3)
## Affiche les informations de debug, FPS, √©tat du jeu
##
## Acc√®s via : GameRoot.debug_overlay

class_name DebugOverlayClass

# ============================================================================
# CONFIGURATION
# ============================================================================

const PANEL_WIDTH: int = 450
const PANEL_MIN_HEIGHT: int = 400

# ============================================================================
# R√âF√âRENCES UI
# ============================================================================

var panel: PanelContainer = null
var info_label: RichTextLabel = null
var log_label: RichTextLabel = null

# ============================================================================
# √âTAT
# ============================================================================

var is_visible: bool = false
var watched_variables: Dictionary = {}  # key -> { object: Node, property: String }
var show_logs: bool = true

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	layer = 110  # Au-dessus de tout
	name = "DebugOverlay"
	
	_create_ui()
	visible = false
	
	print("[DebugOverlay] ‚úÖ Initialis√© (F3 pour afficher)")

func _create_ui() -> void:
	"""Cr√©e l'interface de debug"""
	
	# Panel principal
	panel = PanelContainer.new()
	panel.name = "DebugPanel"
	panel.position = Vector2(10, 10)
	panel.custom_minimum_size = Vector2(PANEL_WIDTH, PANEL_MIN_HEIGHT)
	
	# Style du panel
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.05, 0.05, 0.1, 0.9)
	style.border_width_left = 2
	style.border_width_top = 2
	style.border_width_right = 2
	style.border_width_bottom = 2
	style.border_color = Color(0.3, 0.3, 0.5)
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	panel.add_theme_stylebox_override("panel", style)
	
	add_child(panel)
	
	# Margin
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 15)
	margin.add_theme_constant_override("margin_top", 15)
	margin.add_theme_constant_override("margin_right", 15)
	margin.add_theme_constant_override("margin_bottom", 15)
	panel.add_child(margin)
	
	# VBox pour organiser
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 10)
	margin.add_child(vbox)
	
	# Label d'info principal
	info_label = RichTextLabel.new()
	info_label.bbcode_enabled = true
	info_label.fit_content = true
	info_label.scroll_active = false
	info_label.custom_minimum_size = Vector2(0, 200)
	vbox.add_child(info_label)
	
	# S√©parateur
	var separator = HSeparator.new()
	vbox.add_child(separator)
	
	# Label des logs r√©cents
	var log_title = Label.new()
	log_title.text = "üìú Logs r√©cents"
	log_title.add_theme_color_override("font_color", Color(0.7, 0.7, 0.9))
	vbox.add_child(log_title)
	
	var scroll = ScrollContainer.new()
	scroll.custom_minimum_size = Vector2(0, 150)
	scroll.size_flags_vertical = Control.SIZE_EXPAND_FILL
	vbox.add_child(scroll)
	
	log_label = RichTextLabel.new()
	log_label.bbcode_enabled = true
	log_label.fit_content = true
	log_label.scroll_active = false
	scroll.add_child(log_label)

# ============================================================================
# VISIBILIT√â
# ============================================================================

func toggle_visibility() -> void:
	"""Inverse la visibilit√© de l'overlay"""
	is_visible = not is_visible
	visible = is_visible

func show_overlay() -> void:
	"""Affiche l'overlay"""
	is_visible = true
	visible = true

func hide_overlay() -> void:
	"""Cache l'overlay"""
	is_visible = false
	visible = false

# ============================================================================
# MISE √Ä JOUR
# ============================================================================

func _process(_delta: float) -> void:
	if not is_visible:
		return
	
	_update_display()

func _update_display() -> void:
	"""Met √† jour l'affichage"""
	
	var text = "[b][color=cyan]‚ïê‚ïê‚ïê DEBUG OVERLAY ‚ïê‚ïê‚ïê[/color][/b]\n\n"
	
	# Performance
	text += "[b][color=yellow]Performance[/color][/b]\n"
	text += "  FPS: [color=lime]%d[/color]\n" % Engine.get_frames_per_second()
	
	var mem_static = OS.get_static_memory_usage() / 1024.0 / 1024.0
	text += "  M√©moire: [color=lime]%.2f MB[/color]\n\n" % mem_static
	
	# GameRoot Status (via autoload)
	if GameRoot:
		text += "[b][color=yellow]GameRoot[/color][/b]\n"
		text += "  EventBus: %s\n" % _status_icon(GameRoot.event_bus != null)
		text += "  SceneLoader: %s\n" % _status_icon(GameRoot.scene_loader != null)
		text += "  GameManager: %s\n" % _status_icon(GameRoot.game_manager != null)
		text += "  UIManager: %s\n" % _status_icon(GameRoot.ui_manager != null)
		text += "  GlobalLogger: %s\n\n" % _status_icon(GameRoot.global_logger != null)
		
		# Sc√®ne actuelle
		if GameRoot.scene_loader:
			var scene_name = GameRoot.scene_loader.get_current_scene_name()
			var is_loading = GameRoot.scene_loader.is_loading
			text += "[b][color=yellow]Sc√®ne[/color][/b]\n"
			text += "  Actuelle: [color=white]%s[/color]\n" % scene_name
			text += "  Loading: %s\n\n" % _status_icon(is_loading, "üîÑ", "‚úÖ")
		
		# √âtat du jeu
		if GameRoot.game_manager:
			text += "[b][color=yellow]√âtat[/color][/b]\n"
			text += "  Pause: %s\n\n" % _status_icon(GameRoot.game_manager.is_paused, "‚è∏Ô∏è", "‚ñ∂Ô∏è")
	
	# Variables surveill√©es
	if not watched_variables.is_empty():
		text += "[b][color=yellow]Variables[/color][/b]\n"
		
		for key in watched_variables:
			var entry = watched_variables[key]
			var obj = entry.object
			var prop = entry.property
			
			if is_instance_valid(obj):
				var value = obj.get(prop)
				if value != null:
					text += "  [color=cyan]%s:[/color] %s\n" % [key, _format_value(value)]
		
		text += "\n"
	
	info_label.text = text
	
	# Logs r√©cents
	if show_logs and GameRoot and GameRoot.global_logger:
		var log_text = ""
		var recent_logs = GameRoot.global_logger.get_recent_logs(10)
		
		for entry in recent_logs:
			var color = "white"
			match entry.level:
				GlobalLoggerClass.LogLevel.DEBUG:
					color = "gray"
				GlobalLoggerClass.LogLevel.WARNING:
					color = "yellow"
				GlobalLoggerClass.LogLevel.ERROR:
					color = "red"
			
			log_text += "[color=%s][%s] %s[/color]\n" % [color, entry.category, entry.message]
		
		log_label.text = log_text

func _status_icon(condition: bool, true_icon: String = "‚úÖ", false_icon: String = "‚ùå") -> String:
	return true_icon if condition else false_icon

func _format_value(value: Variant) -> String:
	"""Formate une valeur pour l'affichage"""
	
	if value is Array:
		return "Array[%d]" % value.size()
	elif value is Dictionary:
		return "Dict[%d]" % value.size()
	elif value is Vector2 or value is Vector2i:
		return "(%s, %s)" % [value.x, value.y]
	elif value is Vector3:
		return "(%.1f, %.1f, %.1f)" % [value.x, value.y, value.z]
	else:
		return str(value)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func watch_variable(key: String, object: Node, property: String) -> void:
	"""Surveille une variable pour l'afficher dans l'overlay"""
	watched_variables[key] = {"object": object, "property": property}

func unwatch_variable(key: String) -> void:
	"""Arr√™te de surveiller une variable"""
	watched_variables.erase(key)

func clear_watched() -> void:
	"""Supprime toutes les variables surveill√©es"""
	watched_variables.clear()

func set_show_logs(show: bool) -> void:
	"""Active/d√©sactive l'affichage des logs"""
	show_logs = show

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	# Le toggle est g√©r√© par GameRoot
	pass
```

## core/autoloads/dialogue_manager.gd

```text
extends Node
## DialogueManager - Gestionnaire central du syst√®me de dialogue
## Autoload qui orchestre tous les dialogues du jeu
##
## Utilise la DialogueBox persistante de UIManager (toujours en m√©moire)
## Les sc√®nes n'ont plus besoin d'embarquer leur propre DialogueBox
##
## Acc√®s via : GameRoot.dialogue_manager

class_name DialogueManagerClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal dialogue_started(dialogue_id: String)
signal dialogue_line_shown(line_data: Dictionary)
signal dialogue_choices_shown(choices: Array)
signal dialogue_choice_selected(choice_index: int)
signal dialogue_ended(dialogue_id: String)
signal bark_requested(speaker: String, text: String, position: Vector2)

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var default_text_speed: float = 50.0
@export var default_auto_advance_delay: float = 2.0
@export var enable_skip: bool = true
@export var enable_auto_mode: bool = false
@export var dialogue_sfx_volume: float = 0.0

@export var reading_speed_chars_per_second: float = 15.0
@export var minimum_reading_time: float = 1.5
@export var maximum_reading_time: float = 8.0

# ============================================================================
# √âTAT
# ============================================================================

var current_dialogue = null  # DialogueData
var current_line_index: int = 0
var is_dialogue_active: bool = false

## DialogueBox persistante (assign√©e par GameRoot depuis UIManager)
var persistent_dialogue_box: DialogueBoxClass = null

## DialogueBox active (persistante ou override temporaire)
var dialogue_box: DialogueBoxClass = null

var bark_system = null

var text_speed: float = 50.0
var auto_mode: bool = false
var is_skippable: bool = true

var dialogue_history: Array[Dictionary] = []
var max_history_size: int = 100

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	text_speed = default_text_speed
	auto_mode = enable_auto_mode
	
	if ClassDB.class_exists("BarkSystem"):
		bark_system = ClassDB.instantiate("BarkSystem")
		add_child(bark_system)
	
	call_deferred("_connect_to_event_bus")
	
	print("[DialogueManager] ‚úÖ Initialis√©")

func _connect_to_event_bus() -> void:
	await get_tree().process_frame
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("dialogue_started", _on_eventbus_dialogue_started)
		GameRoot.event_bus.safe_connect("dialogue_ended", _on_eventbus_dialogue_ended)

## Appel√© par GameRoot apr√®s la cr√©ation de UIManager
func set_persistent_dialogue_box(box: DialogueBoxClass) -> void:
	"""Configure la DialogueBox persistante de UIManager"""
	persistent_dialogue_box = box
	print("[DialogueManager] üîó DialogueBox persistante connect√©e")

# ============================================================================
# D√âMARRAGE DE DIALOGUE
# ============================================================================

## D√©marre un dialogue (utilise la DialogueBox persistante par d√©faut)
func start_dialogue(dialogue, override_dialogue_box: DialogueBoxClass = null) -> void:
	"""
	D√©marre un nouveau dialogue.
	
	@param dialogue : DialogueData √† afficher
	@param override_dialogue_box : DialogueBox sp√©cifique (optionnel)
		Si null, utilise la DialogueBox persistante de UIManager
	"""
	
	if is_dialogue_active:
		push_warning("[DialogueManager] Un dialogue est d√©j√† en cours")
		return
	
	if not dialogue or dialogue.lines.is_empty():
		push_error("[DialogueManager] Dialogue invalide ou vide")
		return
	
	current_dialogue = dialogue
	current_line_index = 0
	is_dialogue_active = true
	
	# S√©lectionner la DialogueBox √† utiliser
	if override_dialogue_box:
		dialogue_box = override_dialogue_box
	elif persistent_dialogue_box:
		dialogue_box = persistent_dialogue_box
	else:
		push_error("[DialogueManager] Aucune DialogueBox disponible")
		end_dialogue()
		return
	
	# Configurer la DialogueBox
	dialogue_box.dialogue_manager = self
	dialogue_box.show_dialogue_box()
	
	# Se connecter au signal de r√©v√©lation du texte
	if dialogue_box.has_signal("text_reveal_completed"):
		if not dialogue_box.text_reveal_completed.is_connected(_on_text_reveal_completed):
			dialogue_box.text_reveal_completed.connect(_on_text_reveal_completed)
	
	# √âmettre les signaux
	dialogue_started.emit(dialogue.dialogue_id)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.dialogue_started.emit(dialogue.dialogue_id)
	
	# Afficher la premi√®re ligne
	show_current_line()
	
	print("[DialogueManager] ‚úÖ Dialogue d√©marr√© : %s" % dialogue.dialogue_id)

func start_dialogue_from_id(dialogue_id: String, override_dialogue_box: DialogueBoxClass = null) -> void:
	"""D√©marre un dialogue √† partir de son ID"""
	# TODO: Impl√©menter un syst√®me de registre de dialogues
	push_warning("[DialogueManager] start_dialogue_from_id non impl√©ment√©")

# ============================================================================
# AFFICHAGE DES LIGNES
# ============================================================================

func show_current_line() -> void:
	if not current_dialogue or current_line_index >= current_dialogue.lines.size():
		end_dialogue()
		return
	
	var line = current_dialogue.lines[current_line_index]
	
	print("[DialogueManager] üìñ Ligne %d/%d" % [current_line_index + 1, current_dialogue.lines.size()])
	
	_add_to_history(line)
	
	if line.has("choices") and not line.choices.is_empty():
		show_choices(line.choices)
		return
	
	if line.has("event"):
		_trigger_event(line.event)
		advance_dialogue()
		return
	
	dialogue_box.display_line(line)
	dialogue_line_shown.emit(line)

func _calculate_reading_time(line: Dictionary) -> float:
	if line.has("auto_delay"):
		return line.auto_delay
	
	var text = line.get("text", "")
	var text_key = line.get("text_key", "")
	
	if text_key:
		text = tr(text_key)
	
	var clean_text = _strip_bbcode(text)
	var char_count = clean_text.length()
	
	var reveal_speed = line.get("speed", default_text_speed)
	var reveal_time = char_count / reveal_speed
	var reading_time = char_count / reading_speed_chars_per_second
	var total_time = reveal_time + reading_time
	
	total_time = clamp(total_time, minimum_reading_time, maximum_reading_time)
	return total_time

func _strip_bbcode(text: String) -> String:
	var regex = RegEx.new()
	regex.compile("\\[[\\/]?[^\\]]*\\]")
	return regex.sub(text, "", true)

func show_choices(choices: Array) -> void:
	dialogue_box.display_choices(choices)
	dialogue_choices_shown.emit(choices)

func select_choice(choice_index: int) -> void:
	var line = current_dialogue.lines[current_line_index]
	
	if not line.has("choices") or choice_index >= line.choices.size():
		push_error("[DialogueManager] Index de choix invalide")
		return
	
	var choice = line.choices[choice_index]
	
	dialogue_choice_selected.emit(choice_index)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.choice_made.emit(current_dialogue.dialogue_id, choice_index)
	
	if choice.has("next_line"):
		current_line_index = choice.next_line
		show_current_line()
	elif choice.has("end_dialogue") and choice.end_dialogue:
		end_dialogue()
	else:
		advance_dialogue()

# ============================================================================
# NAVIGATION
# ============================================================================

func advance_dialogue() -> void:
	if not is_dialogue_active:
		return
	
	if dialogue_box and dialogue_box.is_text_revealing:
		dialogue_box.complete_text()
		return
	
	current_line_index += 1
	
	if current_line_index >= current_dialogue.lines.size():
		end_dialogue()
	else:
		show_current_line()

func skip_dialogue() -> void:
	if not is_skippable or not enable_skip:
		return
	end_dialogue()

func end_dialogue() -> void:
	if not is_dialogue_active:
		return
	
	var dialogue_id = current_dialogue.dialogue_id if current_dialogue else ""
	is_dialogue_active = false
	
	# D√©connecter les signaux
	if dialogue_box and dialogue_box.has_signal("text_reveal_completed"):
		if dialogue_box.text_reveal_completed.is_connected(_on_text_reveal_completed):
			dialogue_box.text_reveal_completed.disconnect(_on_text_reveal_completed)
	
	if dialogue_box:
		dialogue_box.hide_dialogue_box()
	
	# √âmettre les signaux
	dialogue_ended.emit(dialogue_id)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.dialogue_ended.emit(dialogue_id)
	
	# Nettoyer
	current_dialogue = null
	current_line_index = 0
	
	# Remettre la DialogueBox par d√©faut (persistante)
	dialogue_box = persistent_dialogue_box
	
	print("[DialogueManager] üèÅ Dialogue termin√© : %s" % dialogue_id)

# ============================================================================
# BARKS
# ============================================================================

func show_bark(speaker: String, text_key: String, world_position: Vector2, duration: float = 2.0) -> void:
	if not bark_system:
		push_warning("[DialogueManager] BarkSystem non initialis√©")
		return
	
	var translated_text = tr(text_key)
	bark_system.show_bark(speaker, translated_text, world_position, duration)
	bark_requested.emit(speaker, translated_text, world_position)

# ============================================================================
# √âV√âNEMENTS
# ============================================================================

func _trigger_event(event_data: Dictionary) -> void:
	var event_type = event_data.get("type", "")
	
	match event_type:
		"set_variable":
			var key = event_data.get("key", "")
			var value = event_data.get("value", null)
			if key:
				print("[DialogueManager] Variable set : %s = %s" % [key, value])
		
		"play_sound":
			var sound_path = event_data.get("sound", "")
			if sound_path:
				print("[DialogueManager] Play sound : %s" % sound_path)
		
		"trigger_battle":
			var battle_id = event_data.get("battle_id", "")
			if battle_id and GameRoot and GameRoot.campaign_manager:
				GameRoot.campaign_manager.start_battle(battle_id)
		
		_:
			print("[DialogueManager] √âv√©nement inconnu : %s" % event_type)

# ============================================================================
# HISTORIQUE
# ============================================================================

func _add_to_history(line: Dictionary) -> void:
	dialogue_history.append(line.duplicate())
	while dialogue_history.size() > max_history_size:
		dialogue_history.pop_front()

func get_history() -> Array[Dictionary]:
	return dialogue_history.duplicate()

func clear_history() -> void:
	dialogue_history.clear()

# ============================================================================
# CONFIGURATION
# ============================================================================

func set_text_speed(speed: float) -> void:
	text_speed = clamp(speed, 10.0, 200.0)

func set_auto_mode(enabled: bool) -> void:
	auto_mode = enabled

func toggle_auto_mode() -> void:
	auto_mode = not auto_mode
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Mode auto: " + ("ON" if auto_mode else "OFF"), "info")

func is_active() -> bool:
	return is_dialogue_active

# ============================================================================
# CALLBACKS
# ============================================================================

func _on_eventbus_dialogue_started(_dialogue_id: String) -> void:
	pass

func _on_eventbus_dialogue_ended(_dialogue_id: String) -> void:
	pass

func _on_text_reveal_completed() -> void:
	if not is_dialogue_active or not current_dialogue:
		return
	
	var line = current_dialogue.lines[current_line_index]
	
	if auto_mode and line.get("auto_advance", false):
		var delay = _calculate_reading_time(line)
		
		get_tree().create_timer(delay).timeout.connect(
			func():
				if is_dialogue_active and current_line_index < current_dialogue.lines.size():
					advance_dialogue()
		)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## core/autoloads/event_bus.gd

```text
extends Node
## EventBus - Hub de communication global d√©coupl√©
## Permet aux sc√®nes de communiquer sans d√©pendances directes
##
## Acc√®s via : GameRoot.event_bus

class_name EventBusClass

# ============================================================================
# SIGNAUX GLOBAUX DU JEU
# ============================================================================

# --- Syst√®me ---
signal game_started()
signal game_paused(paused: bool)
signal game_saved(save_name: String)
signal game_loaded(save_name: String)
signal settings_changed(settings: Dictionary)

# --- Navigation ---
signal scene_change_requested(scene_id: int)
signal return_to_menu_requested()
signal quit_game_requested()

# --- Combat ---
signal battle_started(battle_data: Variant)
signal battle_ended(results: Dictionary)
signal duo_formed(unit_a: Node, unit_b: Node)
signal duo_broken(unit_a: Node, unit_b: Node)
signal unit_attacked(attacker: Node, target: Node, damage: int)
signal unit_died(unit: Node)
signal turn_started(unit: Node)
signal turn_ended(unit: Node)

# --- Statistiques & Progression ---
signal stats_updated(unit: Node, stat_name: String, new_value: float)
signal threat_level_changed(duo: Array, new_threat: float)
signal legend_gained(duo: Array, legend_type: String)
signal title_unlocked(unit: Node, title: String)
signal mvp_awarded(unit: Node, battle_id: String)

# --- Divinit√©s (Syst√®me de Foi) ---
signal divine_points_gained(god_name: String, points: int)
signal divine_threshold_reached(god_name: String, threshold: int)
signal divine_event_triggered(god_name: String, event_data: Dictionary)

# --- Monde & Narration ---
signal dialogue_started(dialogue_id: String)
signal dialogue_ended(dialogue_id: String)
signal choice_made(choice_id: String, option: int)
signal cutscene_started(cutscene_id: String)
signal cutscene_ended(cutscene_id: String)
signal location_discovered(location_name: String)
signal quest_updated(quest_id: String, status: String)

# --- Ressources ---
signal gold_changed(new_amount: int)
signal item_gained(item_id: String, quantity: int)
signal item_lost(item_id: String, quantity: int)

# --- UI ---
signal notification_posted(message: String, type: String)
signal tooltip_requested(content: String, position: Vector2)
signal tooltip_hidden()

# --- Dialogue ---
signal dialogue_bark_requested(speaker: String, text_key: String, position: Vector2)
signal dialogue_typewriter_completed()
signal dialogue_skip_requested()

# --- Campagne ---
signal campaign_started()
signal campaign_completed()
signal chapter_changed(chapter_id: int)

# --- Data Loading ---
signal data_loaded(data_type: String, data: Dictionary)
signal data_load_warning(data_type: String, warning: String)
signal ability_reloaded(ability_id: String)

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	print("[EventBus] ‚úÖ Initialis√©")

# ============================================================================
# M√âTHODES UTILITAIRES
# ============================================================================

func emit_event(event_name: String, args: Array = [], debug: bool = false) -> void:
	"""√âmet un signal par son nom avec des arguments"""
	
	if not has_signal(event_name):
		push_warning("[EventBus] Signal introuvable : %s" % event_name)
		return
	
	if debug:
		print("[EventBus] √âmission : %s avec args : %s" % [event_name, args])
	
	callv("emit_signal", [event_name] + args)

func safe_connect(signal_name: String, callable: Callable, flags: int = 0) -> void:
	"""Connexion s√©curis√©e avec v√©rification"""
	
	if not has_signal(signal_name):
		push_error("[EventBus] Impossible de connecter √† un signal inexistant : %s" % signal_name)
		return
	
	if is_connected(signal_name, callable):
		push_warning("[EventBus] D√©j√† connect√© : %s" % signal_name)
		return
	
	connect(signal_name, callable, flags)

func safe_disconnect(signal_name: String, callable: Callable) -> void:
	"""D√©connexion s√©curis√©e"""
	
	if not has_signal(signal_name):
		return
	
	if is_connected(signal_name, callable):
		disconnect(signal_name, callable)

func disconnect_all(object: Object) -> void:
	"""D√©connexion de tous les signaux d'un objet"""
	
	for signal_dict in get_signal_list():
		var sig_name = signal_dict["name"]
		var connections = get_signal_connection_list(sig_name)
		
		for connection in connections:
			if connection["callable"].get_object() == object:
				disconnect(sig_name, connection["callable"])

# ============================================================================
# HELPERS SP√âCIFIQUES AU JEU
# ============================================================================

func notify(message: String, type: String = "info") -> void:
	"""Notification simple"""
	notification_posted.emit(message, type)

func change_scene(scene_id: int) -> void:
	"""Changement de sc√®ne via EventBus"""
	scene_change_requested.emit(scene_id)

func add_divine_points(god: String, points: int) -> void:
	"""Mise √† jour des statistiques divines"""
	divine_points_gained.emit(god, points)

func form_duo(unit_a: Node, unit_b: Node) -> void:
	"""Formation de duo"""
	duo_formed.emit(unit_a, unit_b)

func break_duo(unit_a: Node, unit_b: Node) -> void:
	"""Rupture de duo"""
	duo_broken.emit(unit_a, unit_b)

func attack(attacker: Node, target: Node, damage: int) -> void:
	"""Attaque d'unit√©"""
	unit_attacked.emit(attacker, target, damage)

func end_battle(results: Dictionary) -> void:
	"""Fin de combat"""
	battle_ended.emit(results)

func show_bark(speaker: String, text_key: String, position: Vector2) -> void:
	"""Affiche un bark de dialogue"""
	dialogue_bark_requested.emit(speaker, text_key, position)

func start_battle(battle_id: String) -> void:
	"""√âmet le signal de d√©but de combat"""
	print("[EventBus] üé¨ D√©but du combat : %s" % battle_id)
	battle_started.emit(battle_id)

# ============================================================================
# DEBUG
# ============================================================================

func debug_list_connections() -> void:
	"""Liste toutes les connexions actives (debug)"""
	
	print("\n=== EventBus - Connexions actives ===")
	
	for signal_dict in get_signal_list():
		var sig_name = signal_dict["name"]
		var connections = get_signal_connection_list(sig_name)
		
		if connections.size() > 0:
			print("\n[%s] : %d connexions" % [sig_name, connections.size()])
			for connection in connections:
				var target = connection["callable"].get_object()
				var method = connection["callable"].get_method()
				print("  -> %s.%s" % [target.name if target else "null", method])
	
	print("\n=====================================\n")
```

## core/autoloads/game_manager.gd

```text
extends Node
## GameManager - Orchestration du cycle de vie du jeu
## G√®re l'√©tat du jeu, les sauvegardes, la pause
##
## Le d√©marrage de nouvelle partie est d√©l√©gu√© √† CampaignManager
## (qui g√®re la s√©quence d'intro via DialogueManager + UIManager)
##
## Acc√®s via : GameRoot.game_manager

class_name GameManagerClass

# ============================================================================
# R√âF√âRENCES (assign√©es par GameRoot)
# ============================================================================

var scene_loader: SceneLoaderClass = null

# ============================================================================
# √âTAT DU JEU
# ============================================================================

var game_state: Dictionary = {}
var is_paused: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	print("[GameManager] ‚úÖ Initialis√©")

# ============================================================================
# GESTION DE LA PAUSE
# ============================================================================

func pause_game(paused: bool) -> void:
	is_paused = paused
	get_tree().paused = paused
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.game_paused.emit(paused)
	
	print("[GameManager] Jeu %s" % ("en pause" if paused else "repris"))

func toggle_pause() -> void:
	pause_game(not is_paused)

# ============================================================================
# SAUVEGARDE / CHARGEMENT
# ============================================================================

func save_game(save_name: String) -> void:
	game_state["timestamp"] = Time.get_unix_time_from_system()
	game_state["scene_id"] = scene_loader.current_scene_id if scene_loader else -1
	
	# Sauvegarder l'√©tat de la campagne
	if GameRoot and GameRoot.campaign_manager:
		game_state["campaign"] = GameRoot.campaign_manager.get_campaign_state()
	
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("saves"):
		dir.make_dir("saves")
	
	var save_path = "user://saves/%s.save" % save_name
	var file = FileAccess.open(save_path, FileAccess.WRITE)
	
	if file:
		file.store_string(JSON.stringify(game_state, "\t"))
		file.close()
		
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.game_saved.emit(save_name)
			GameRoot.event_bus.notify("Partie sauvegard√©e : %s" % save_name, "success")
		
		print("[GameManager] üíæ Sauvegarde : %s" % save_name)
	else:
		push_error("[GameManager] Impossible de sauvegarder")

func load_game(save_name: String) -> void:
	var save_path = "user://saves/%s.save" % save_name
	
	if not FileAccess.file_exists(save_path):
		push_error("[GameManager] Sauvegarde introuvable : %s" % save_name)
		return
	
	var file = FileAccess.open(save_path, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		game_state = json.data
		
		var saved_scene_id = game_state.get("scene_id", -1)
		if saved_scene_id != -1 and scene_loader:
			scene_loader.load_scene_by_id(saved_scene_id)
		
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.game_loaded.emit(save_name)
			GameRoot.event_bus.notify("Partie charg√©e : %s" % save_name, "success")
		
		print("[GameManager] üìÇ Chargement : %s" % save_name)
	else:
		push_error("[GameManager] Erreur lors du chargement de la sauvegarde")

func has_save(save_name: String) -> bool:
	return FileAccess.file_exists("user://saves/%s.save" % save_name)

func get_save_list() -> Array[String]:
	var saves: Array[String] = []
	var save_dir = "user://saves/"
	
	if not DirAccess.dir_exists_absolute(save_dir):
		return saves
	
	var dir = DirAccess.open(save_dir)
	dir.list_dir_begin()
	
	var file_name = dir.get_next()
	while file_name != "":
		if file_name.ends_with(".save"):
			saves.append(file_name.get_basename())
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return saves

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_game_started() -> void:
	"""Callback quand une nouvelle partie d√©marre.
	La s√©quence d'intro est enti√®rement g√©r√©e par CampaignManager
	(qui utilise DialogueManager + UIManager pour les dialogues et l'UI)."""
	
	print("[GameManager] üéÆ Nouvelle partie d√©marr√©e")
	
	# CampaignManager re√ßoit aussi game_started et g√®re la s√©quence d'intro
	# Pas besoin de charger une sc√®ne intro ici - CampaignManager s'en occupe

func _on_game_paused(paused: bool) -> void:
	if paused != is_paused:
		is_paused = paused
		get_tree().paused = paused
	print("[GameManager] %s" % ("‚è∏Ô∏è Pause" if paused else "‚ñ∂Ô∏è Reprise"))

func _on_quit_game_requested() -> void:
	print("[GameManager] üö™ Fermeture du jeu...")
	get_tree().quit()

func _on_return_to_menu_requested() -> void:
	print("[GameManager] üè† Retour au menu principal")
	
	is_paused = false
	get_tree().paused = false
	
	if scene_loader:
		scene_loader.load_scene_by_id(SceneRegistry.SceneID.MAIN_MENU)

# ============================================================================
# GETTERS
# ============================================================================

func get_current_scene() -> Node:
	return scene_loader.current_scene if scene_loader else null

func get_current_scene_id() -> int:
	return scene_loader.current_scene_id if scene_loader else -1

func is_loading() -> bool:
	return scene_loader.is_loading if scene_loader else false

# ============================================================================
# DEBUG
# ============================================================================

func _input(event: InputEvent) -> void:
	if OS.is_debug_build():
		if event.is_action_pressed("ui_end"):
			print_status()

func print_status() -> void:
	print("\n=== GameManager Status ===")
	print("  Sc√®ne : %s" % (SceneRegistry.get_scene_name(get_current_scene_id()) if get_current_scene_id() != -1 else "N/A"))
	print("  Pause : %s" % is_paused)
	print("  Loading : %s" % is_loading())
	print("===========================\n")
```

## core/autoloads/game_root.gd

```text
extends Node
## GameRoot - Point d'entr√©e unique du jeu
## Sc√®ne autoload principale qui instancie et expose tous les syst√®mes globaux
##
## Configuration : Ajouter GameRoot.tscn comme autoload nomm√© "GameRoot"
## Acc√®s : GameRoot.event_bus, GameRoot.scene_loader, etc.

class_name GameRootClass


# === AUTOLOADS ===
const EventBusClass        = preload("res://core/autoloads/event_bus.gd")
const SceneLoaderClass     = preload("res://core/autoloads/scene_loader.gd")
const UIManagerClass       = preload("res://core/autoloads/ui_manager.gd")
const DialogueManagerClass = preload("res://core/autoloads/dialogue_manager.gd")
const TeamManagerClass     = preload("res://core/autoloads/team_manager.gd")
const BattleDataManagerClass = preload("res://core/autoloads/battle_data_manager.gd")
const CampaignManagerClass = preload("res://core/autoloads/campaign_manager.gd")
const GlobalLoggerClass    = preload("res://core/autoloads/global_logger.gd")
const VersionManagerClass  = preload("res://core/autoloads/version_manager.gd")
const GameManagerClass     = preload("res://core/autoloads/game_manager.gd")
const DebugOverlayClass    = preload("res://core/autoloads/debug_overlay.gd")

# === DATA / HELPERS ===
const SceneRegistry        = preload("res://core/data/scene_registry.gd")
const JSONDataLoader       = preload("res://core/data/json_data_loader.gd")
const ModelValidator       = preload("res://core/data/model_validator.gd")
const ValidationResult     = preload("res://core/data/validation_result.gd")
const AbilityDataLoader    = preload("res://core/data/ability_data_loader.gd")

# === DIALOGUE SYSTEM ===
const DialogueData         = preload("res://core/dialogue/dialogue_data.gd")
const DialogueDataLoader   = preload("res://core/dialogue/dialogue_data_loader.gd")
const DialogueBoxClass     = preload("res://core/dialogue/dialogue_box.gd")
const BarkSystem           = preload("res://core/dialogue/bark_system.gd")

# === FEATURES ===
const DebugVersionPanel    = preload("res://features/debug/debug_version_panel.gd")
#const MainMenuClass        = preload("res://features/menu/main_menu.gd")
const WorldMapClass        = preload("res://features/world_map/logic/world_map.gd")


# ============================================================================
# R√âF√âRENCES EXPOS√âES (acc√®s via GameRoot.xxx)
# ============================================================================

var event_bus: EventBusClass = null
var scene_loader: SceneLoaderClass = null
var game_manager: GameManagerClass = null
var ui_manager: UIManagerClass = null
var debug_overlay: DebugOverlayClass = null
var global_logger: GlobalLoggerClass = null
var battle_data_manager: BattleDataManagerClass = null
var dialogue_manager: DialogueManagerClass = null
var version_manager: VersionManagerClass = null
var team_manager : TeamManagerClass = null  # TeamManager n'a pas de class_name typ√©
var dialogue_data : DialogueData = null
var campaign_manager: CampaignManagerClass = null
# ============================================================================
# CONTENEUR DE SC√àNES
# ============================================================================

var scene_container: Node = null
var current_scene: Node = null

# ============================================================================
# CONFIGURATION DES SCRIPTS
# ============================================================================

const SCRIPTS = {
	"event_bus": "res://core/autoloads/event_bus.gd",
	"global_logger": "res://core/autoloads/global_logger.gd",
	"scene_loader": "res://core/autoloads/scene_loader.gd",
	"game_manager": "res://core/autoloads/game_manager.gd",
	"ui_manager": "res://core/autoloads/ui_manager.gd",
	"debug_overlay": "res://core/autoloads/debug_overlay.gd",
	"battle_data_manager": "res://core/autoloads/battle_data_manager.gd",
	"dialogue_manager": "res://core/autoloads/dialogue_manager.gd",
	"version_manager": "res://core/autoloads/version_manager.gd",
	"team_manager": "res://core/autoloads/team_manager.gd",
	"dialogue_data": "res://core/dialogue/dialogue_data.gd",
	"campaign_manager": "res://core/autoloads/campaign_manager.gd"
}




# ============================================================================
# √âTAT
# ============================================================================

var _is_initialized: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	if _is_initialized:
		push_warning("[GameRoot] D√©j√† initialis√©, skip")
		return
	
	name = "GameRoot"
	
	print("========================================")
	print("  GAME ROOT - Initialisation")
	print("========================================")
	
	# Ordre d'initialisation important !
	_setup_scene_container()
	_initialize_core_systems()
	_initialize_managers()
	_initialize_ui_systems()
	_connect_systems()
	_check_migrations()
	
	_is_initialized = true
	
	print("========================================")
	print("  GAME ROOT - Pr√™t !")
	print("========================================")
	
	# Charger la sc√®ne initiale
	call_deferred("_load_initial_scene")

func _setup_scene_container() -> void:
	"""Configure le conteneur de sc√®nes (cr√©√© dans la .tscn ou dynamiquement)"""
	scene_container = get_node_or_null("SceneContainer")
	
	if not scene_container:
		scene_container = Node.new()
		scene_container.name = "SceneContainer"
		add_child(scene_container)
		print("[GameRoot]   ‚Üí SceneContainer cr√©√© dynamiquement")
	else:
		print("[GameRoot]   ‚Üí SceneContainer trouv√© dans la sc√®ne")

func _initialize_core_systems() -> void:
	"""Initialise les syst√®mes de base (EventBus, Logger)"""
	global_logger = _create_system("global_logger", "GlobalLogger") as GlobalLoggerClass
	event_bus = _create_system("event_bus", "EventBus") as EventBusClass
	print("[GameRoot] ‚úÖ Syst√®mes de base initialis√©s")

func _initialize_managers() -> void:
	"""Initialise les managers principaux"""
	
	# SceneLoader
	scene_loader = _create_system("scene_loader", "SceneLoader") as SceneLoaderClass
	scene_loader.scene_container = scene_container
	
	# GameManager
	game_manager = _create_system("game_manager", "GameManager") as GameManagerClass
	game_manager.scene_loader = scene_loader
	
	# BattleDataManager
	battle_data_manager = _create_system("battle_data_manager", "BattleDataManager") as BattleDataManagerClass
	
	# DialogueManager
	dialogue_manager = _create_system("dialogue_manager", "DialogueManager") as DialogueManagerClass
	
	# VersionManager
	version_manager = _create_system("version_manager", "VersionManager") as VersionManagerClass
	
	# TeamManager
	team_manager = _create_system("team_manager", "TeamManager")
	
	# CampaignManager (apr√®s les autres car il les utilise)
	campaign_manager = _create_system("campaign_manager", "CampaignManager") as CampaignManagerClass
	
	print("[GameRoot] ‚úÖ Managers initialis√©s")

func _initialize_ui_systems() -> void:
	"""Initialise les syst√®mes UI (au-dessus des sc√®nes)"""
	ui_manager = _create_system("ui_manager", "UIManager") as UIManagerClass
	
	if OS.is_debug_build():
		debug_overlay = _create_system("debug_overlay", "DebugOverlay") as DebugOverlayClass
	
	# Connecter DialogueManager √† la DialogueBox persistante de UIManager
	if dialogue_manager and ui_manager:
		GameRoot.dialogue_manager.set_persistent_dialogue_box(ui_manager.get_dialogue_box())
	
	print("[GameRoot] ‚úÖ Syst√®mes UI initialis√©s")

func _create_system(key: String, node_name: String) -> Node:
	"""Cr√©e et ajoute un syst√®me depuis son script."""
	var script_path = SCRIPTS.get(key, "")
	
	if script_path == "":
		push_error("[GameRoot] Cl√© de script introuvable : %s" % key)
		return null
	
	if not ResourceLoader.exists(script_path):
		push_error("[GameRoot] Script introuvable : %s" % script_path)
		return null
	
	var script = load(script_path)
	if not script:
		push_error("[GameRoot] √âchec du chargement du script : %s" % script_path)
		return null
	
	var base_type: String = script.get_instance_base_type()
	var instance: Node
	
	match base_type:
		"CanvasLayer":
			instance = CanvasLayer.new()
		"Control":
			instance = Control.new()
		"Node2D":
			instance = Node2D.new()
		"Node3D":
			instance = Node3D.new()
		_:
			instance = Node.new()
	
	instance.set_script(script)
	instance.name = node_name
	add_child(instance)
	
	print("[GameRoot]   ‚Üí %s charg√© (%s)" % [node_name, base_type])
	return instance

func _connect_systems() -> void:
	"""Connecte les syst√®mes entre eux via l'EventBus"""
	if not event_bus:
		push_error("[GameRoot] EventBus non initialis√©")
		return
	
	# SceneLoader
	if scene_loader:
		event_bus.safe_connect("scene_change_requested", scene_loader._on_scene_change_requested)
	
	# GameManager
	if game_manager:
		event_bus.safe_connect("game_started", game_manager._on_game_started)
		event_bus.safe_connect("game_paused", game_manager._on_game_paused)
		event_bus.safe_connect("quit_game_requested", game_manager._on_quit_game_requested)
		event_bus.safe_connect("return_to_menu_requested", game_manager._on_return_to_menu_requested)
	
	# UIManager
	if ui_manager:
		event_bus.safe_connect("notification_posted", ui_manager._on_notification_posted)
	
	# CampaignManager
	if campaign_manager:
		event_bus.safe_connect("game_started", campaign_manager._on_game_started)
		event_bus.safe_connect("battle_ended", campaign_manager._on_battle_ended)
	
	print("[GameRoot] ‚úÖ Syst√®mes connect√©s")

func _check_migrations() -> void:
	if version_manager:
		version_manager.check_and_migrate()

func _load_initial_scene() -> void:
	"""Charge la sc√®ne initiale (menu principal)"""
	if scene_loader:
		if SceneRegistry.scene_exists(SceneRegistry.SceneID.MAIN_MENU):
			scene_loader.load_scene_by_id(SceneRegistry.SceneID.MAIN_MENU, false)
		else:
			push_warning("[GameRoot] Menu principal non trouv√©")

# ============================================================================
# CALLBACKS SC√àNE
# ============================================================================

func _on_scene_loaded(scene: Node) -> void:
	current_scene = scene
	if global_logger:
		global_logger.info("SCENE", "Sc√®ne charg√©e : %s" % scene.name)

func _on_scene_unloaded() -> void:
	current_scene = null

# ============================================================================
# API PUBLIQUE
# ============================================================================

func change_scene(scene_id: int, transition: bool = true) -> void:
	if scene_loader:
		scene_loader.load_scene_by_id(scene_id, transition)

func change_scene_by_path(scene_path: String, transition: bool = true) -> void:
	if scene_loader:
		scene_loader.load_scene(scene_path, transition)

func notify(message: String, type: String = "info") -> void:
	if event_bus:
		event_bus.notify(message, type)

func log_info(category: String, message: String) -> void:
	if global_logger:
		global_logger.info(category, message)

func log_debug(category: String, message: String) -> void:
	if global_logger:
		global_logger.debug(category, message)

func log_warning(category: String, message: String) -> void:
	if global_logger:
		global_logger.warning(category, message)

func log_error(category: String, message: String) -> void:
	if global_logger:
		global_logger.error(category, message)

# ============================================================================
# GETTERS
# ============================================================================

func get_current_scene() -> Node:
	return current_scene

func get_current_scene_id() -> int:
	return scene_loader.current_scene_id if scene_loader else -1

func is_loading() -> bool:
	return scene_loader.is_loading if scene_loader else false

func is_initialized() -> bool:
	return _is_initialized

func get_event_bus() -> EventBusClass:
	return event_bus

func get_scene_loader() -> SceneLoaderClass:
	return scene_loader

func get_game_manager() -> GameManagerClass:
	return game_manager

func get_ui_manager() -> UIManagerClass:
	return ui_manager

func get_global_logger() -> GlobalLoggerClass:
	return global_logger

func get_battle_data_manager() -> BattleDataManagerClass:
	return battle_data_manager

func get_dialogue_manager() -> DialogueManagerClass:
	return dialogue_manager

func get_campaign_manager() -> CampaignManagerClass:
	return campaign_manager

# ============================================================================
# DEBUG
# ============================================================================

func _input(event: InputEvent) -> void:
	if OS.is_debug_build():
		if event.is_action_pressed("debug_toggle") and debug_overlay:
			debug_overlay.toggle_visibility()

func print_status() -> void:
	print("\n=== GameRoot Status ===")
	print("  Initialized: ", _is_initialized)
	print("  EventBus: ", "OK" if event_bus else "NULL")
	print("  GlobalLogger: ", "OK" if global_logger else "NULL")
	print("  SceneLoader: ", "OK" if scene_loader else "NULL")
	print("  GameManager: ", "OK" if game_manager else "NULL")
	print("  UIManager: ", "OK" if ui_manager else "NULL")
	print("  BattleDataManager: ", "OK" if battle_data_manager else "NULL")
	print("  DialogueManager: ", "OK" if dialogue_manager else "NULL")
	print("  CampaignManager: ", "OK" if campaign_manager else "NULL")
	print("  VersionManager: ", "OK" if version_manager else "NULL")
	print("  TeamManager: ", "OK" if team_manager else "NULL")
	print("  DebugOverlay: ", "OK" if debug_overlay else "N/A (release)")
	print("  SceneContainer: ", "OK" if scene_container else "NULL")
	print("  CurrentScene: ", current_scene.name if current_scene else "None")
	print("========================\n")
```

## core/autoloads/global_logger.gd

```text
extends Node
## GlobalLogger - Syst√®me de logging centralis√©
## G√®re les logs avec cat√©gories, niveaux et formatage
##
## Acc√®s via : GameRoot.global_logger

class_name GlobalLoggerClass

# ============================================================================
# CONFIGURATION
# ============================================================================

enum LogLevel {
	DEBUG = 0,
	INFO = 1,
	WARNING = 2,
	ERROR = 3,
	NONE = 4
}

const LOG_COLORS = {
	LogLevel.DEBUG: "gray",
	LogLevel.INFO: "white",
	LogLevel.WARNING: "yellow",
	LogLevel.ERROR: "red"
}

const LOG_PREFIXES = {
	LogLevel.DEBUG: "üîç",
	LogLevel.INFO: "‚ÑπÔ∏è",
	LogLevel.WARNING: "‚ö†Ô∏è",
	LogLevel.ERROR: "‚ùå"
}

# ============================================================================
# √âTAT
# ============================================================================

var min_log_level: LogLevel = LogLevel.DEBUG
var enabled_categories: Dictionary = {}  # category -> bool
var log_to_file: bool = false
var log_file_path: String = "user://logs/game.log"
var log_file: FileAccess = null

# Historique des logs (pour debug overlay)
var log_history: Array[Dictionary] = []
var max_history: int = 100

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# En release, ne logger que les warnings et erreurs
	if not OS.is_debug_build():
		min_log_level = LogLevel.WARNING
	
	# Activer toutes les cat√©gories par d√©faut
	_enable_default_categories()
	
	print("[GlobalLogger] ‚úÖ Initialis√© (niveau: %s)" % LogLevel.keys()[min_log_level])

func _enable_default_categories() -> void:
	"""Active les cat√©gories de log par d√©faut"""
	
	var categories = [
		"GAME", "BATTLE", "UI", "SCENE", "SAVE",
		"AUDIO", "NETWORK", "AI", "DIALOGUE", "EVENT",
		"BATTLE_DATA", "TEAM"
	]
	
	for cat in categories:
		enabled_categories[cat] = true

# ============================================================================
# API PUBLIQUE
# ============================================================================

func debug(category: String, message: String) -> void:
	"""Log de niveau DEBUG"""
	_log(LogLevel.DEBUG, category, message)

func info(category: String, message: String) -> void:
	"""Log de niveau INFO"""
	_log(LogLevel.INFO, category, message)

func warning(category: String, message: String) -> void:
	"""Log de niveau WARNING"""
	_log(LogLevel.WARNING, category, message)

func error(category: String, message: String) -> void:
	"""Log de niveau ERROR"""
	_log(LogLevel.ERROR, category, message)

# ============================================================================
# LOGGING INTERNE
# ============================================================================

func _log(level: LogLevel, category: String, message: String) -> void:
	"""Fonction de logging principale"""
	
	# V√©rifier le niveau minimum
	if level < min_log_level:
		return
	
	# V√©rifier si la cat√©gorie est activ√©e (sauf pour ERROR)
	if level != LogLevel.ERROR:
		if enabled_categories.has(category) and not enabled_categories[category]:
			return
	
	# Formater le message
	var timestamp = Time.get_time_string_from_system()
	var prefix = LOG_PREFIXES.get(level, "")
	var formatted = "[%s] %s [%s] %s" % [timestamp, prefix, category, message]
	
	# Afficher dans la console
	match level:
		LogLevel.DEBUG:
			print(formatted)
		LogLevel.INFO:
			print(formatted)
		LogLevel.WARNING:
			push_warning(formatted)
		LogLevel.ERROR:
			push_error(formatted)
	
	# Ajouter √† l'historique
	_add_to_history(level, category, message, timestamp)
	
	# √âcrire dans le fichier si activ√©
	if log_to_file:
		_write_to_file(formatted)

func _add_to_history(level: LogLevel, category: String, message: String, timestamp: String) -> void:
	"""Ajoute un log √† l'historique"""
	
	log_history.append({
		"level": level,
		"category": category,
		"message": message,
		"timestamp": timestamp
	})
	
	# Limiter la taille
	while log_history.size() > max_history:
		log_history.pop_front()

func _write_to_file(message: String) -> void:
	"""√âcrit un message dans le fichier de log"""
	
	if not log_file:
		_open_log_file()
	
	if log_file:
		log_file.store_line(message)
		log_file.flush()

func _open_log_file() -> void:
	"""Ouvre le fichier de log"""
	
	# Cr√©er le dossier si n√©cessaire
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("logs"):
		dir.make_dir("logs")
	
	log_file = FileAccess.open(log_file_path, FileAccess.WRITE)
	
	if log_file:
		log_file.store_line("=== Game Log - %s ===" % Time.get_datetime_string_from_system())
		log_file.store_line("")

# ============================================================================
# CONFIGURATION
# ============================================================================

func set_log_level(level: LogLevel) -> void:
	"""D√©finit le niveau minimum de log"""
	min_log_level = level
	info("GAME", "Niveau de log chang√© : %s" % LogLevel.keys()[level])

func enable_category(category: String, enabled: bool = true) -> void:
	"""Active ou d√©sactive une cat√©gorie"""
	enabled_categories[category] = enabled

func enable_file_logging(enabled: bool = true, path: String = "") -> void:
	"""Active ou d√©sactive le logging dans un fichier"""
	
	log_to_file = enabled
	
	if path != "":
		log_file_path = path
	
	if enabled:
		_open_log_file()
		info("GAME", "Logging fichier activ√© : %s" % log_file_path)
	elif log_file:
		log_file.close()
		log_file = null

# ============================================================================
# UTILITAIRES
# ============================================================================

func get_recent_logs(count: int = 20, level_filter: LogLevel = LogLevel.DEBUG) -> Array[Dictionary]:
	"""Retourne les logs r√©cents filtr√©s par niveau"""
	
	var filtered: Array[Dictionary] = []
	
	for i in range(log_history.size() - 1, -1, -1):
		var entry = log_history[i]
		if entry.level >= level_filter:
			filtered.append(entry)
			if filtered.size() >= count:
				break
	
	filtered.reverse()
	return filtered

func get_logs_by_category(category: String, count: int = 20) -> Array[Dictionary]:
	"""Retourne les logs d'une cat√©gorie sp√©cifique"""
	
	var filtered: Array[Dictionary] = []
	
	for i in range(log_history.size() - 1, -1, -1):
		var entry = log_history[i]
		if entry.category == category:
			filtered.append(entry)
			if filtered.size() >= count:
				break
	
	filtered.reverse()
	return filtered

func clear_history() -> void:
	"""Vide l'historique des logs"""
	log_history.clear()

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if log_file:
		log_file.store_line("")
		log_file.store_line("=== Session termin√©e ===")
		log_file.close()
```

## core/autoloads/scene_loader.gd

```text
extends Node
## SceneLoader - Chargement et transition de sc√®nes
## Charge les sc√®nes dans le SceneContainer de GameRoot
##
## Acc√®s via : GameRoot.scene_loader

class_name SceneLoaderClass

# ============================================================================
# SIGNAUX
# ============================================================================

signal scene_loading_started(scene_path: String)
signal scene_loading_progress(progress: float)
signal scene_loaded(scene: Node)
signal scene_transition_finished()

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var fade_duration: float = 0.3
@export var debug_mode: bool = true

# ============================================================================
# R√âF√âRENCES
# ============================================================================

var scene_container: Node = null  # Assign√© par GameRoot
var transition_overlay: ColorRect = null

# ============================================================================
# √âTAT
# ============================================================================

var current_scene: Node = null
var current_scene_id: int = -1
var is_loading: bool = false
var loading_progress: float = 0.0

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	call_deferred("_setup_transition_overlay")
	print("[SceneLoader] ‚úÖ Initialis√©")

func _setup_transition_overlay() -> void:
	"""Cr√©e l'overlay de transition dans l'UIManager"""
	
	# Attendre que l'UIManager soit pr√™t
	await get_tree().process_frame
	
	if GameRoot and GameRoot.ui_manager:
		transition_overlay = GameRoot.ui_manager.create_transition_overlay()
	else:
		# Fallback : cr√©er localement
		_create_local_overlay()
	
	if debug_mode:
		print("[SceneLoader] ‚úÖ Overlay de transition configur√©")

func _create_local_overlay() -> void:
	"""Cr√©e un overlay local (fallback)"""
	
	var canvas = CanvasLayer.new()
	canvas.layer = 100
	add_child(canvas)
	
	transition_overlay = ColorRect.new()
	transition_overlay.color = Color.BLACK
	transition_overlay.set_anchors_preset(Control.PRESET_FULL_RECT)
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	transition_overlay.modulate.a = 0.0
	canvas.add_child(transition_overlay)

# ============================================================================
# CHARGEMENT DE SC√àNE
# ============================================================================

func load_scene_by_id(scene_id: int, transition: bool = true) -> void:
	"""Charge une sc√®ne via son ID du registre"""
	
	if not SceneRegistry.scene_exists(scene_id):
		push_error("[SceneLoader] Sc√®ne introuvable : %d" % scene_id)
		return
	
	var scene_path = SceneRegistry.get_scene_path(scene_id)
	current_scene_id = scene_id
	
	if debug_mode:
		print("[SceneLoader] üé¨ Chargement : %s" % SceneRegistry.get_scene_name(scene_id))
	
	await load_scene(scene_path, transition)

func load_scene(scene_path: String, transition: bool = true) -> void:
	"""Charge une sc√®ne par son chemin"""
	
	if is_loading:
		push_warning("[SceneLoader] Chargement d√©j√† en cours")
		return
	
	if not ResourceLoader.exists(scene_path):
		push_error("[SceneLoader] Sc√®ne introuvable : %s" % scene_path)
		return
	
	is_loading = true
	scene_loading_started.emit(scene_path)
	
	if debug_mode:
		print("[SceneLoader] üé¨ D√©but du chargement : %s" % scene_path)
	
	# Transition sortante
	if transition:
		await _fade_out()
	
	# Nettoyer la sc√®ne actuelle
	_cleanup_current_scene()
	
	# Charger la nouvelle sc√®ne
	var new_scene = await _load_scene_async(scene_path)
	
	if new_scene == null:
		push_error("[SceneLoader] √âchec du chargement : %s" % scene_path)
		is_loading = false
		if transition:
			await _fade_in()
		return
	
	# Ajouter la sc√®ne au container
	if scene_container:
		scene_container.add_child(new_scene)
	else:
		push_error("[SceneLoader] SceneContainer non d√©fini !")
		get_tree().root.add_child(new_scene)
	
	current_scene = new_scene
	
	# Mettre √† jour la r√©f√©rence dans GameRoot
	if GameRoot:
		GameRoot.current_scene = new_scene
		GameRoot._on_scene_loaded(new_scene)
	
	scene_loaded.emit(new_scene)
	
	# Transition entrante
	if transition:
		await _fade_in()
	
	is_loading = false
	scene_transition_finished.emit()
	
	if debug_mode:
		print("[SceneLoader] ‚úÖ Sc√®ne charg√©e : %s" % scene_path)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _cleanup_current_scene() -> void:
	"""Supprime la sc√®ne actuelle"""
	
	if not scene_container:
		return
	
	for child in scene_container.get_children():
		if debug_mode:
			print("[SceneLoader] üóëÔ∏è Suppression : %s" % child.name)
		child.queue_free()
	
	current_scene = null
	
	# Notifier GameRoot
	if GameRoot:
		GameRoot._on_scene_unloaded()
	
	# Attendre le nettoyage
	await get_tree().process_frame

# ============================================================================
# CHARGEMENT ASYNCHRONE
# ============================================================================

func _load_scene_async(scene_path: String) -> Node:
	"""Chargement asynchrone avec progression"""
	
	var status = ResourceLoader.load_threaded_request(scene_path)
	
	if status != OK:
		push_error("[SceneLoader] Erreur lors de la requ√™te de chargement")
		return null
	
	while true:
		var progress_array = []
		status = ResourceLoader.load_threaded_get_status(scene_path, progress_array)
		
		if status == ResourceLoader.THREAD_LOAD_LOADED:
			var packed_scene = ResourceLoader.load_threaded_get(scene_path)
			return packed_scene.instantiate()
		
		elif status == ResourceLoader.THREAD_LOAD_FAILED:
			push_error("[SceneLoader] √âchec du chargement threaded")
			return null
		
		elif status == ResourceLoader.THREAD_LOAD_INVALID_RESOURCE:
			push_error("[SceneLoader] Ressource invalide")
			return null
		
		# Mettre √† jour la progression
		if progress_array.size() > 0:
			loading_progress = progress_array[0]
			scene_loading_progress.emit(loading_progress)
			
			# Notifier l'UIManager
			if GameRoot and GameRoot.ui_manager:
				GameRoot.ui_manager.update_loading_progress(loading_progress)
		
		await get_tree().process_frame
	
	return null

# ============================================================================
# TRANSITIONS VISUELLES
# ============================================================================

func _fade_out() -> void:
	"""Fondu vers le noir"""
	
	if not transition_overlay:
		return
	
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_STOP
	
	var tween = create_tween()
	tween.tween_property(transition_overlay, "modulate:a", 1.0, fade_duration)
	await tween.finished

func _fade_in() -> void:
	"""Fondu depuis le noir"""
	
	if not transition_overlay:
		return
	
	var tween = create_tween()
	tween.tween_property(transition_overlay, "modulate:a", 0.0, fade_duration)
	await tween.finished
	
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_scene_change_requested(scene_id: int) -> void:
	"""R√©action √† une demande de changement de sc√®ne"""
	load_scene_by_id(scene_id)

# ============================================================================
# UTILITAIRES
# ============================================================================

func reload_current_scene(transition: bool = true) -> void:
	"""Recharge la sc√®ne actuelle"""
	
	if current_scene_id != -1:
		load_scene_by_id(current_scene_id, transition)
	elif current_scene:
		var scene_path = current_scene.scene_file_path
		load_scene(scene_path, transition)

func get_current_scene_name() -> String:
	"""Retourne le nom de la sc√®ne actuelle"""
	
	if current_scene_id != -1:
		return SceneRegistry.get_scene_name(current_scene_id)
	elif current_scene:
		return current_scene.name
	return "Aucune"
```

## core/autoloads/team_manager.gd

```text
extends Node
## TeamManager - Gestion de l'√©quipe du joueur
## Autoload pour g√©rer le roster, le recrutement, l'XP
##
## Acc√®s via : GameRoot.team_manager

class_name TeamManagerClass

signal team_changed()
signal unit_recruited(unit_id: String)
signal unit_dismissed(unit_id: String)
signal unit_leveled_up(unit_id: String, new_level: int)

# ============================================================================
# CONFIGURATION
# ============================================================================

const MAX_TEAM_SIZE: int = 8
const TEAM_SAVE_PATH: String = "user://team_data.json"
const AVAILABLE_UNITS_PATH: String = "res://data/team/available_units.json"

# ============================================================================
# DONN√âES
# ============================================================================

var current_team: Array[Dictionary] = []  # √âquipe active (max 4 en combat)
var roster: Array[Dictionary] = []  # Toutes les unit√©s recrut√©es
var available_units: Dictionary = {}  # Unit√©s recrutables

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_load_available_units()
	_load_team_from_save()
	print("[TeamManager] ‚úÖ Initialis√© - √âquipe : ", current_team.size(), " / Roster : ", roster.size())

func _load_available_units() -> void:
	if not FileAccess.file_exists(AVAILABLE_UNITS_PATH):
		push_warning("[TeamManager] Fichier d'unit√©s disponibles non trouv√©")
		return
	
	var file = FileAccess.open(AVAILABLE_UNITS_PATH, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		available_units = json.data
	else:
		push_warning("[TeamManager] Erreur de parsing des unit√©s disponibles")

# ============================================================================
# GESTION DE L'√âQUIPE
# ============================================================================

func add_to_team(unit_data: Dictionary) -> bool:
	"""Ajoute une unit√© √† l'√©quipe active"""
	
	if current_team.size() >= 4:
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.notify("√âquipe compl√®te (max 4 en combat)", "warning")
		return false
	
	current_team.append(unit_data)
	team_changed.emit()
	_save_team()
	
	print("[TeamManager] ‚úÖ Ajout√© : ", unit_data.get("name"))
	return true

func remove_from_team(unit_id: String) -> bool:
	"""Retire une unit√© de l'√©quipe active"""
	
	for i in range(current_team.size()):
		if current_team[i].get("id") == unit_id:
			current_team.remove_at(i)
			team_changed.emit()
			_save_team()
			return true
	
	return false

func recruit_unit(unit_id: String) -> bool:
	"""Recrute une unit√© (l'ajoute au roster)"""
	
	if roster.size() >= MAX_TEAM_SIZE:
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.notify("Roster complet (max " + str(MAX_TEAM_SIZE) + ")", "warning")
		return false
	
	# V√©rifier si d√©j√† recrut√©e
	for unit in roster:
		if unit.get("id") == unit_id:
			if GameRoot and GameRoot.event_bus:
				GameRoot.event_bus.notify("Unit√© d√©j√† recrut√©e", "warning")
			return false
	
	# Cr√©er l'instance depuis les donn√©es disponibles
	if not available_units.has(unit_id):
		push_error("[TeamManager] Unit√© introuvable : ", unit_id)
		return false
	
	var unit_template = available_units[unit_id]
	var new_unit = _create_unit_instance(unit_template)
	
	roster.append(new_unit)
	unit_recruited.emit(unit_id)
	_save_team()
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Recrut√© : " + new_unit.get("name"), "success")
	return true

func _create_unit_instance(template: Dictionary) -> Dictionary:
	"""Cr√©e une instance d'unit√© depuis un template"""
	
	var instance = template.duplicate(true)
	instance["instance_id"] = str(Time.get_ticks_msec())  # ID unique
	instance["level"] = 1
	instance["xp"] = 0
	instance["current_hp"] = instance.get("stats", {}).get("hp", 100)
	
	return instance

# ============================================================================
# GETTERS
# ============================================================================

func get_current_team() -> Array[Dictionary]:
	return current_team.duplicate()

func get_roster() -> Array[Dictionary]:
	return roster.duplicate()

func get_unit_by_id(unit_id: String) -> Dictionary:
	for unit in roster:
		if unit.get("id") == unit_id:
			return unit
	return {}

func is_team_full() -> bool:
	return current_team.size() >= 4

# ============================================================================
# XP & LEVEL UP
# ============================================================================

func add_xp(unit_id: String, xp_amount: int) -> void:
	"""Ajoute de l'XP √† une unit√©"""
	
	var unit = get_unit_by_id(unit_id)
	
	if unit.is_empty():
		return
	
	unit.xp += xp_amount
	
	# Check level up
	var xp_needed = _calculate_xp_for_level(unit.level + 1)
	
	if unit.xp >= xp_needed:
		_level_up(unit)

func _level_up(unit: Dictionary) -> void:
	"""Level up d'une unit√©"""
	
	unit.level += 1
	unit.xp = 0  # Reset XP
	
	# Augmenter les stats (exemple simple)
	var stats = unit.get("stats", {})
	stats.hp = int(stats.get("hp", 100) * 1.1)
	stats.attack = int(stats.get("attack", 20) * 1.1)
	stats.defense = int(stats.get("defense", 10) * 1.1)
	
	unit_leveled_up.emit(unit.get("id"), unit.level)
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify(unit.get("name") + " atteint le niveau " + str(unit.level) + " !", "success")
	
	_save_team()

func _calculate_xp_for_level(level: int) -> int:
	"""Calcul XP n√©cessaire pour un niveau"""
	return 100 * level  # Formule simple

# ============================================================================
# SAUVEGARDE / CHARGEMENT
# ============================================================================

func _save_team() -> void:
	"""Sauvegarde l'√©quipe"""
	
	var save_data = {
		"current_team": current_team,
		"roster": roster,
		"timestamp": Time.get_unix_time_from_system()
	}
	
	var file = FileAccess.open(TEAM_SAVE_PATH, FileAccess.WRITE)
	
	if not file:
		push_error("[TeamManager] Impossible de sauvegarder")
		return
	
	file.store_string(JSON.stringify(save_data, "\t"))
	file.close()
	
	print("[TeamManager] üíæ √âquipe sauvegard√©e")

func _load_team_from_save() -> void:
	"""Charge l'√©quipe depuis la sauvegarde"""
	
	if not FileAccess.file_exists(TEAM_SAVE_PATH):
		# Cr√©er une √©quipe par d√©faut
		_create_default_team()
		return
	
	var file = FileAccess.open(TEAM_SAVE_PATH, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) != OK:
		push_error("[TeamManager] Erreur de parsing de la sauvegarde")
		_create_default_team()
		return
	
	var data = json.data
	current_team.clear()
	for unit in data.get("current_team", []):
		current_team.append(unit as Dictionary)
	
	roster.clear()
	for unit in data.get("roster", []):
		roster.append(unit as Dictionary)
	
	print("[TeamManager] üìÇ √âquipe charg√©e depuis sauvegarde")

func _create_default_team() -> void:
	"""Cr√©e une √©quipe de d√©part"""
	
	print("[TeamManager] üÜï Cr√©ation √©quipe par d√©faut")
	
	# Recruter 2 unit√©s de base si disponibles
	if available_units.has("starter_knight"):
		recruit_unit("starter_knight")
		if roster.size() > 0:
			add_to_team(roster[0])
	
	if available_units.has("starter_mage"):
		recruit_unit("starter_mage")
		if roster.size() > 1:
			add_to_team(roster[1])
```

## core/autoloads/ui_manager.gd

```text
extends CanvasLayer
## UIManager - Gestion de l'interface utilisateur globale
## G√®re les notifications, l'√©cran de chargement, les menus globaux
## et la DialogueBox persistante (toujours en m√©moire)
##
## Acc√®s via : GameRoot.ui_manager

class_name UIManagerClass

# ============================================================================
# CONFIGURATION
# ============================================================================

const NOTIFICATION_DURATION: float = 3.0
const NOTIFICATION_FADE: float = 0.3
const MAX_NOTIFICATIONS: int = 5

# ============================================================================
# R√âF√âRENCES UI
# ============================================================================

var notification_container: VBoxContainer = null
var loading_screen: Control = null
var loading_progress_bar: ProgressBar = null
var loading_label: Label = null
var pause_menu: Control = null
var transition_overlay: ColorRect = null
var dialogue_box: DialogueBoxClass = null  # ‚Üê NOUVEAU : DialogueBox persistante

# ============================================================================
# √âTAT
# ============================================================================

var active_notifications: Array[Control] = []
var is_loading_visible: bool = false

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	layer = 90
	name = "UIManager"
	
	_create_transition_layer()
	_create_notification_system()
	_create_loading_screen()
	_create_pause_menu()
	_create_dialogue_box()  # ‚Üê NOUVEAU
	
	print("[UIManager] ‚úÖ Initialis√© (avec DialogueBox persistante)")

# ============================================================================
# DIALOGUE BOX PERSISTANTE
# ============================================================================

func _create_dialogue_box() -> void:
	"""Cr√©e la DialogueBox persistante accessible par DialogueManager"""
	
	# Charger depuis .tscn si disponible
	var dialogue_box_scene_path = "res://shared/ui/dialogue_box.tscn"
	
	if ResourceLoader.exists(dialogue_box_scene_path):
		var packed = load(dialogue_box_scene_path)
		dialogue_box = packed.instantiate() as DialogueBoxClass
		print("[UIManager]   ‚Üí DialogueBox charg√©e depuis .tscn")
	else:
		# Fallback : cr√©er programmatiquement
		dialogue_box = DialogueBoxClass.new()
		print("[UIManager]   ‚Üí DialogueBox cr√©√©e dynamiquement")
	
	dialogue_box.name = "PersistentDialogueBox"
	dialogue_box.visible = false
	dialogue_box.z_index = 60  # Au-dessus des sc√®nes, sous le pause menu
	add_child(dialogue_box)

func get_dialogue_box() -> DialogueBoxClass:
	"""Retourne la DialogueBox persistante"""
	return dialogue_box

func show_dialogue_box() -> void:
	"""Affiche la DialogueBox"""
	if dialogue_box:
		dialogue_box.show_dialogue_box()

func hide_dialogue_box() -> void:
	"""Cache la DialogueBox"""
	if dialogue_box:
		dialogue_box.hide_dialogue_box()

# ============================================================================
# TRANSITION LAYER
# ============================================================================

func _create_transition_layer() -> void:
	transition_overlay = ColorRect.new()
	transition_overlay.name = "TransitionOverlay"
	transition_overlay.color = Color.BLACK
	transition_overlay.set_anchors_preset(Control.PRESET_FULL_RECT)
	transition_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	transition_overlay.modulate.a = 0.0
	transition_overlay.z_index = 100
	add_child(transition_overlay)

# ============================================================================
# NOTIFICATIONS
# ============================================================================

func _create_notification_system() -> void:
	notification_container = VBoxContainer.new()
	notification_container.name = "NotificationContainer"
	notification_container.set_anchors_preset(Control.PRESET_TOP_RIGHT)
	notification_container.anchor_left = 1.0
	notification_container.anchor_right = 1.0
	notification_container.offset_left = -320
	notification_container.offset_top = 20
	notification_container.offset_right = -20
	notification_container.add_theme_constant_override("separation", 10)
	add_child(notification_container)

func _create_loading_screen() -> void:
	loading_screen = Control.new()
	loading_screen.name = "LoadingScreen"
	loading_screen.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.visible = false
	loading_screen.z_index = 50
	add_child(loading_screen)
	
	var bg = ColorRect.new()
	bg.color = Color(0.05, 0.05, 0.08, 0.95)
	bg.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.add_child(bg)
	
	var center = CenterContainer.new()
	center.set_anchors_preset(Control.PRESET_FULL_RECT)
	loading_screen.add_child(center)
	
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 20)
	center.add_child(vbox)
	
	loading_label = Label.new()
	loading_label.text = "Chargement..."
	loading_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	loading_label.add_theme_font_size_override("font_size", 32)
	vbox.add_child(loading_label)
	
	loading_progress_bar = ProgressBar.new()
	loading_progress_bar.custom_minimum_size = Vector2(400, 30)
	loading_progress_bar.value = 0
	vbox.add_child(loading_progress_bar)

func _create_pause_menu() -> void:
	pause_menu = Control.new()
	pause_menu.name = "PauseMenu"
	pause_menu.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.visible = false
	pause_menu.z_index = 80
	add_child(pause_menu)
	
	var bg = ColorRect.new()
	bg.color = Color(0, 0, 0, 0.7)
	bg.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.add_child(bg)
	
	var center = CenterContainer.new()
	center.set_anchors_preset(Control.PRESET_FULL_RECT)
	pause_menu.add_child(center)
	
	var panel = PanelContainer.new()
	center.add_child(panel)
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 40)
	margin.add_theme_constant_override("margin_top", 40)
	margin.add_theme_constant_override("margin_right", 40)
	margin.add_theme_constant_override("margin_bottom", 40)
	panel.add_child(margin)
	
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 15)
	margin.add_child(vbox)
	
	var title = Label.new()
	title.text = "PAUSE"
	title.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title.add_theme_font_size_override("font_size", 48)
	vbox.add_child(title)
	
	var resume_btn = Button.new()
	resume_btn.text = "Reprendre"
	resume_btn.custom_minimum_size = Vector2(200, 50)
	resume_btn.pressed.connect(_on_resume_pressed)
	vbox.add_child(resume_btn)
	
	var options_btn = Button.new()
	options_btn.text = "Options"
	options_btn.custom_minimum_size = Vector2(200, 50)
	options_btn.pressed.connect(_on_options_pressed)
	vbox.add_child(options_btn)
	
	var menu_btn = Button.new()
	menu_btn.text = "Menu Principal"
	menu_btn.custom_minimum_size = Vector2(200, 50)
	menu_btn.pressed.connect(_on_main_menu_pressed)
	vbox.add_child(menu_btn)
	
	var quit_btn = Button.new()
	quit_btn.text = "Quitter"
	quit_btn.custom_minimum_size = Vector2(200, 50)
	quit_btn.pressed.connect(_on_quit_pressed)
	vbox.add_child(quit_btn)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func create_transition_overlay() -> ColorRect:
	return transition_overlay

func show_notification(message: String, type: String = "info", duration: float = NOTIFICATION_DURATION) -> void:
	while active_notifications.size() >= MAX_NOTIFICATIONS:
		var oldest = active_notifications.pop_front()
		if oldest and is_instance_valid(oldest):
			oldest.queue_free()
	
	var notif = _create_notification_panel(message, type)
	notification_container.add_child(notif)
	active_notifications.append(notif)
	
	notif.modulate.a = 0.0
	notif.position.x = 50
	
	var tween = create_tween()
	tween.set_parallel(true)
	tween.tween_property(notif, "modulate:a", 1.0, NOTIFICATION_FADE)
	tween.tween_property(notif, "position:x", 0.0, NOTIFICATION_FADE)
	
	await get_tree().create_timer(duration).timeout
	
	if is_instance_valid(notif):
		var fade_tween = create_tween()
		fade_tween.tween_property(notif, "modulate:a", 0.0, NOTIFICATION_FADE)
		fade_tween.tween_callback(func():
			if is_instance_valid(notif):
				active_notifications.erase(notif)
				notif.queue_free()
		)

func _create_notification_panel(message: String, type: String) -> PanelContainer:
	var panel = PanelContainer.new()
	panel.custom_minimum_size = Vector2(300, 0)
	
	var style = StyleBoxFlat.new()
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	style.border_width_left = 4
	
	match type:
		"success":
			style.bg_color = Color(0.1, 0.3, 0.1, 0.95)
			style.border_color = Color(0.3, 0.8, 0.3)
		"warning":
			style.bg_color = Color(0.3, 0.25, 0.1, 0.95)
			style.border_color = Color(0.9, 0.7, 0.2)
		"error":
			style.bg_color = Color(0.3, 0.1, 0.1, 0.95)
			style.border_color = Color(0.9, 0.3, 0.3)
		_:
			style.bg_color = Color(0.1, 0.15, 0.25, 0.95)
			style.border_color = Color(0.4, 0.6, 0.9)
	
	panel.add_theme_stylebox_override("panel", style)
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 15)
	margin.add_theme_constant_override("margin_top", 10)
	margin.add_theme_constant_override("margin_right", 15)
	margin.add_theme_constant_override("margin_bottom", 10)
	panel.add_child(margin)
	
	var label = Label.new()
	label.text = message
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	margin.add_child(label)
	
	return panel

func show_loading(text: String = "Chargement...") -> void:
	loading_label.text = text
	loading_progress_bar.value = 0
	loading_screen.visible = true
	is_loading_visible = true

func hide_loading() -> void:
	loading_screen.visible = false
	is_loading_visible = false

func update_loading_progress(progress: float) -> void:
	loading_progress_bar.value = progress * 100

func show_pause_menu() -> void:
	pause_menu.visible = true

func hide_pause_menu() -> void:
	pause_menu.visible = false

func toggle_pause_menu() -> void:
	if pause_menu.visible:
		hide_pause_menu()
	else:
		show_pause_menu()

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_notification_posted(message: String, type: String) -> void:
	show_notification(message, type)

# ============================================================================
# CALLBACKS MENU PAUSE
# ============================================================================

func _on_resume_pressed() -> void:
	hide_pause_menu()
	if GameRoot and GameRoot.game_manager:
		GameRoot.game_manager.pause_game(false)

func _on_options_pressed() -> void:
	show_notification("Options (√† impl√©menter)", "info")

func _on_main_menu_pressed() -> void:
	hide_pause_menu()
	if GameRoot:
		if GameRoot.game_manager:
			GameRoot.game_manager.pause_game(false)
		if GameRoot.event_bus:
			GameRoot.event_bus.return_to_menu_requested.emit()

func _on_quit_pressed() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.quit_game_requested.emit()

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_cancel"):
		if GameRoot and GameRoot.game_manager:
			var current_id = GameRoot.game_manager.get_current_scene_id()
			if current_id != SceneRegistry.SceneID.MAIN_MENU:
				GameRoot.game_manager.toggle_pause()
				toggle_pause_menu()
```

## core/autoloads/version_manager.gd

```text
extends Node
class_name VersionManagerClass
## Gestion des versions de donn√©es et migrations
##
## Acc√®s via : GameRoot.version_manager

const CURRENT_VERSION = "1.0.0"
const VERSION_FILE = "user://version.json"

signal migration_started(from_version: String, to_version: String)
signal migration_completed(from_version: String, to_version: String)
signal migration_failed(from_version: String, to_version: String, error: String)

var migrations: Dictionary = {}  # "0.9.0" -> Callable

func _ready() -> void:
	_register_migrations()
	print("[VersionManager] ‚úÖ Initialis√© (version: %s)" % CURRENT_VERSION)

func _register_migrations() -> void:
	# Exemple de migration 0.9.0 -> 1.0.0
	register_migration("0.9.0", _migrate_0_9_to_1_0)

func register_migration(from_version: String, migration_func: Callable) -> void:
	migrations[from_version] = migration_func

func check_and_migrate() -> bool:
	var installed_version = _get_installed_version()
	
	if installed_version == CURRENT_VERSION:
		print("[VersionManager] ‚úÖ Version √† jour : ", CURRENT_VERSION)
		return true
	
	print("[VersionManager] üîÑ Migration n√©cessaire : ", installed_version, " -> ", CURRENT_VERSION)
	
	return migrate_from(installed_version)

func migrate_from(from_version: String) -> bool:
	if not migrations.has(from_version):
		# Pas de migration n√©cessaire, mettre √† jour la version
		_set_installed_version(CURRENT_VERSION)
		return true
	
	migration_started.emit(from_version, CURRENT_VERSION)
	
	var migration_func = migrations[from_version]
	var success = migration_func.call()
	
	if success:
		_set_installed_version(CURRENT_VERSION)
		migration_completed.emit(from_version, CURRENT_VERSION)
		print("[VersionManager] ‚úÖ Migration r√©ussie")
		return true
	else:
		migration_failed.emit(from_version, CURRENT_VERSION, "√âchec de la migration")
		return false

func _get_installed_version() -> String:
	if not FileAccess.file_exists(VERSION_FILE):
		return "0.0.0"
	
	var file = FileAccess.open(VERSION_FILE, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) == OK:
		return json.data.get("version", "0.0.0")
	
	return "0.0.0"

func _set_installed_version(version: String) -> void:
	var data = {"version": version, "timestamp": Time.get_unix_time_from_system()}
	
	var file = FileAccess.open(VERSION_FILE, FileAccess.WRITE)
	file.store_string(JSON.stringify(data, "\t"))
	file.close()

func get_current_version() -> String:
	return CURRENT_VERSION

func get_installed_version() -> String:
	return _get_installed_version()

# ============================================================================
# MIGRATIONS SP√âCIFIQUES
# ============================================================================

func _migrate_0_9_to_1_0() -> bool:
	print("[VersionManager] Migration 0.9.0 -> 1.0.0")
	
	var save_dir = "user://saves/"
	
	if not DirAccess.dir_exists_absolute(save_dir):
		return true  # Pas de sauvegardes
	
	var dir = DirAccess.open(save_dir)
	dir.list_dir_begin()
	
	var file_name = dir.get_next()
	while file_name != "":
		if file_name.ends_with(".save"):
			var full_path = save_dir + file_name
			_migrate_save_file(full_path)
		
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return true

func _migrate_save_file(path: String) -> void:
	var file = FileAccess.open(path, FileAccess.READ)
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	if json.parse(json_string) != OK:
		return
	
	var data = json.data
	data["version"] = "1.0.0"
	
	file = FileAccess.open(path, FileAccess.WRITE)
	file.store_string(JSON.stringify(data, "\t"))
	file.close()
```

## core/data/ability_data_loader.gd

```text
class_name AbilityDataLoader
extends Node
## Charge les donn√©es d'abilities depuis JSON
## Format: data/abilities/*.json

const ABILITIES_DIR = "res://data/abilities/"

var _json_loader: JSONDataLoader
var abilities: Dictionary = {}

func _init():
	_json_loader = JSONDataLoader.new()

func _ready() -> void:
	load_all_abilities()

func load_all_abilities() -> void:
	abilities = _json_loader.load_json_directory(ABILITIES_DIR, false)
	
	if abilities.is_empty():
		push_warning("No abilities loaded from " + ABILITIES_DIR)
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.data_load_warning.emit("abilities", "No data found")
	else:
		print("[AbilityDataLoader] Loaded %d abilities" % abilities.size())
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.data_loaded.emit("abilities", abilities)

func get_ability(ability_id: String) -> Dictionary:
	if abilities.has(ability_id):
		return abilities[ability_id]
	
	push_error("Ability not found: " + ability_id)
	return {}

func reload_ability(ability_id: String) -> void:
	var file_path = ABILITIES_DIR.path_join(ability_id + ".json")
	_json_loader.clear_cache(file_path)
	var data = _json_loader.load_json_file(file_path)
	
	if data:
		abilities[ability_id] = data
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.ability_reloaded.emit(ability_id)

## Valide les champs requis d'une ability
func validate_ability(data: Dictionary) -> bool:
	var required = ["id", "name", "type", "cost"]
	return _json_loader.validate_schema(data, required)
```

## core/data/json_data_loader.gd

```text
class_name JSONDataLoader
extends RefCounted
## Chargeur JSON g√©n√©rique avec validation et cache

signal data_loaded(data_type: String, data: Dictionary)
signal data_load_failed(data_type: String, error: String)

var _cache: Dictionary = {}
var _schema_validators: Dictionary = {}

## Charge un fichier JSON avec cache optionnel
func load_json_file(file_path: String, use_cache: bool = true) -> Variant:
	if use_cache and _cache.has(file_path):
		return _cache[file_path]
	
	if not FileAccess.file_exists(file_path):
		push_error("JSON file not found: " + file_path)
		return null
	
	var file = FileAccess.open(file_path, FileAccess.READ)
	if not file:
		push_error("Failed to open JSON file: " + file_path)
		return null
	
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	var parse_result = json.parse(json_string)
	
	if parse_result != OK:
		var error_msg = "JSON parse error at line %d: %s" % [json.get_error_line(), json.get_error_message()]
		push_error(error_msg)
		return null
	
	var data = json.data
	
	if use_cache:
		_cache[file_path] = data
	
	return data

## Charge tous les fichiers JSON d'un dossier
func load_json_directory(dir_path: String, recursive: bool = false) -> Dictionary:
	var result = {}
	var dir = DirAccess.open(dir_path)
	
	if not dir:
		push_error("Failed to open directory: " + dir_path)
		return result
	
	dir.list_dir_begin()
	var file_name = dir.get_next()
	
	while file_name != "":
		if file_name.begins_with("."):
			file_name = dir.get_next()
			continue
		
		var full_path = dir_path.path_join(file_name)
		
		if dir.current_is_dir():
			if recursive:
				var subdir_data = load_json_directory(full_path, true)
				result[file_name] = subdir_data
		elif file_name.ends_with(".json"):
			var data = load_json_file(full_path)
			if data != null:
				var key = file_name.get_basename()
				result[key] = data
		
		file_name = dir.get_next()
	
	dir.list_dir_end()
	return result

## Valide la structure d'un objet JSON selon un sch√©ma basique
func validate_schema(data: Dictionary, required_fields: Array) -> bool:
	for field in required_fields:
		if not data.has(field):
			push_error("Missing required field: " + field)
			return false
	return true

## Charge et valide un fichier avec sch√©ma
func load_validated_json(file_path: String, required_fields: Array = []) -> Variant:
	var data = load_json_file(file_path)
	
	if data == null:
		return null
	
	if data is Dictionary and required_fields.size() > 0:
		if not validate_schema(data, required_fields):
			return null
	
	return data

## Nettoie le cache (utile pour rechargement √† chaud)
func clear_cache(file_path: String = "") -> void:
	if file_path.is_empty():
		_cache.clear()
	else:
		_cache.erase(file_path)

## Sauvegarde des donn√©es en JSON (pour √©diteurs/outils)
func save_json_file(file_path: String, data: Variant) -> bool:
	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if not file:
		push_error("Failed to save JSON file: " + file_path)
		return false
	
	var json_string = JSON.stringify(data, "\t")
	file.store_string(json_string)
	file.close()
	return true
```

## core/data/model_validator.gd

```text
extends Node
class_name ModelValidator
## Validateur de mod√®les de donn√©es JSON

static var _models: Dictionary = {}

# ======================================================
# PUBLIC API
# ======================================================

static func validate(data: Variant, model_id: String) -> ValidationResult:
	var result := ValidationResult.new()
	var model := _load_model(model_id)

	if model.is_empty():
		result.add_error("Model not found: %s" % model_id)
		return result

	_validate_value(data, model, "", result)

	result.data = data
	return result


# ======================================================
# MODEL LOADING
# ======================================================

static func _load_model(model_id: String) -> Dictionary:
	if _models.has(model_id):
		return _models[model_id]

	var path := "res://data/models/%s_model.json" % model_id
	if not FileAccess.file_exists(path):
		push_error("[ModelValidator] Model file not found: " + path)
		return {}

	var file := FileAccess.open(path, FileAccess.READ)
	var parsed = JSON.parse_string(file.get_as_text())
	file.close()

	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("[ModelValidator] Invalid model format: " + model_id)
		return {}

	_models[model_id] = parsed
	return parsed


# ======================================================
# CORE VALIDATION
# ======================================================

static func _validate_value(value: Variant, model: Dictionary, path: String, result: ValidationResult) -> void:
	match model.get("type"):
		"object":
			_validate_object(value, model, path, result)

		"array":
			_validate_array(value, model, path, result)

		"vector2i":
			_validate_vector2i(value, path, result)

		_:
			result.add_error("%s: Unknown model type" % path)


# ======================================================
# OBJECT
# ======================================================

static func _validate_object(value, model, path, result):
	if typeof(value) != TYPE_DICTIONARY:
		result.add_error("%s must be an object" % path)
		return

	var fields: Dictionary = model.get("fields", {})

	for field_name in fields.keys():
		var rule = fields[field_name]
		var field_path = field_name if path == "" else "%s.%s" % [path, field_name]

		if rule.get("required", false) and not value.has(field_name):
			result.add_error("Missing field: %s" % field_path)
			continue

		if not value.has(field_name):
			continue

		_validate_field(value, field_name, rule, field_path, result)


# ======================================================
# ARRAY
# ======================================================

static func _validate_array(value, model, path, result):
	if typeof(value) != TYPE_ARRAY:
		result.add_error("%s must be an array" % path)
		return

	var item_model_id = model.get("items", {}).get("model", "")
	if item_model_id == "":
		return

	var item_model = _load_model(item_model_id)

	for i in range(value.size()):
		var item_path = "%s[%d]" % [path, i]
		_validate_value(value[i], item_model, item_path, result)


# ======================================================
# VECTOR2I
# ======================================================

static func _validate_vector2i(value, path, result):
	if typeof(value) != TYPE_DICTIONARY or not value.has("x") or not value.has("y"):
		result.add_error("%s must be a Vector2i-like object" % path)
		return

	value.x = int(value.x)
	value.y = int(value.y)


# ======================================================
# FIELD
# ======================================================

static func _validate_field(obj, key, rule, path, result):
	var v = obj[key]

	match rule.get("type"):
		"string":
			if typeof(v) != TYPE_STRING:
				result.add_error("%s must be a string" % path)

		"number":
			if typeof(v) != TYPE_FLOAT and typeof(v) != TYPE_INT:
				result.add_error("%s must be a number" % path)
				return

			if rule.get("integer", false) and typeof(v) == TYPE_FLOAT and v != int(v):
				result.add_error("%s must be an integer (got %s)" % [path, v])

			if rule.has("min") and v < rule.min:
				result.add_error("%s < min (%s)" % [path, rule.min])

			if rule.has("max") and v > rule.max:
				result.add_error("%s > max (%s)" % [path, rule.max])

			if rule.get("normalize") == "int":
				obj[key] = int(v)

		"object":
			var sub_model = rule.get("model", "")
			if sub_model != "":
				_validate_value(v, _load_model(sub_model), path, result)

		"array":
			if typeof(v) != TYPE_ARRAY:
				result.add_error("%s must be an array" % path)
				return
			
			var item_rule = rule.get("items", {})
			if not item_rule.is_empty():
				for i in range(v.size()):
					var item_path = "%s[%d]" % [path, i]
					if item_rule.has("model"):
						var item_model = _load_model(item_rule.model)
						_validate_value(v[i], item_model, item_path, result)

		"boolean":
			if typeof(v) != TYPE_BOOL:
				result.add_error("%s must be a boolean" % path)

# ======================================================
# CACHE MANAGEMENT
# ======================================================

static func clear_cache() -> void:
	"""Vide le cache des mod√®les"""
	_models.clear()

static func reload_model(model_id: String) -> void:
	"""Recharge un mod√®le sp√©cifique"""
	_models.erase(model_id)
	_load_model(model_id)
```

## core/data/scene_registry.gd

```text
extends Node
## SceneRegistry - Registre centralis√© de toutes les sc√®nes du jeu
## Permet un acc√®s d√©coupl√© aux chemins de sc√®nes
##
## NOTE : INTRO_DIALOGUE a √©t√© retir√© car la s√©quence d'intro
## est maintenant g√©r√©e par CampaignManager + DialogueManager + UIManager
## sans sc√®ne d√©di√©e.

class_name SceneRegistry

enum SceneID {
	# Menus
	MAIN_MENU,
	OPTIONS_MENU,
	PAUSE_MENU,
	SAVE_LOAD_MENU,
	
	# Monde
	WORLD_MAP,
	TOWN,
	CASTLE,
	
	# Combat
	BATTLE,
	BATTLE_PREPARATION,
	BATTLE_RESULTS,
	
	# Narration
	CUTSCENE,
	DIALOGUE,
	
	# Syst√®me
	LOADING_SCREEN,
	CREDITS,
}

const SCENE_PATHS: Dictionary = {
	# Menus
	SceneID.MAIN_MENU: "res://features/menu/main_menu.tscn",
	SceneID.OPTIONS_MENU: "res://features/menu/options_menu.tscn",
	SceneID.PAUSE_MENU: "res://features/menu/pause_menu.tscn",
	SceneID.SAVE_LOAD_MENU: "res://features/menu/save_load_menu.tscn",
	
	# Monde
	SceneID.WORLD_MAP: "res://features/world_map/visuals/world_map.tscn",
	SceneID.TOWN: "res://features/world_map/visuals/town.tscn",
	SceneID.CASTLE: "res://features/world_map/visuals/castle.tscn",
	
	# Combat
	SceneID.BATTLE: "res://features/combat/visuals/battle_3d.tscn",
	SceneID.BATTLE_PREPARATION: "res://features/combat/visuals/battle_preparation.tscn",
	SceneID.BATTLE_RESULTS: "res://features/Duo/ui/battle_results.tscn",
	
	# Narration
	SceneID.CUTSCENE: "res://features/narrative/cutscene.tscn",
	SceneID.DIALOGUE: "res://features/narrative/dialogue.tscn",
	
	# Syst√®me
	SceneID.LOADING_SCREEN: "res://shared/system/loading_screen.tscn",
	SceneID.CREDITS: "res://shared/credits/credits.tscn",
}

const SCENE_METADATA: Dictionary = {
	SceneID.MAIN_MENU: {
		"category": "menu",
		"requires_save": false,
		"pausable": false,
	},
	SceneID.WORLD_MAP: {
		"category": "world",
		"requires_save": true,
		"pausable": true,
		"music": "res://audio/music/world_theme.ogg",
	},
	SceneID.BATTLE: {
		"category": "battle",
		"requires_save": true,
		"pausable": true,
		"music": "res://audio/music/battle_theme.ogg",
	},
}

static func get_scene_path(scene_id: SceneID) -> String:
	if SCENE_PATHS.has(scene_id):
		return SCENE_PATHS[scene_id]
	push_error("[SceneRegistry] SceneID introuvable : ", scene_id)
	return ""

static func get_scene_metadata(scene_id: SceneID) -> Dictionary:
	if SCENE_METADATA.has(scene_id):
		return SCENE_METADATA[scene_id]
	return {}

static func scene_exists(scene_id: SceneID) -> bool:
	var path = get_scene_path(scene_id)
	return path != "" and ResourceLoader.exists(path)

static func get_scenes_by_category(category: String) -> Array[SceneID]:
	var result: Array[SceneID] = []
	for scene_id in SCENE_METADATA:
		var metadata = SCENE_METADATA[scene_id]
		if metadata.get("category") == category:
			result.append(scene_id)
	return result

static func get_scene_name(scene_id: SceneID) -> String:
	var scene_names = {
		SceneID.MAIN_MENU: "Menu Principal",
		SceneID.OPTIONS_MENU: "Options",
		SceneID.PAUSE_MENU: "Pause",
		SceneID.SAVE_LOAD_MENU: "Sauvegarder/Charger",
		SceneID.WORLD_MAP: "Carte du Monde",
		SceneID.TOWN: "Ville",
		SceneID.CASTLE: "Ch√¢teau",
		SceneID.BATTLE: "Combat",
		SceneID.BATTLE_PREPARATION: "Pr√©paration Combat",
		SceneID.BATTLE_RESULTS: "R√©sultats Combat",
		SceneID.CUTSCENE: "Cin√©matique",
		SceneID.DIALOGUE: "Dialogue",
		SceneID.LOADING_SCREEN: "Chargement",
		SceneID.CREDITS: "Cr√©dits",
	}
	return scene_names.get(scene_id, "Inconnu")

static func validate_registry() -> bool:
	var all_valid = true
	for scene_id in SCENE_PATHS:
		var path = SCENE_PATHS[scene_id]
		if not ResourceLoader.exists(path):
			push_warning("[SceneRegistry] Sc√®ne manquante : ", get_scene_name(scene_id), " (", path, ")")
			all_valid = false
	return all_valid
```

## core/data/validation_result.gd

```text
extends RefCounted
class_name ValidationResult
## R√©sultat d'une validation de donn√©es

var is_valid: bool = true
var errors: Array[String] = []
var data: Variant = null

func add_error(message: String) -> void:
	"""Ajoute une erreur et marque le r√©sultat comme invalide"""
	errors.append(message)
	is_valid = false

func has_errors() -> bool:
	"""V√©rifie si des erreurs sont pr√©sentes"""
	return not errors.is_empty()

func get_errors_string() -> String:
	"""Retourne toutes les erreurs en une seule cha√Æne"""
	return "\n".join(errors)

func clear() -> void:
	"""R√©initialise le r√©sultat"""
	is_valid = true
	errors.clear()
	data = null
```

## core/dialogue/bark_system.gd

```text
extends Node
class_name BarkSystem
## Syst√®me de "barks" - messages courts au-dessus des personnages

signal bark_shown(speaker: String, text: String)
signal bark_hidden(speaker: String)

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var default_duration: float = 2.0
@export var fade_duration: float = 0.3
@export var max_barks: int = 5
@export var bark_offset: Vector2 = Vector2(0, -50)

# ============================================================================
# √âTAT
# ============================================================================

var active_barks: Dictionary = {}  # speaker -> BarkLabel
var bark_container: CanvasLayer = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_create_bark_container()
	print("[BarkSystem] ‚úÖ Initialis√©")

func _create_bark_container() -> void:
	"""Cr√©e le conteneur pour les barks"""
	bark_container = CanvasLayer.new()
	bark_container.layer = 50
	bark_container.name = "BarkContainer"
	add_child(bark_container)

# ============================================================================
# API PUBLIQUE
# ============================================================================

func show_bark(speaker: String, text: String, world_position: Vector2, duration: float = -1.0) -> void:
	"""Affiche un bark au-dessus d'une position"""
	
	if duration < 0:
		duration = default_duration
	
	# Supprimer le bark existant pour ce speaker
	if active_barks.has(speaker):
		_remove_bark(speaker)
	
	# Limiter le nombre de barks
	while active_barks.size() >= max_barks:
		var oldest = active_barks.keys()[0]
		_remove_bark(oldest)
	
	# Cr√©er le nouveau bark
	var bark_label = _create_bark_label(text, world_position)
	active_barks[speaker] = bark_label
	bark_container.add_child(bark_label)
	
	# Animation d'apparition
	bark_label.modulate.a = 0.0
	var tween = create_tween()
	tween.tween_property(bark_label, "modulate:a", 1.0, fade_duration)
	
	bark_shown.emit(speaker, text)
	
	# Timer de disparition
	await get_tree().create_timer(duration).timeout
	
	if active_barks.has(speaker) and is_instance_valid(active_barks[speaker]):
		_fade_out_bark(speaker)

func hide_bark(speaker: String) -> void:
	"""Cache imm√©diatement un bark"""
	_remove_bark(speaker)

func hide_all_barks() -> void:
	"""Cache tous les barks"""
	for speaker in active_barks.keys():
		_remove_bark(speaker)

# ============================================================================
# CR√âATION UI
# ============================================================================

func _create_bark_label(text: String, world_position: Vector2) -> PanelContainer:
	"""Cr√©e un label de bark stylis√©"""
	
	var panel = PanelContainer.new()
	
	# Style du panel
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.1, 0.1, 0.15, 0.9)
	style.border_width_left = 2
	style.border_width_top = 2
	style.border_width_right = 2
	style.border_width_bottom = 2
	style.border_color = Color(0.5, 0.5, 0.6)
	style.corner_radius_top_left = 8
	style.corner_radius_top_right = 8
	style.corner_radius_bottom_left = 8
	style.corner_radius_bottom_right = 8
	style.content_margin_left = 10
	style.content_margin_top = 5
	style.content_margin_right = 10
	style.content_margin_bottom = 5
	panel.add_theme_stylebox_override("panel", style)
	
	# Label
	var label = Label.new()
	label.text = text
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	label.custom_minimum_size = Vector2(50, 0)
	panel.add_child(label)
	
	# Position (convertir world √† screen si n√©cessaire)
	panel.position = world_position + bark_offset
	
	return panel

func _fade_out_bark(speaker: String) -> void:
	"""Fait dispara√Ætre un bark avec animation"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	if not is_instance_valid(bark):
		active_barks.erase(speaker)
		return
	
	var tween = create_tween()
	tween.tween_property(bark, "modulate:a", 0.0, fade_duration)
	tween.tween_callback(func(): _remove_bark(speaker))

func _remove_bark(speaker: String) -> void:
	"""Supprime un bark"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	active_barks.erase(speaker)
	
	if is_instance_valid(bark):
		bark.queue_free()
	
	bark_hidden.emit(speaker)

# ============================================================================
# MISE √Ä JOUR POSITION
# ============================================================================

func update_bark_position(speaker: String, world_position: Vector2) -> void:
	"""Met √† jour la position d'un bark (pour suivre un personnage)"""
	
	if not active_barks.has(speaker):
		return
	
	var bark = active_barks[speaker]
	if is_instance_valid(bark):
		bark.position = world_position + bark_offset
```

## core/dialogue/dialogue_box.gd

```text
extends Control
class_name DialogueBoxClass
## Bo√Æte de dialogue UI - √† √©tendre ou utiliser directement

# ============================================================================
# SIGNAUX
# ============================================================================

signal text_reveal_completed()
signal choice_selected(index: int)
signal dialogue_box_shown()
signal dialogue_box_hidden()

# ============================================================================
# R√âF√âRENCES (√† connecter dans l'inspecteur ou via code)
# ============================================================================

@export var speaker_label: Label
@export var text_label: RichTextLabel
@export var portrait_texture: TextureRect
@export var choices_container: VBoxContainer
@export var continue_indicator: Control

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var typewriter_speed: float = 50.0  # Caract√®res par seconde
@export var show_continue_indicator: bool = true
@export var auto_size: bool = true

# ============================================================================
# √âTAT
# ============================================================================

var dialogue_manager = null  # R√©f√©rence au DialogueManager
var is_text_revealing: bool = false
var current_text: String = ""
var revealed_characters: int = 0
var _typewriter_timer: float = 0.0

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# Cr√©er l'UI si pas de r√©f√©rences
	if not speaker_label or not text_label:
		_create_default_ui()
	
	# Cacher par d√©faut
	visible = false
	
	if continue_indicator:
		continue_indicator.visible = false

func _create_default_ui() -> void:
	"""Cr√©e une UI de dialogue par d√©faut"""
	
	# Panel principal
	var panel = PanelContainer.new()
	panel.set_anchors_preset(Control.PRESET_BOTTOM_WIDE)
	panel.anchor_top = 0.7
	panel.offset_top = 0
	panel.offset_bottom = -20
	panel.offset_left = 20
	panel.offset_right = -20
	add_child(panel)
	
	# Style
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.08, 0.08, 0.12, 0.95)
	style.border_width_left = 3
	style.border_width_top = 3
	style.border_width_right = 3
	style.border_width_bottom = 3
	style.border_color = Color(0.4, 0.4, 0.6)
	style.corner_radius_top_left = 12
	style.corner_radius_top_right = 12
	style.corner_radius_bottom_left = 12
	style.corner_radius_bottom_right = 12
	panel.add_theme_stylebox_override("panel", style)
	
	# Margin
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 20)
	margin.add_theme_constant_override("margin_top", 15)
	margin.add_theme_constant_override("margin_right", 20)
	margin.add_theme_constant_override("margin_bottom", 15)
	panel.add_child(margin)
	
	# VBox
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 10)
	margin.add_child(vbox)
	
	# Speaker
	speaker_label = Label.new()
	speaker_label.add_theme_font_size_override("font_size", 24)
	speaker_label.add_theme_color_override("font_color", Color(0.9, 0.8, 0.5))
	vbox.add_child(speaker_label)
	
	# Text
	text_label = RichTextLabel.new()
	text_label.bbcode_enabled = true
	text_label.fit_content = true
	text_label.scroll_active = false
	text_label.size_flags_vertical = Control.SIZE_EXPAND_FILL
	text_label.add_theme_font_size_override("normal_font_size", 20)
	vbox.add_child(text_label)
	
	# Choices container
	choices_container = VBoxContainer.new()
	choices_container.add_theme_constant_override("separation", 8)
	choices_container.visible = false
	vbox.add_child(choices_container)
	
	# Continue indicator
	continue_indicator = Label.new()
	continue_indicator.text = "‚ñº"
	continue_indicator.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	continue_indicator.visible = false
	vbox.add_child(continue_indicator)

# ============================================================================
# AFFICHAGE
# ============================================================================

func show_dialogue_box() -> void:
	"""Affiche la bo√Æte de dialogue"""
	visible = true
	dialogue_box_shown.emit()

func hide_dialogue_box() -> void:
	"""Cache la bo√Æte de dialogue"""
	visible = false
	is_text_revealing = false
	dialogue_box_hidden.emit()

func display_line(line: Dictionary) -> void:
	"""Affiche une ligne de dialogue"""
	
	# Speaker
	var speaker = line.get("speaker", "")
	if speaker_label:
		speaker_label.text = speaker
		speaker_label.visible = speaker != ""
	
	# Portrait
	if portrait_texture and line.has("portrait"):
		var portrait_path = line.get("portrait", "")
		if portrait_path != "" and ResourceLoader.exists(portrait_path):
			portrait_texture.texture = load(portrait_path)
			portrait_texture.visible = true
		else:
			portrait_texture.visible = false
	
	# Texte
	var text = line.get("text", "")
	var text_key = line.get("text_key", "")
	
	if text_key != "":
		text = tr(text_key)
	
	current_text = text
	
	# Cacher les choix
	if choices_container:
		choices_container.visible = false
		_clear_choices()
	
	# Cacher l'indicateur de continuation
	if continue_indicator:
		continue_indicator.visible = false
	
	# D√©marrer le typewriter
	var speed = line.get("speed", typewriter_speed)
	_start_typewriter(text, speed)

func display_choices(choices: Array) -> void:
	"""Affiche les choix"""
	
	if not choices_container:
		return
	
	_clear_choices()
	
	for i in range(choices.size()):
		var choice = choices[i]
		var button = Button.new()
		
		var choice_text = choice.get("text", "")
		var choice_key = choice.get("text_key", "")
		
		if choice_key != "":
			choice_text = tr(choice_key)
		
		button.text = choice_text
		button.custom_minimum_size = Vector2(0, 40)
		button.pressed.connect(func(): _on_choice_pressed(i))
		
		choices_container.add_child(button)
	
	choices_container.visible = true

func _clear_choices() -> void:
	"""Supprime tous les boutons de choix"""
	if choices_container:
		for child in choices_container.get_children():
			child.queue_free()

func _on_choice_pressed(index: int) -> void:
	"""Callback quand un choix est s√©lectionn√©"""
	choice_selected.emit(index)
	
	if dialogue_manager:
		dialogue_manager.select_choice(index)

# ============================================================================
# TYPEWRITER
# ============================================================================

func _start_typewriter(text: String, speed: float) -> void:
	"""D√©marre l'effet typewriter"""
	
	current_text = text
	revealed_characters = 0
	is_text_revealing = true
	typewriter_speed = speed
	_typewriter_timer = 0.0
	
	if text_label:
		text_label.text = ""

func _process(delta: float) -> void:
	if not is_text_revealing:
		return
	
	_typewriter_timer += delta * typewriter_speed
	
	var chars_to_show = int(_typewriter_timer)
	
	if chars_to_show > revealed_characters:
		revealed_characters = chars_to_show
		
		if text_label:
			if revealed_characters >= current_text.length():
				text_label.text = current_text
				complete_text()
			else:
				text_label.text = current_text.substr(0, revealed_characters)

func complete_text() -> void:
	"""Compl√®te imm√©diatement le texte"""
	
	if text_label:
		text_label.text = current_text
	
	revealed_characters = current_text.length()
	is_text_revealing = false
	
	# Afficher l'indicateur de continuation
	if continue_indicator and show_continue_indicator:
		continue_indicator.visible = true
	
	text_reveal_completed.emit()

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	if not visible:
		return
	
	# Avancer le dialogue
	if event.is_action_pressed("ui_accept") or event.is_action_pressed("ui_select"):
		if dialogue_manager:
			dialogue_manager.advance_dialogue()
		get_viewport().set_input_as_handled()
```

## core/dialogue/dialogue_box.tscn

```text
[gd_scene load_steps=3 format=3 uid="uid://byp8xytm75beo"]

[ext_resource type="Script" uid="uid://d0bmm781h8rqb" path="res://core/dialogue/dialogue_box.gd" id="1_fd1y2"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_panel"]
bg_color = Color(0.1, 0.1, 0.12, 0.95)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.7, 0.7, 0.8, 1)
corner_radius_top_left = 12
corner_radius_top_right = 12
corner_radius_bottom_right = 12
corner_radius_bottom_left = 12

[node name="DialogueBox" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_fd1y2")

[node name="DialoguePanel" type="PanelContainer" parent="."]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -700.0
offset_top = -250.0
offset_right = 700.0
offset_bottom = -50.0
grow_horizontal = 2
grow_vertical = 0
theme_override_styles/panel = SubResource("StyleBoxFlat_panel")

[node name="MarginContainer" type="MarginContainer" parent="DialoguePanel"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="HBoxContainer" type="HBoxContainer" parent="DialoguePanel/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="Portrait" type="TextureRect" parent="DialoguePanel/MarginContainer/HBoxContainer"]
custom_minimum_size = Vector2(128, 128)
layout_mode = 2
size_flags_vertical = 0
expand_mode = 1
stretch_mode = 5

[node name="VBoxContainer" type="VBoxContainer" parent="DialoguePanel/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="SpeakerLabel" type="Label" parent="DialoguePanel/MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.85, 0.5, 1)
theme_override_font_sizes/font_size = 24
text = "Speaker Name"

[node name="TextLabel" type="RichTextLabel" parent="DialoguePanel/MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Dialogue text goes here..."
fit_content = true
scroll_active = false

[node name="ChoicesContainer" type="VBoxContainer" parent="DialoguePanel/MarginContainer/VBoxContainer"]
visible = false
layout_mode = 2
theme_override_constants/separation = 10

[node name="ContinueIndicator" type="Label" parent="DialoguePanel"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 1, 0.5, 1)
text = "‚ñº Appuyez"
horizontal_alignment = 2
vertical_alignment = 2

[node name="VoicePlayer" type="AudioStreamPlayer" parent="."]

[node name="AdvanceSFX" type="AudioStreamPlayer" parent="."]
```

## core/dialogue/dialogue_data.gd

```text
extends Resource
class_name DialogueData
## Structure de donn√©es pour un dialogue

@export var dialogue_id: String = ""
@export var lines: Array[Dictionary] = []
@export var metadata: Dictionary = {}

## Structure d'une ligne de dialogue :
## {
##   "speaker": "nom_du_personnage",
##   "text": "Texte du dialogue",
##   "text_key": "DIALOGUE_KEY",  # Cl√© de traduction (optionnel)
##   "portrait": "res://path/to/portrait.png",  # (optionnel)
##   "emotion": "happy",  # (optionnel)
##   "speed": 50.0,  # Vitesse du texte (optionnel)
##   "auto_advance": false,  # Auto-avance (optionnel)
##   "auto_delay": 2.0,  # D√©lai avant auto-avance (optionnel)
##   "choices": [],  # Choix possibles (optionnel)
##   "event": {},  # √âv√©nement √† d√©clencher (optionnel)
## }

func _init(id: String = "", dialogue_lines: Array = []) -> void:
	dialogue_id = id
	for line in dialogue_lines:
		lines.append(line)

func add_line(line_data: Dictionary) -> void:
	"""Ajoute une ligne de dialogue"""
	lines.append(line_data)

func get_line(index: int) -> Dictionary:
	"""R√©cup√®re une ligne par son index"""
	if index >= 0 and index < lines.size():
		return lines[index]
	return {}

func get_line_count() -> int:
	"""Retourne le nombre de lignes"""
	return lines.size()

## Cr√©e un DialogueData depuis un dictionnaire JSON
static func from_dict(data: Dictionary) -> DialogueData:
	var dialogue = DialogueData.new()
	dialogue.dialogue_id = data.get("dialogue_id", "")
	dialogue.metadata = data.get("metadata", {})
	
	var raw_lines = data.get("lines", [])
	for line in raw_lines:
		dialogue.lines.append(line)
	
	return dialogue

## Convertit en dictionnaire pour sauvegarde
func to_dict() -> Dictionary:
	return {
		"dialogue_id": dialogue_id,
		"lines": lines,
		"metadata": metadata
	}
```

## core/dialogue/dialogue_data_loader.gd

```text
# addons/core/data/dialogue_data_loader.gd

extends Node
class_name DialogueDataLoader
const DIALOGUES_DIR = "res://data/dialogues/"

var _json_loader: JSONDataLoader
var dialogues: Dictionary = {}

func _init():
	_json_loader = JSONDataLoader.new()

func load_all_dialogues() -> void:
	dialogues = _json_loader.load_json_directory(DIALOGUES_DIR, true)
	
	if dialogues.is_empty():
		push_warning("No dialogues loaded")
	else:
		print("Loaded %d dialogue sets" % dialogues.size())
		GameRoot.event_bus.emit_signal("data_loaded", "dialogues", dialogues)

# ‚úÖ NOUVELLE M√âTHODE : Charge un dialogue sp√©cifique
func load_dialogue(dialogue_id: String) -> Dictionary:
	"""
	Charge un dialogue depuis un fichier JSON
	
	@param dialogue_id : ID du dialogue (nom du fichier sans .json)
	@return Dictionary contenant le dialogue, ou {} si introuvable
	"""
	var file_path = DIALOGUES_DIR.path_join(dialogue_id + ".json")
	
	if not FileAccess.file_exists(file_path):
		push_error("[DialogueDataLoader] Fichier introuvable : ", file_path)
		return {}
	
	var data = _json_loader.load_json_file(file_path)
	
	if typeof(data) != TYPE_DICTIONARY or data.is_empty():
		push_error("[DialogueDataLoader] Format invalide pour : ", dialogue_id)
		return {}
	
	# Stocker en cache
	dialogues[dialogue_id] = data
	
	return data

func get_dialogue(dialogue_id: String) -> Dictionary:
	# V√©rifier le cache d'abord
	if dialogues.has(dialogue_id):
		return dialogues[dialogue_id]
	
	# Sinon, charger depuis le fichier
	return load_dialogue(dialogue_id)

func get_dialogue_node(dialogue_id: String, node_id: String) -> Dictionary:
	var dialogue = get_dialogue(dialogue_id)
	if dialogue.has("nodes") and dialogue.nodes.has(node_id):
		return dialogue.nodes[node_id]
	return {}

func reload_dialogue(dialogue_id: String) -> void:
	var file_path = DIALOGUES_DIR.path_join(dialogue_id + ".json")
	_json_loader.clear_cache(file_path)
	var data = load_dialogue(dialogue_id)
	
	if not data.is_empty():
		GameRoot.event_bus.emit_signal("dialogue_reloaded", dialogue_id)
```

## core/game_root.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://gameroot001"]

[ext_resource type="Script" path="res://core/autoloads/game_root.gd" id="1_gameroot"]

[node name="GameRoot" type="Node"]
script = ExtResource("1_gameroot")

[node name="SceneContainer" type="Node" parent="."]
```

## features/combat/logic/action_module_3d.gd

```text
extends Node
## ActionModule3D - G√®re toutes les actions de combat en 3D

class_name ActionModule3D

signal action_executed(attacker: BattleUnit3D, target: BattleUnit3D, action_type: String)
signal damage_dealt(target: BattleUnit3D, damage: int)

var unit_manager: UnitManager3D
var terrain: TerrainModule3D
var ring_system: RingSystem

const ATTACK_COLOR: Color = Color(1.0, 0.3, 0.3, 0.5)

# ============================================================================
# VALIDATION
# ============================================================================

func can_attack(attacker: BattleUnit3D, target: BattleUnit3D) -> bool:
	if not attacker.can_act():
		return false
	if not target.is_alive():
		return false
	if attacker.is_player_unit == target.is_player_unit:
		return false
	
	var distance = terrain.get_distance(attacker.grid_position, target.grid_position)
	return distance <= attacker.attack_range

func get_attack_positions(unit: BattleUnit3D) -> Array[Vector2i]:
	"""Retourne toutes les positions attaquables"""
	var positions: Array[Vector2i] = []
	var range = unit.attack_range
	
	for dy in range(-range, range + 1):
		for dx in range(-range, range + 1):
			if dx == 0 and dy == 0:
				continue
			
			var manhattan = abs(dx) + abs(dy)
			if manhattan > range:
				continue
			
			var pos = unit.grid_position + Vector2i(dx, dy)
			if terrain.is_in_bounds(pos):
				positions.append(pos)
	
	return positions

# ============================================================================
# ACTIONS DE COMBAT
# ============================================================================

func execute_attack(attacker: BattleUnit3D, target: BattleUnit3D, duo_partner: BattleUnit3D = null) -> void:
	if not can_attack(attacker, target):
		return
	
	var is_duo_attack = duo_partner != null
	
	if is_duo_attack:
		print("[ActionModule3D] ‚öîÔ∏è ATTAQUE EN DUO")
		
		# ‚úÖ NOUVEAU : Afficher l'aura sur les deux unit√©s
		var is_enemy_duo = not attacker.is_player_unit
		attacker.show_duo_aura(is_enemy_duo)
		duo_partner.show_duo_aura(is_enemy_duo)
		
		# Attendre un peu pour que l'aura soit visible
		await attacker.get_tree().create_timer(0.5).timeout
	
	await _animate_attack_3d(attacker, target)

	if is_duo_attack and duo_partner:
		var mana_cost = 20  # TODO: Ajuster selon le ring de canalisation
		
		if not duo_partner.consume_mana(mana_cost):
			GameRoot.event_bus.notify("‚ùå Mana insuffisant pour le duo", "error")
			GameRoot.global_logger.warning("ACTION", "%s : mana insuffisant" % duo_partner.unit_name)
			return
		
		GameRoot.global_logger.info("ACTION", "%s (support) consomme %d mana" % [
			duo_partner.unit_name,
			mana_cost
		])

	var damage = calculate_damage(attacker, target)
	
	# Bonus de duo
	if is_duo_attack:
		damage = int(damage * 1.5)
	
	target.take_damage(damage)
	_spawn_damage_number(target, damage)
	
	damage_dealt.emit(target, damage)
	action_executed.emit(attacker, target, "attack")
	GameRoot.event_bus.attack(attacker, target, damage)
	
	# ‚úÖ NOUVEAU : Retirer les auras apr√®s l'attaque
	if is_duo_attack:
		await attacker.get_tree().create_timer(0.5).timeout
		
		# V√©rifier que les unit√©s existent encore
		if is_instance_valid(attacker) and attacker.is_alive():
			attacker.hide_duo_aura()
		
		if is_instance_valid(duo_partner) and duo_partner.is_alive():
			duo_partner.hide_duo_aura()

# ‚úÖ NOUVELLE FONCTION
func _spawn_damage_number(target: BattleUnit3D, damage: int) -> void:
	"""Cr√©e un nombre de d√©g√¢ts anim√© au-dessus de la cible"""
	var damage_number = preload("res://features/combat/visuals/damage_number.gd").new()
	
	# Position de spawn : au-dessus de l'unit√©
	var spawn_pos = target.global_position + Vector3(0, 2.0, 0)
	
	# Offset al√©atoire pour √©viter superposition
	var random_offset = Vector3(
		randf_range(-0.5, 0.5),
		0,
		randf_range(-0.5, 0.5)
	)
	
	damage_number.setup(damage, spawn_pos, random_offset)
	
	# Ajouter √† la sc√®ne
	target.get_parent().add_child(damage_number)

func calculate_damage(attacker: BattleUnit3D, target: BattleUnit3D) -> int:
	var base_damage = attacker.attack_power
	if attacker.has_meta("is_prepared"):
		var bonus = attacker.get_meta("prepared_bonus", {})
		if bonus.has("attack"):
			base_damage = int(base_damage * bonus.attack)
			GameRoot.global_logger.debug("ACTION", "%s (pr√©par√©) : attaque boost√©e x%.2f" % [attacker.unit_name, bonus.attack])
		
		# D√©cr√©menter le compteur
		bonus.turns_remaining -= 1
		if bonus.turns_remaining <= 0:
			attacker.remove_meta("is_prepared")
			attacker.remove_meta("prepared_bonus")
			GameRoot.global_logger.debug("ACTION", "%s : bonus de pr√©paration expir√©" % attacker.unit_name)
		else:
			attacker.set_meta("prepared_bonus", bonus)
	
	var terrain_defense = terrain.get_defense_bonus(target.grid_position)
	var total_defense = target.defense_power + (terrain_defense * 0.1)
	# ‚úÖ Appliquer le bonus d√©fensif de pr√©paration
	if target.has_meta("is_prepared"):
		var bonus = target.get_meta("prepared_bonus", {})
		if bonus.has("defense"):
			total_defense = int(total_defense * bonus.defense)
			GameRoot.global_logger.debug("ACTION", "%s (pr√©par√©) : d√©fense boost√©e x%.2f" % [target.unit_name, bonus.defense])
	# ‚úÖ Appliquer la r√©duction de d√©fense si l'unit√© d√©fend
	if target.has_meta("is_defending"):
		var defense_reduction = target.get_meta("defense_bonus", 0.0)
		base_damage = int(base_damage * (1.0 - defense_reduction))
		GameRoot.global_logger.debug("ACTION", "%s d√©fend : -%d%% d√©g√¢ts" % [target.unit_name, int(defense_reduction * 100)])
	
	var damage = max(1, int(base_damage - total_defense))
	damage = int(damage * randf_range(0.9, 1.1))
	
	return damage

# ============================================================================
# ANIMATIONS 3D
# ============================================================================

func _animate_attack_3d(attacker: BattleUnit3D, target: BattleUnit3D) -> void:
	"""Anime une attaque en 3D"""
	var original_pos = attacker.position
	var target_pos = target.position
	var direction = (target_pos - original_pos).normalized()
	var attack_distance = 0.5
	
	var tween = attacker.create_tween()
	tween.tween_property(attacker, "position", original_pos + direction * attack_distance, 0.1)
	tween.tween_property(attacker, "position", original_pos, 0.1)
	await tween.finished
```

## features/combat/logic/ai_module_3d.gd

```text
extends Node
## AIModule3D - Intelligence artificielle pour les ennemis (version 3D)
## ‚úÖ VERSION MISE √Ä JOUR : Support des attaques en duo

class_name AIModule3D

signal ai_turn_started()
signal ai_turn_completed()
signal ai_action_taken(unit: BattleUnit3D, action: String)

var terrain: TerrainModule3D
var unit_manager: UnitManager3D
var movement_module: MovementModule3D
var action_module: ActionModule3D

# ‚úÖ NOUVEAU : R√©f√©rence au DuoSystem
var duo_system: DuoSystem

enum AIBehavior {
	AGGRESSIVE,
	DEFENSIVE,
	BALANCED,
	SUPPORT
}

var default_behavior: AIBehavior = AIBehavior.AGGRESSIVE

# ============================================================================
# EX√âCUTION
# ============================================================================

func execute_enemy_turn() -> void:
	ai_turn_started.emit()
	
	var enemies = unit_manager.get_alive_enemy_units()
	print("[AIModule3D] === Tour IA (", enemies.size(), " unit√©s) ===")
	
	enemies.sort_custom(_sort_by_priority)
	
	for enemy in enemies:
		await _execute_unit_turn(enemy)
		await get_tree().create_timer(0.5).timeout
	
	ai_turn_completed.emit()
	print("[AIModule3D] === Fin du tour IA ===")

func _execute_unit_turn(unit: BattleUnit3D) -> void:
	if not unit.is_alive():
		return
	
	print("[AIModule3D] ", unit.unit_name, " joue")
	
	var decision = evaluate_unit_action(unit)
	
	if decision.has("move_to") and unit.can_move():
		var target_pos = decision.move_to
		if movement_module.can_move_to(unit, target_pos):
			await movement_module.move_unit(unit, target_pos)
			unit.movement_used = true
	
	if decision.has("action") and unit.can_act():
		await _execute_ai_action(unit, decision)
		unit.action_used = true

# ============================================================================
# √âVALUATION
# ============================================================================

func evaluate_unit_action(unit: BattleUnit3D) -> Dictionary:
	var best_decision: Dictionary = {"action": "wait", "score": 0.0}
	
	var target = find_best_attack_target(unit)
	
	if not target:
		var move_pos = find_best_movement(unit)
		return {"action": "wait", "move_to": move_pos, "score": 10.0}
	
	# ‚úÖ NOUVEAU : V√©rifier si on peut attaquer en duo
	var duo_partner = find_best_duo_partner(unit)
	
	if action_module.can_attack(unit, target):
		best_decision = {
			"action": "attack",
			"target": target,
			"duo_partner": duo_partner,  # ‚úÖ NOUVEAU
			"score": 100.0
		}
	else:
		var move_pos = find_position_to_attack(unit, target)
		if move_pos != unit.grid_position:
			best_decision = {
				"action": "attack",
				"target": target,
				"duo_partner": duo_partner,  # ‚úÖ NOUVEAU
				"move_to": move_pos,
				"score": 80.0
			}
	
	return best_decision

func find_best_duo_partner(unit: BattleUnit3D) -> BattleUnit3D:
	"""Trouve le meilleur partenaire de duo pour une unit√© ennemie"""
	
	var enemies = unit_manager.get_alive_enemy_units()
	var best_partner: BattleUnit3D = null
	var best_score: float = -INF
	
	for ally in enemies:
		if ally == unit:
			continue
		
		# ‚úÖ V√©rifier l'adjacence cardinale stricte
		if not _is_cardinal_adjacent(unit.grid_position, ally.grid_position):
			continue
		
		var score = _evaluate_duo_synergy(unit, ally)
		
		if score > best_score:
			best_score = score
			best_partner = ally
	
	return best_partner
	
func _evaluate_duo_synergy(unit_a: BattleUnit3D, unit_b: BattleUnit3D) -> float:
	"""√âvalue la synergie d'un duo potentiel"""
	
	var score = 0.0
	
	# Pr√©f√©rer les unit√©s avec haute attaque + support
	if unit_a.attack_power > unit_b.attack_power:
		score += 10.0
	
	# Bonus si les deux unit√©s ont des HP √©lev√©s
	score += (unit_a.get_hp_percentage() + unit_b.get_hp_percentage()) * 5.0
	
	# Bonus pour diversit√© de stats
	var stat_diff = abs(unit_a.attack_power - unit_b.defense_power)
	score += stat_diff * 0.5
	
	return score

func find_best_attack_target(unit: BattleUnit3D) -> BattleUnit3D:
	var player_units = unit_manager.get_alive_player_units()
	
	if player_units.is_empty():
		return null
	
	var best_target: BattleUnit3D = null
	var best_score: float = -INF
	
	for target in player_units:
		var score = _evaluate_target(unit, target)
		if score > best_score:
			best_score = score
			best_target = target
	
	return best_target

func _can_form_duo_with_any_ally(unit: BattleUnit3D) -> bool:
	"""V√©rifie si l'unit√© peut former un duo avec AU MOINS un alli√© vivant"""
	
	var enemies = unit_manager.get_alive_enemy_units()
	
	for ally in enemies:
		if ally == unit:
			continue
		
		# V√©rifier si l'alli√© peut encore agir
		if not ally.can_act():
			continue
		
		# V√©rifier l'adjacence cardinale
		if not _is_cardinal_adjacent(unit.grid_position, ally.grid_position):
			continue
		
		# Duo possible trouv√©
		return true
	
	# Aucun duo possible
	return false

func _evaluate_target(attacker: BattleUnit3D, target: BattleUnit3D) -> float:
	var score = 0.0
	
	var distance = terrain.get_distance(attacker.grid_position, target.grid_position)
	score += (20.0 - distance) * 10.0
	
	var hp_percent = target.get_hp_percentage()
	score += (1.0 - hp_percent) * 100.0
	
	score += (50.0 - target.defense_power) * 2.0
	
	return score

func find_best_movement(unit: BattleUnit3D) -> Vector2i:
	var player_units = unit_manager.get_alive_player_units()
	
	if player_units.is_empty():
		return unit.grid_position
	
	var closest_enemy: BattleUnit3D = null
	var closest_distance: int = 999999
	
	for player_unit in player_units:
		var dist = terrain.get_distance(unit.grid_position, player_unit.grid_position)
		if dist < closest_distance:
			closest_distance = dist
			closest_enemy = player_unit
	
	if not closest_enemy:
		return unit.grid_position
	
	return find_position_to_attack(unit, closest_enemy)

func find_position_to_attack(attacker: BattleUnit3D, target: BattleUnit3D) -> Vector2i:
	var reachable = movement_module.calculate_reachable_positions(attacker)
	
	if reachable.is_empty():
		return attacker.grid_position
	
	var best_pos: Vector2i = attacker.grid_position
	var best_distance: int = 999999
	
	for pos in reachable:
		var distance = terrain.get_distance(pos, target.grid_position)
		
		if distance <= attacker.attack_range:
			return pos
		
		if distance < best_distance:
			best_distance = distance
			best_pos = pos
	
	return best_pos

# ============================================================================
# EX√âCUTION DES ACTIONS
# ============================================================================

func _execute_ai_action(unit: BattleUnit3D, decision: Dictionary) -> void:
	match decision.get("action", "wait"):
		"attack":
			var target = decision.get("target")
			var duo_partner = decision.get("duo_partner")
			
			if target and action_module.can_attack(unit, target):
				# ‚úÖ NOUVELLE R√àGLE : Si pas de partenaire trouv√©, v√©rifier s'il y a d'autres alli√©s
				if not duo_partner:
					# Compter les alli√©s vivants
					var alive_allies = unit_manager.get_alive_enemy_units()
					
					# S'il y a plus d'un ennemi vivant (l'unit√© elle-m√™me + au moins un autre)
					if alive_allies.size() > 1:
						# V√©rifier si on PEUT former un duo avec quelqu'un
						if _can_form_duo_with_any_ally(unit):
							print("[AIModule3D] ‚ö†Ô∏è Attaque solo refus√©e : duo possible avec un alli√©")
							# Ne PAS attaquer, passer le tour
							ai_action_taken.emit(unit, "wait")
							return
				
				# Si on arrive ici, soit on a un partenaire, soit on est le dernier survivant
				if duo_partner:
					# V√©rifier adjacence et si le partenaire peut agir
					if _is_cardinal_adjacent(unit.grid_position, duo_partner.grid_position):
						if duo_partner.can_act():
							print("[AIModule3D] üí´ Duo IA temporaire : ", unit.unit_name, " + ", duo_partner.unit_name)
							# Marquer le partenaire comme ayant agi
							duo_partner.action_used = true
							duo_partner.movement_used = true
						else:
							# Le partenaire ne peut plus agir
							duo_partner = null
					else:
						duo_partner = null
				
				await action_module.execute_attack(unit, target, duo_partner)
				ai_action_taken.emit(unit, "attack")
		
		"wait":
			ai_action_taken.emit(unit, "wait")

# ============================================================================
# UTILITAIRES
# ============================================================================

func _sort_by_priority(a: BattleUnit3D, b: BattleUnit3D) -> bool:
	var player_units = unit_manager.get_alive_player_units()
	
	if player_units.is_empty():
		return false
	
	var dist_a = _min_distance_to_players(a, player_units)
	var dist_b = _min_distance_to_players(b, player_units)
	
	return dist_a < dist_b

func _min_distance_to_players(unit: BattleUnit3D, players: Array) -> int:
	var min_dist = 999999
	
	for player in players:
		var dist = terrain.get_distance(unit.grid_position, player.grid_position)
		if dist < min_dist:
			min_dist = dist
	
	return min_dist


func _is_cardinal_adjacent(pos_a: Vector2i, pos_b: Vector2i) -> bool:
	"""V√©rifie si deux positions sont adjacentes en cardinal"""
	var diff = pos_b - pos_a
	return (abs(diff.x) == 1 and diff.y == 0) or (abs(diff.y) == 1 and diff.x == 0)
```

## features/combat/logic/battle_commands.gd

```text
extends Command
class_name MoveUnitCommand

var unit: BattleUnit3D
var from_pos: Vector2i
var to_pos: Vector2i
var unit_manager: UnitManager3D

func _init(p_unit: BattleUnit3D, p_to: Vector2i, p_manager: UnitManager3D):
	unit = p_unit
	from_pos = p_unit.grid_position
	to_pos = p_to
	unit_manager = p_manager
	description = "%s se d√©place de %s √† %s" % [unit.unit_name, from_pos, to_pos]

func _do_execute() -> bool:
	unit_manager.move_unit(unit, to_pos)
	return true

func _do_undo() -> bool:
	unit_manager.move_unit(unit, from_pos)
	return true
```

## features/combat/logic/battle_map_manager_3d.gd

```text
extends Node3D
## BattleMapManager3D - Gestionnaire principal du combat en 3D
## VERSION COMPL√àTE : Transitions + Zoom + Rosace + Repos int√©gr√© au d√©placement

class_name BattleMapManager3D

# ============================================================================
# SIGNAUX
# ============================================================================

signal battle_map_ready()
signal turn_phase_changed(phase: TurnPhase)
signal unit_selected(unit: BattleUnit3D)
signal unit_deselected()
signal action_completed()

# ============================================================================
# ENUMS
# ============================================================================

enum TurnPhase {
	PLAYER_TURN,
	ENEMY_TURN,
	CUTSCENE,
	VICTORY,
	DEFEAT
}

enum ActionState {
	IDLE,
	UNIT_SELECTED,
	CHOOSING_DUO,
	SHOWING_MOVE,
	SHOWING_ATTACK,
	EXECUTING_ACTION,
	USING_REST,
	SELECTING_ITEM_TARGET 
}

enum CompassDirection {
	NORTH = 0,
	NORTH_EAST = 45,
	EAST = 90,
	SOUTH_EAST = 135,
	SOUTH = 180,
	SOUTH_WEST = 225,
	WEST = 270,
	NORTH_WEST = 315
}

# ============================================================================
# CONFIGURATION
# ============================================================================

const TILE_SIZE: float = 1.0
const GRID_WIDTH: int = 20
const GRID_HEIGHT: int = 15

# Configuration cam√©ra
const CAMERA_ROTATION_SPEED: float = 135.0
const CAMERA_DISTANCE: float = 15.0
const CAMERA_HEIGHT: float = 12.0
const CAMERA_ANGLE: float = 45.0

# Zoom cam√©ra
const CAMERA_ZOOM_MIN: float = 8.0
const CAMERA_ZOOM_MAX: float = 25.0
const CAMERA_ZOOM_STEP: float = 2.0

# Couleurs de highlight
const MOVEMENT_COLOR: Color = Color(0.3, 0.6, 1.0, 0.5)
const ATTACK_COLOR: Color = Color(1.0, 0.3, 0.3, 0.5)

# Sc√®nes pr√©charg√©es
const DUO_ATTACK_OPTION_SCENE = preload("res://features/Duo/ui/duo_attack_option.tscn")
const CHARACTER_MINI_CARD_SCENE = preload("res://features/Duo/ui/character_mini_card.tscn")

# ============================================================================
# R√âF√âRENCES UI
# ============================================================================

@onready var grid_container: Node3D = $GridContainer
@onready var units_container: Node3D = $UnitsContainer
@onready var camera_rig: Node3D = $CameraRig
@onready var camera: Camera3D = $CameraRig/Camera3D
@onready var ui_layer: CanvasLayer = $UILayer
@onready var battle_ui: Control = $UILayer/BattleUI

# Menu d'actions
@onready var action_popup: PopupPanel = $UILayer/BattleUI/ActionPopup
@onready var move_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/MoveButton
@onready var attack_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/AttackButton
@onready var defend_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/DefendButton
@onready var draw_mana_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/DrawManaButton
#@onready var abilities_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/AbilitiesButton
@onready var items_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/ItemsButton
@onready var prepare_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/PrepareButton
#@onready var wait_action_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/WaitActionButton
@onready var cancel_button: Button = $UILayer/BattleUI/ActionPopup/VBoxContainer/CancelButton

# Menu de duo
@onready var duo_popup: PopupPanel = $UILayer/BattleUI/DuoSelectionPopup
@onready var support_card_container: PanelContainer = $UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/SupportMiniCard
@onready var leader_card_container: PanelContainer = $UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/LeaderMiniCard
@onready var duo_options_container: VBoxContainer = $UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer/DuoOptionsContainer
@onready var solo_button_duo: Button = $UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer/ButtonsContainer/SoloButton
@onready var cancel_duo_button: Button = $UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer/ButtonsContainer/CancelDuoButton

# Labels d'info
@onready var info_unit_name_label: Label = $UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/UnitNameLabel
@onready var info_class_label: Label = $UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/ClassLabel
@onready var info_hp_value: Label = $UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid/HPValue
@onready var info_atk_value: Label = $UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid/ATKValue
@onready var info_def_value: Label = $UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid/DEFValue
@onready var info_mov_value: Label = $UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid/MOVValue
@onready var turn_label: Label = $UILayer/BattleUI/TopBar/MarginContainer/HBoxContainer/TurnLabel
@onready var phase_label: Label = $UILayer/BattleUI/TopBar/MarginContainer/HBoxContainer/PhaseLabel

# Boutons de contr√¥le
@onready var end_turn_button: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer/EndTurnButton

# Rosace de cam√©ra
@onready var compass_n: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/NButton
@onready var compass_ne: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/NEButton
@onready var compass_e: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/EButton
@onready var compass_se: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/SEButton
@onready var compass_s: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/SButton
@onready var compass_sw: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/SWButton
@onready var compass_w: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/WButton
@onready var compass_nw: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/NWButton
@onready var compass_center: Button = $UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass/CenterButton

# Dialogue
# Dialogue et objets
#@onready var dialogue_box: DialogueBox = $UILayer/DialogueBox
@onready var item_popup: PopupPanel = $UILayer/BattleUI/ItemPopup
@onready var item_list_container: VBoxContainer = $UILayer/BattleUI/ItemPopup/MarginContainer/VBoxContainer/ScrollContainer/ItemListContainer
# ============================================================================
# MODULES
# ============================================================================

var terrain_module: TerrainModule3D
var unit_manager: UnitManager3D
var movement_module: MovementModule3D
var action_module: ActionModule3D
var objective_module: ObjectiveModule
var stats_tracker: BattleStatsTracker
var ai_module: AIModule3D
var json_scenario_module: JSONScenarioModule
var battle_state_machine: BattleStateMachine
var duo_system: DuoSystem
var ring_system: RingSystem
#var data_validation: DataValidationModule
var rest_module: RestModule  # ‚úÖ Module de repos
var last_man_stand_module: LastManStandModule
var item_module: ItemModule

# ============================================================================
# √âTAT
# ============================================================================

var battle_data: Dictionary = {}
var current_turn: int = 1
var selected_unit: BattleUnit3D = null
var duo_partner: BattleUnit3D = null
var hovered_unit: BattleUnit3D = null
var is_battle_active: bool = false
var current_action_state: ActionState = ActionState.IDLE
var current_attack_profile: Dictionary = {}

# Cam√©ra
var camera_rotation_target: float = 0.0
var camera_rotation_current: float = 0.0
var is_camera_rotating: bool = false
var camera_zoom_distance: float = CAMERA_DISTANCE
var battle_center: Vector3 = Vector3.ZERO

# Transition
var transition_overlay: CanvasLayer
var transition_panel: ColorRect
var transition_label: Label

# Raycasting
const MOUSE_RAY_LENGTH: float = 1000.0

# Instances des cartes
var support_mini_card: CharacterMiniCard = null
var leader_mini_card: CharacterMiniCard = null

# ============================================================================
# SYST√àME DE TRANSITION DE TOUR
# ============================================================================

func _create_transition_overlay() -> void:
	"""Cr√©e l'overlay pour les transitions de tour"""
	
	transition_overlay = CanvasLayer.new()
	transition_overlay.layer = 100
	add_child(transition_overlay)
	
	transition_panel = ColorRect.new()
	transition_panel.color = Color(0, 0, 0, 0)
	transition_panel.mouse_filter = Control.MOUSE_FILTER_IGNORE
	transition_panel.set_anchors_preset(Control.PRESET_FULL_RECT)
	transition_overlay.add_child(transition_panel)
	
	transition_label = Label.new()
	transition_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	transition_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	transition_label.set_anchors_preset(Control.PRESET_CENTER)
	transition_label.pivot_offset = transition_label.size / 2
	
	transition_label.add_theme_font_size_override("font_size", 120)
	transition_label.add_theme_color_override("font_color", Color.WHITE)
	transition_label.add_theme_color_override("font_outline_color", Color.BLACK)
	transition_label.add_theme_constant_override("outline_size", 8)
	
	transition_overlay.add_child(transition_label)
	
	GameRoot.global_logger.debug("BATTLE", "Overlay de transition cr√©√©")

func _calculate_battle_center() -> Vector3:
	"""Calcule le centre g√©om√©trique de toutes les unit√©s vivantes"""
	
	var alive_units = unit_manager.get_all_units().filter(func(u): return u.is_alive())
	
	if alive_units.is_empty():
		return Vector3.ZERO
	
	var sum_pos = Vector3.ZERO
	for unit in alive_units:
		sum_pos += unit.global_position
	
	var center = sum_pos / alive_units.size()
	center.y = camera_rig.position.y
	
	return center

func _play_turn_transition(turn_number: int, is_player_turn: bool) -> void:
	"""Joue l'animation de transition de tour"""
	
	battle_center = _calculate_battle_center()
	
	var phase_name = "JOUEUR" if is_player_turn else "ENNEMI"
	var message = "Tour %d - %s" % [turn_number, phase_name]
	transition_label.text = message
	
	var screen_size = get_viewport().get_visible_rect().size
	transition_label.position.x = -screen_size.x
	transition_label.position.y = screen_size.y / 2 - 60
	
	var tween = create_tween()
	tween.set_parallel(false)
	
	tween.set_parallel(true)
	tween.tween_property(transition_panel, "color:a", 0.9, 0.5).set_ease(Tween.EASE_IN)
	tween.tween_property(transition_label, "position:x", screen_size.x / 2 - transition_label.size.x / 2, 0.5).set_ease(Tween.EASE_OUT)
	tween.set_parallel(false)
	
	tween.tween_interval(0.5)
	tween.tween_method(_move_camera_to_position, camera_rig.position, battle_center, 1.0).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_CUBIC)
	tween.tween_interval(0.5)
	
	tween.set_parallel(true)
	tween.tween_property(transition_label, "position:x", screen_size.x, 0.5).set_ease(Tween.EASE_IN)
	tween.tween_property(transition_panel, "color:a", 0.0, 0.5).set_ease(Tween.EASE_OUT)
	tween.set_parallel(false)
	
	await tween.finished
	
	GameRoot.global_logger.debug("BATTLE", "Transition de tour termin√©e")

func _move_camera_to_position(new_position: Vector3) -> void:
	"""D√©place le camera_rig (pour tween)"""
	camera_rig.position = new_position

# ============================================================================
# ZOOM CAM√âRA
# ============================================================================

func _handle_camera_zoom(direction: float) -> void:
	"""G√®re le zoom de la cam√©ra"""
	
	camera_zoom_distance = clamp(
		camera_zoom_distance + direction * CAMERA_ZOOM_STEP,
		CAMERA_ZOOM_MIN,
		CAMERA_ZOOM_MAX
	)
	
	var angle_rad = deg_to_rad(CAMERA_ANGLE)
	camera.position.z = camera_zoom_distance
	camera.position.y = CAMERA_HEIGHT * (camera_zoom_distance / CAMERA_DISTANCE)
	
	GameRoot.global_logger.debug("BATTLE", "Zoom cam√©ra : %.1f" % camera_zoom_distance)

# ============================================================================
# ROSACE DE CAM√âRA
# ============================================================================

func _connect_compass_buttons() -> void:
	"""Connecte les boutons de la rosace de cam√©ra"""
	
	compass_n.pressed.connect(func(): set_camera_direction(CompassDirection.NORTH))
	compass_ne.pressed.connect(func(): set_camera_direction(CompassDirection.NORTH_EAST))
	compass_e.pressed.connect(func(): set_camera_direction(CompassDirection.EAST))
	compass_se.pressed.connect(func(): set_camera_direction(CompassDirection.SOUTH_EAST))
	compass_s.pressed.connect(func(): set_camera_direction(CompassDirection.SOUTH))
	compass_sw.pressed.connect(func(): set_camera_direction(CompassDirection.SOUTH_WEST))
	compass_w.pressed.connect(func(): set_camera_direction(CompassDirection.WEST))
	compass_nw.pressed.connect(func(): set_camera_direction(CompassDirection.NORTH_WEST))
	compass_center.pressed.connect(_on_center_camera)
	
	GameRoot.global_logger.debug("BATTLE", "Boutons de la rosace connect√©s")

func set_camera_direction(direction: CompassDirection) -> void:
	"""Positionne la cam√©ra selon une direction cardinale"""
	
	camera_rotation_target = float(direction)
	is_camera_rotating = true
	
	GameRoot.global_logger.debug("BATTLE", "Cam√©ra orient√©e vers : %d¬∞" % direction)

func _on_center_camera() -> void:
	"""Centre la cam√©ra sur le centre du combat"""
	
	battle_center = _calculate_battle_center()
	
	var tween = create_tween()
	tween.tween_property(camera_rig, "position", battle_center, 0.5).set_ease(Tween.EASE_IN_OUT)
	
	GameRoot.global_logger.debug("BATTLE", "Cam√©ra centr√©e")

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	battle_state_machine = BattleStateMachine.new()
	battle_state_machine.debug_mode = true
	add_child(battle_state_machine)
	
	_setup_camera()
	_connect_ui_buttons()
	_connect_compass_buttons()
	_create_transition_overlay()
	
	GameRoot.global_logger.info("BATTLE", "BattleMapManager3D initialis√©")
	
	await get_tree().process_frame
	
	if GameRoot.battle_data_manager.has_battle_data():
		var data = GameRoot.battle_data_manager.get_battle_data()
		GameRoot.global_logger.info("BATTLE", "Donn√©es r√©cup√©r√©es : %s" % data.get("battle_id"))
		call_deferred("initialize_battle", data)
	else:
		GameRoot.global_logger.error("BATTLE", "Aucune donn√©e de combat disponible")
	
	battle_state_machine.state_changed.connect(_on_battle_state_changed)
	
	support_mini_card = CHARACTER_MINI_CARD_SCENE.instantiate()
	support_card_container.add_child(support_mini_card)
	
	leader_mini_card = CHARACTER_MINI_CARD_SCENE.instantiate()
	leader_card_container.add_child(leader_mini_card)
	
	if GameRoot.debug_overlay:
		GameRoot.debug_overlay.watch_variable("Tour actuel", self, "current_turn")
		GameRoot.debug_overlay.watch_variable("Phase", self, "current_phase")
		GameRoot.debug_overlay.watch_variable("Unit√©s joueur", unit_manager, "player_units")
		GameRoot.debug_overlay.watch_variable("Unit√©s ennemies", unit_manager, "enemy_units")

func _setup_camera() -> void:
	camera_rig.position = Vector3.ZERO
	camera_rotation_current = 0.0
	camera_rotation_target = 0.0
	_update_camera_position()

func _connect_ui_buttons() -> void:
	"""Connecte tous les boutons de l'interface"""
	
	# Menu d'actions
	move_button.pressed.connect(_on_move_pressed)
	attack_button.pressed.connect(_on_attack_pressed)
	defend_button.pressed.connect(_on_defend_pressed)
	draw_mana_button.pressed.connect(_on_draw_mana_pressed)
	items_button.pressed.connect(_on_items_pressed)
	prepare_button.pressed.connect(_on_prepare_pressed)
	cancel_button.pressed.connect(_on_cancel_action_pressed)
	
	# Menu de duo
	solo_button_duo.pressed.connect(_on_solo_attack_pressed)
	cancel_duo_button.pressed.connect(_on_cancel_duo_pressed)
	
	# Boutons de contr√¥le
	end_turn_button.pressed.connect(_on_end_turn_pressed)

func initialize_battle(data: Dictionary) -> void:
	if is_battle_active:
		GameRoot.global_logger.warning("BATTLE", "Combat d√©j√† en cours")
		return
	
	battle_data = data
	is_battle_active = true
	
	GameRoot.global_logger.info("BATTLE", "Initialisation du combat 3D...")
	
	await _initialize_modules()
	
	if json_scenario_module and GameRoot.ui_manager.dialogue_box:
		json_scenario_module.dialogue_box = GameRoot.ui_manager.dialogue_box
		GameRoot.global_logger.debug("BATTLE", "DialogueBox configur√©e")
	
	await _load_terrain(data.get("terrain", "plains"))
	await _load_objectives(data.get("objectives", {}))
	await _load_scenario(data.get("scenario", {}))
	await _spawn_units(data.get("player_units", []), data.get("enemy_units", []))
	await _start_battle()
	
	GameRoot.global_logger.info("BATTLE", "Combat pr√™t !")
	battle_map_ready.emit()

# ============================================================================
# INITIALISATION DES MODULES
# ============================================================================

func _initialize_modules() -> void:
	terrain_module = TerrainModule3D.new()
	terrain_module.tile_size = TILE_SIZE
	terrain_module.grid_width = GRID_WIDTH
	terrain_module.grid_height = GRID_HEIGHT
	grid_container.add_child(terrain_module)
	
	unit_manager = UnitManager3D.new()
	unit_manager.tile_size = TILE_SIZE
	unit_manager.terrain = terrain_module
	units_container.add_child(unit_manager)
	
	movement_module = MovementModule3D.new()
	movement_module.terrain = terrain_module
	movement_module.unit_manager = unit_manager
	add_child(movement_module)
	
	action_module = ActionModule3D.new()
	action_module.unit_manager = unit_manager
	action_module.terrain = terrain_module
	add_child(action_module)
	
	objective_module = ObjectiveModule.new()
	add_child(objective_module)
	
	json_scenario_module = JSONScenarioModule.new()
	add_child(json_scenario_module)
	
	stats_tracker = BattleStatsTracker.new()
	add_child(stats_tracker)
	
	duo_system = DuoSystem.new()
	duo_system.terrain_module = terrain_module
	add_child(duo_system)
	
	ring_system = RingSystem.new()
	add_child(ring_system)
	
	#data_validation = DataValidationModule.new()
	#add_child(data_validation)
	
	ai_module = AIModule3D.new()
	ai_module.terrain = terrain_module
	ai_module.unit_manager = unit_manager
	ai_module.movement_module = movement_module
	ai_module.action_module = action_module
	ai_module.duo_system = duo_system
	add_child(ai_module)
	
	item_module = ItemModule.new()
	item_module.terrain = terrain_module
	item_module.unit_manager = unit_manager
	item_module.duo_system = duo_system
	add_child(item_module)
	
	# Charger l'inventaire depuis BattleDataManager
	var inventory = battle_data.get("inventory", {
		"potion_hp_small": 3,
		"potion_hp_medium": 2,
		"antidote": 2,
		"remedy": 1,
		"mana_elixir": 2
	})
	item_module.setup_inventory(inventory)
	
	item_module.item_used.connect(_on_item_used)
	item_module.item_failed.connect(_on_item_failed)
	
	
	# ‚úÖ Module Last Man Stand
	last_man_stand_module = LastManStandModule.new()
	last_man_stand_module.terrain = terrain_module
	last_man_stand_module.unit_manager = unit_manager
	add_child(last_man_stand_module)
	
	last_man_stand_module.last_man_stand_triggered.connect(_on_last_man_stand_triggered)
	last_man_stand_module.last_man_stand_completed.connect(_on_last_man_stand_completed)

	
	# ‚úÖ Module de repos
	rest_module = RestModule.new()
	add_child(rest_module)
	rest_module.reset_for_new_battle()
	rest_module.rest_points_changed.connect(_on_rest_points_changed)
	
	_connect_modules()
	await get_tree().process_frame
	
	ring_system.load_rings_from_json("res://data/ring/rings.json")
	
	#var validation_report = data_validation.validate_all_data()
	#if not validation_report.is_valid:
		#GameRoot.global_logger.error("BATTLE", "Validation des donn√©es √©chou√©e !")
		#for error in validation_report.errors:
			#GameRoot.global_logger.error("BATTLE", "  - %s" % error)
	
	_connect_duo_signals()
	
	GameRoot.global_logger.info("BATTLE", "Modules 3D initialis√©s")

func _connect_modules() -> void:
	unit_manager.unit_died.connect(_on_unit_died)
	unit_manager.unit_moved.connect(_on_unit_moved)
	movement_module.movement_completed.connect(stats_tracker.record_movement)
	action_module.action_executed.connect(stats_tracker.record_action)
	objective_module.objective_completed.connect(_on_objective_completed)
	objective_module.all_objectives_completed.connect(_on_victory)

func _connect_duo_signals() -> void:
	duo_system.duo_formed.connect(_on_duo_formed)
	duo_system.duo_broken.connect(_on_duo_broken)
	duo_system.duo_validation_failed.connect(_on_duo_validation_failed)

# ============================================================================
# CHARGEMENT
# ============================================================================

func _load_terrain(terrain_data: Variant) -> void:
	if typeof(terrain_data) == TYPE_STRING:
		terrain_module.load_preset(terrain_data)
	elif typeof(terrain_data) == TYPE_DICTIONARY:
		terrain_module.load_custom(terrain_data)
	GameRoot.global_logger.info("BATTLE", "Terrain 3D charg√©")

func _load_objectives(objectives_data: Dictionary) -> void:
	if objectives_data.is_empty():
		return
	objective_module.setup_objectives(objectives_data)
	await get_tree().process_frame

func _load_scenario(scenario_data: Dictionary) -> void:
	if scenario_data.has("scenario_file"):
		json_scenario_module.setup_scenario(scenario_data.scenario_file)
	else:
		GameRoot.global_logger.warning("BATTLE", "Pas de fichier de sc√©nario fourni")
	await get_tree().process_frame

func _spawn_units(player_units: Array, enemy_units: Array) -> void:
	for unit_data in player_units:
		var unit = unit_manager.spawn_unit(unit_data, true)
		if unit:
			stats_tracker.register_unit(unit)
	
	for unit_data in enemy_units:
		var unit = unit_manager.spawn_unit(unit_data, false)
		if unit:
			stats_tracker.register_unit(unit)
	
	await get_tree().process_frame
	GameRoot.global_logger.info("BATTLE", "Unit√©s 3D spawn√©es")

# ============================================================================
# D√âMARRAGE
# ============================================================================

func _start_battle() -> void:
	GameRoot.global_logger.info("BATTLE", "D√©marrage du combat...")
	
	if json_scenario_module.has_intro():
		change_phase(TurnPhase.CUTSCENE)
		await json_scenario_module.play_intro()
		GameRoot.global_logger.debug("BATTLE", "Intro termin√©e")
	
	GameRoot.event_bus.battle_started.emit(battle_data)
	change_phase(TurnPhase.PLAYER_TURN)
	_start_player_turn()

# ============================================================================
# GESTION DES TOURS
# ============================================================================

func change_phase(new_phase: TurnPhase) -> void:
	var state_name = TurnPhase.keys()[new_phase]
	battle_state_machine.change_state(state_name)

func _start_player_turn() -> void:
	GameRoot.global_logger.info("BATTLE", "=== Tour %d - JOUEUR ===" % current_turn)
	turn_label.text = "Tour " + str(current_turn)
	
	await _play_turn_transition(current_turn, true)
	
	unit_manager.reset_player_units()
	_update_all_torus_states(true)
	json_scenario_module.trigger_turn_event(current_turn, false)
	set_process_input(true)

func _start_enemy_turn() -> void:
	GameRoot.global_logger.info("BATTLE", "=== Tour %d - ENNEMI ===" % current_turn)
	
	await _play_turn_transition(current_turn, false)
	
	unit_manager.reset_enemy_units()
	_update_all_torus_states(false)
	json_scenario_module.trigger_turn_event(current_turn, false)
	await ai_module.execute_enemy_turn()
	_end_enemy_turn()

func _end_player_turn() -> void:
	GameRoot.global_logger.debug("BATTLE", "Fin du tour joueur")
	set_process_input(false)
	if selected_unit:
		_deselect_unit()
	
	change_phase(TurnPhase.ENEMY_TURN)
	await get_tree().create_timer(0.5).timeout
	_start_enemy_turn()

func _end_enemy_turn() -> void:
	GameRoot.global_logger.debug("BATTLE", "Fin du tour ennemi")
	current_turn += 1
	objective_module.check_objectives()
	change_phase(TurnPhase.PLAYER_TURN)
	await get_tree().create_timer(0.5).timeout
	_start_player_turn()

func _update_all_torus_states(is_player_turn: bool) -> void:
	for unit in unit_manager.get_all_units():
		var is_current_turn = (is_player_turn and unit.is_player_unit) or (not is_player_turn and not unit.is_player_unit)
		unit.update_torus_state(is_current_turn)

func _on_end_turn_pressed() -> void:
	_end_player_turn()

# ============================================================================
# PROCESS & INPUT
# ============================================================================

func _process(delta: float) -> void:
	_process_camera_rotation(delta)
	_update_info_panel()

func _process_camera_rotation(delta: float) -> void:
	if not is_camera_rotating:
		return
	
	var angle_diff = camera_rotation_target - camera_rotation_current
	
	while angle_diff > 180:
		angle_diff -= 360
	while angle_diff < -180:
		angle_diff += 360
	
	if abs(angle_diff) < 0.1:
		camera_rotation_current = camera_rotation_target
		is_camera_rotating = false
	else:
		var rotation_step = CAMERA_ROTATION_SPEED * delta
		
		if abs(angle_diff) < rotation_step:
			camera_rotation_current = camera_rotation_target
			is_camera_rotating = false
		else:
			camera_rotation_current += rotation_step if angle_diff > 0 else -rotation_step
		
		while camera_rotation_current >= 360:
			camera_rotation_current -= 360
		while camera_rotation_current < 0:
			camera_rotation_current += 360
		
		_update_camera_position()

func _update_camera_position() -> void:
	var angle_rad = deg_to_rad(camera_rotation_current)
	camera_rig.rotation.y = angle_rad
	
	var cam_angle_rad = deg_to_rad(CAMERA_ANGLE)
	camera.position = Vector3(0, CAMERA_HEIGHT, CAMERA_DISTANCE)
	camera.rotation.x = -cam_angle_rad

func rotate_camera(degrees: float) -> void:
	camera_rotation_target += degrees
	while camera_rotation_target >= 360:
		camera_rotation_target -= 360
	while camera_rotation_target < 0:
		camera_rotation_target += 360
	is_camera_rotating = true

func _input(event: InputEvent) -> void:
	# Zoom toujours disponible
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_WHEEL_UP:
			_handle_camera_zoom(-1.0)
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			_handle_camera_zoom(1.0)
	
	if not is_battle_active or battle_state_machine.current_state != "PLAYER_TURN":
		return
	
	if event.is_action_pressed("ui_home"):
		rotate_camera(-45)
	elif event.is_action_pressed("ui_end"):
		rotate_camera(45)
	
	# Clic souris
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		if not action_popup.visible and not duo_popup.visible:
			_handle_mouse_click(event.position)

# ============================================================================
# RAYCASTING & S√âLECTION
# ============================================================================

func _handle_mouse_click(mouse_pos: Vector2) -> void:
	var from = camera.project_ray_origin(mouse_pos)
	var to = from + camera.project_ray_normal(mouse_pos) * MOUSE_RAY_LENGTH
	
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	query.collide_with_areas = true
	query.collision_mask = 3
	
	var result = space_state.intersect_ray(query)
	
	if result:
		_handle_raycast_hit(result)

func _handle_raycast_hit(result: Dictionary) -> void:
	var collider = result.collider
	
	if collider.has_meta("unit"):
		var unit = collider.get_meta("unit")
		
		if hovered_unit != unit:
			hovered_unit = unit
			_update_info_panel()
		
		_handle_unit_click(unit)
		return
	
	if hovered_unit != null:
		hovered_unit = null
		_update_info_panel()
	
	if collider is StaticBody3D:
		var mesh_parent = collider.get_parent()
		if mesh_parent.has_meta("grid_position"):
			var grid_pos = mesh_parent.get_meta("grid_position")
			_handle_terrain_click(grid_pos)

func _handle_unit_click(unit: BattleUnit3D) -> void:
	if unit.is_player_unit:
		if current_action_state == ActionState.CHOOSING_DUO:
			_select_duo_partner(unit)
		else:
			_select_unit(unit)
	elif selected_unit and selected_unit.can_act():
		if current_action_state == ActionState.SHOWING_ATTACK:
			_attack_unit(selected_unit, unit)
	# S√©lection de cible pour objet
	if current_action_state == ActionState.SELECTING_ITEM_TARGET:
		var item_id = get_meta("pending_item_id", "")
		var item_type = get_meta("pending_item_type", "")
		
		match item_type:
			"ally_single":
				if unit.is_player_unit:
					item_module.use_item(selected_unit, item_id, unit)
					_close_all_menus()
					_deselect_unit()
			
			"enemy_single", "enemy_duo":
				if not unit.is_player_unit:
					item_module.use_item(selected_unit, item_id, unit)
					_close_all_menus()
					_deselect_unit()

func _handle_terrain_click(grid_pos: Vector2i) -> void:
	if not selected_unit:
		return
	
	if current_action_state == ActionState.SHOWING_MOVE or current_action_state == ActionState.USING_REST:
		# ‚úÖ FIX : En mode repos, v√©rifier que la case est dans la liste calcul√©e
		if current_action_state == ActionState.USING_REST:
			# R√©cup√©rer les positions accessibles avec repos
			var rest_positions = movement_module.calculate_single_step_positions(selected_unit)
			
			if grid_pos not in rest_positions:
				GameRoot.global_logger.debug("BATTLE", "Clic hors port√©e de repos - annulation")
				_close_all_menus()
				_deselect_unit()
				return
		
		if movement_module.can_move_to(selected_unit, grid_pos):
			await movement_module.move_unit(selected_unit, grid_pos)
			
			if current_action_state == ActionState.USING_REST:
				GameRoot.global_logger.debug("BATTLE", "D√©placement avec repos termin√©")
			
			selected_unit.movement_used = true
			_close_all_menus()
			_deselect_unit()
		else:
			GameRoot.global_logger.debug("BATTLE", "Clic hors port√©e de d√©placement - annulation")
			_close_all_menus()
			_deselect_unit()
	
	elif current_action_state == ActionState.SHOWING_ATTACK:
		var attack_positions = action_module.get_attack_positions(selected_unit)
		
		if grid_pos not in attack_positions:
			GameRoot.global_logger.debug("BATTLE", "Clic hors port√©e d'attaque - annulation")
			_close_all_menus()
			_deselect_unit()
			
	if current_action_state == ActionState.SELECTING_ITEM_TARGET:
		var item_type = get_meta("pending_item_type", "")
		
		if item_type == "position":
			var item_id = get_meta("pending_item_id", "")
			item_module.use_item(selected_unit, item_id, grid_pos)
			_close_all_menus()
			_deselect_unit()

			
# ============================================================================
# PANEL D'INFORMATION
# ============================================================================

func _update_info_panel() -> void:
	if hovered_unit and hovered_unit != selected_unit:
		_display_unit_info(hovered_unit)
	elif selected_unit:
		_display_unit_info(selected_unit)
	else:
		_display_terrain_info()

func _display_unit_info(unit: BattleUnit3D) -> void:
	info_unit_name_label.text = unit.unit_name
	info_class_label.text = "Classe: " + unit.get_meta("class", "Guerrier")
	
	# HP
	info_hp_value.text = "%d/%d" % [unit.current_hp, unit.max_hp]
	
	# ‚úÖ NOUVEAU : Afficher le mana
	var mana_text = "%d/%d (%s)" % [unit.current_mana, unit.max_mana, unit.mana_type.capitalize()]
	# On peut utiliser un label existant ou en cr√©er un nouveau
	# Pour l'instant, ajoutons-le au label de classe
	info_class_label.text = "Classe: %s | Mana: %s" % [unit.get_meta("class", "Guerrier"), mana_text]
	
	info_atk_value.text = str(unit.attack_power)
	info_def_value.text = str(unit.defense_power)
	info_mov_value.text = str(unit.movement_range)
	
	var hp_percent = unit.get_hp_percentage()
	if hp_percent > 0.6:
		info_hp_value.add_theme_color_override("font_color", Color.GREEN)
	elif hp_percent > 0.3:
		info_hp_value.add_theme_color_override("font_color", Color.YELLOW)
	else:
		info_hp_value.add_theme_color_override("font_color", Color.RED)
		
		
func _display_terrain_info() -> void:
	if not terrain_module:
		info_unit_name_label.text = "[Chargement...]"
		info_class_label.text = ""
		info_hp_value.text = "--"
		info_atk_value.text = "--"
		info_def_value.text = "--"
		info_mov_value.text = "--"
		return
	
	var grid_pos = _get_mouse_grid_position()
	
	if not terrain_module.is_in_bounds(grid_pos):
		grid_pos = Vector2i(0, 0)
	
	var tile_type = terrain_module.get_tile_type(grid_pos)
	var tile_name = TerrainModule3D.TileType.keys()[tile_type]
	
	info_unit_name_label.text = "[Terrain]"
	info_class_label.text = "Type: " + tile_name
	
	var move_cost = terrain_module.get_movement_cost(grid_pos)
	var defense_bonus = terrain_module.get_defense_bonus(grid_pos)
	
	info_hp_value.text = "Co√ªt: " + ("‚àû" if move_cost == INF else str(move_cost))
	info_atk_value.text = "--"
	info_def_value.text = "+" + str(defense_bonus)
	info_mov_value.text = "--"
	
	info_hp_value.add_theme_color_override("font_color", Color.WHITE)

func _get_mouse_grid_position() -> Vector2i:
	if not terrain_module:
		return Vector2i(-1, -1)
	
	var mouse_pos = get_viewport().get_mouse_position()
	var from = camera.project_ray_origin(mouse_pos)
	var to = from + camera.project_ray_normal(mouse_pos) * MOUSE_RAY_LENGTH
	
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	query.collide_with_areas = false
	query.collision_mask = 1
	
	var result = space_state.intersect_ray(query)
	
	if result and result.collider is StaticBody3D:
		var mesh_parent = result.collider.get_parent()
		if mesh_parent.has_meta("grid_position"):
			return mesh_parent.get_meta("grid_position")
	
	return Vector2i(-1, -1)

# ============================================================================
# S√âLECTION D'UNIT√â & MENU D'ACTIONS
# ============================================================================

func _select_unit(unit: BattleUnit3D) -> void:
	if selected_unit == unit:
		return
	
	if selected_unit:
		_deselect_unit()
	
	selected_unit = unit
	selected_unit.set_selected(true)
	unit_selected.emit(unit)
	
	_open_action_menu()
	
	current_action_state = ActionState.UNIT_SELECTED
	GameRoot.global_logger.debug("BATTLE", "Unit√© s√©lectionn√©e : %s" % unit.unit_name)

func _deselect_unit() -> void:
	if selected_unit:
		selected_unit.set_selected(false)
		selected_unit = null
		duo_partner = null
		unit_deselected.emit()
		terrain_module.clear_all_highlights()
		_close_all_menus()
		current_action_state = ActionState.IDLE

func _open_action_menu() -> void:
	if not selected_unit:
		return
	
	var screen_pos = camera.unproject_position(selected_unit.position)
	action_popup.position = screen_pos + Vector2(50, -100)
	
	# ‚úÖ Logique du bouton D√©placer avec repos
	var can_use_rest = rest_module.can_use_rest(selected_unit)
	var has_moved = selected_unit.movement_used
	
	if has_moved and can_use_rest:
		# L'unit√© s'est d√©j√† d√©plac√©e, proposer le repos
		move_button.text = "üèÉ Repos (%d/2)" % rest_module.get_rest_points(selected_unit.is_player_unit)
		move_button.disabled = false
	elif not has_moved:
		# D√©placement normal
		move_button.text = "üë£ D√©placer"
		move_button.disabled = not selected_unit.can_move()
	else:
		# D√©j√† boug√© et pas de repos
		move_button.text = "üë£ D√©placer"
		move_button.disabled = true
	
	attack_button.disabled = not selected_unit.can_act()
	defend_button.disabled = not selected_unit.can_act()
	draw_mana_button.disabled = not selected_unit.can_act()
	
	action_popup.popup()

func _close_all_menus() -> void:
	action_popup.hide()
	duo_popup.hide()
	terrain_module.clear_all_highlights()

# ============================================================================
# ACTIONS DU MENU
# ============================================================================

func _on_move_pressed() -> void:
	if not selected_unit:
		return
	
	# ‚úÖ V√©rifier si on est en mode repos
	if selected_unit.movement_used and rest_module.can_use_rest(selected_unit):
		# Mode repos : consommer le point AVANT de montrer la zone
		if not rest_module.use_rest_point(selected_unit):
			GameRoot.event_bus.notify("‚ùå Impossible d'utiliser le repos", "error")
			return
		
		GameRoot.event_bus.notify("‚ú® Repos utilis√© : +1 case de d√©placement", "success")
		
		action_popup.hide()
		current_action_state = ActionState.USING_REST
		
		# Calculer positions accessibles (1 case uniquement)
		var reachable = movement_module.calculate_single_step_positions(selected_unit)
		
		if reachable.is_empty():
			GameRoot.event_bus.notify("‚ö†Ô∏è Aucune case accessible", "warning")
			terrain_module.clear_all_highlights()
			current_action_state = ActionState.IDLE
			return
		
		terrain_module.highlight_tiles(reachable, MOVEMENT_COLOR)
		GameRoot.global_logger.info("BATTLE", "%s utilise le repos : %d case(s) accessible(s)" % [
			selected_unit.unit_name,
			reachable.size()
		])
	
	else:
		# D√©placement normal
		if not selected_unit.can_move():
			return
		
		action_popup.hide()
		current_action_state = ActionState.SHOWING_MOVE
		
		var reachable = movement_module.calculate_reachable_positions(selected_unit)
		terrain_module.highlight_tiles(reachable, MOVEMENT_COLOR)
		
		GameRoot.global_logger.debug("BATTLE", "Mode d√©placement activ√©")

func _on_attack_pressed() -> void:
	if not selected_unit or not selected_unit.can_act():
		return
	
	action_popup.hide()
	_open_duo_selection_menu()

func _on_defend_pressed() -> void:
	if not selected_unit or not selected_unit.can_act():
		return
	
	GameRoot.global_logger.debug("BATTLE", "%s prend une posture d√©fensive" % selected_unit.unit_name)
	
	# ‚úÖ Marquer l'unit√© comme d√©fendant
	selected_unit.action_used = true
	selected_unit.movement_used = true
	
	# ‚úÖ Appliquer le bonus de d√©fense de 30% (r√©duction de d√©g√¢ts)
	selected_unit.set_meta("is_defending", true)
	selected_unit.set_meta("defense_bonus", 0.30)  # 30% de r√©duction
	
	selected_unit.update_state_indicators() 
	# ‚úÖ Effet visuel de d√©fense
	_play_defend_animation(selected_unit)
	
	GameRoot.event_bus.notify("üõ° %s : posture d√©fensive (+30%% r√©sistance)" % selected_unit.unit_name, "info")
	
	_close_all_menus()
	_deselect_unit()

func _play_defend_animation(unit: BattleUnit3D) -> void:
	"""Affiche une animation de d√©fense"""
	
	if not unit or not unit.sprite_3d:
		return
	
	# Effet de bouclier bleu
	var tween = unit.create_tween()
	tween.tween_property(unit.sprite_3d, "modulate", Color(0.5, 0.5, 1.5), 0.2)
	tween.tween_property(unit.sprite_3d, "modulate", Color.WHITE, 0.2)

func _on_draw_mana_pressed() -> void:
	"""Action : Puiser du mana (r√©cup√©ration partielle)"""
	
	if not selected_unit or not selected_unit.can_act():
		return
	
	# R√©cup√©rer 30% du mana maximum
	var mana_gained = int(selected_unit.max_mana * 0.30)
	selected_unit.restore_mana(mana_gained)
	
	# Marquer l'action comme utilis√©e
	selected_unit.action_used = true
	selected_unit.movement_used = true
	
	# Animation visuelle
	_play_mana_draw_animation(selected_unit)
	
	GameRoot.event_bus.notify("‚ú® %s puise du mana : +%d" % [selected_unit.unit_name, mana_gained], "success")
	GameRoot.global_logger.info("BATTLE", "%s puise %d mana (total: %d/%d)" % [
		selected_unit.unit_name,
		mana_gained,
		selected_unit.current_mana,
		selected_unit.max_mana
	])
	
	_close_all_menus()
	_deselect_unit()

func _play_mana_draw_animation(unit: BattleUnit3D) -> void:
	"""Animation de puisage de mana"""
	
	if not unit or not unit.sprite_3d:
		return
	
	# Effet de brille cyan
	var tween = unit.create_tween()
	tween.set_parallel(true)
	
	# Pulsation
	tween.tween_property(unit.sprite_3d, "scale", Vector3(1.2, 1.2, 1.2), 0.3).set_ease(Tween.EASE_OUT)
	tween.tween_property(unit.sprite_3d, "scale", Vector3.ONE, 0.3).set_delay(0.3)
	
	# Couleur cyan brillante
	tween.tween_property(unit.sprite_3d, "modulate", Color(0.3, 1.5, 1.5), 0.3)
	tween.tween_property(unit.sprite_3d, "modulate", Color.WHITE, 0.3).set_delay(0.3)
	
	await tween.finished

func _on_prepare_pressed() -> void:
	"""Action : Se pr√©parer (bonus au prochain tour)"""
	
	if not selected_unit or not selected_unit.can_act():
		return
	
	# Marquer comme pr√©par√©
	selected_unit.set_meta("is_prepared", true)
	selected_unit.set_meta("prepared_bonus", {
		"attack": 1.2,  # +20% attaque
		"defense": 1.15,  # +15% d√©fense
		"turns_remaining": 1
	})
	
	# Marquer l'action
	selected_unit.action_used = true
	selected_unit.movement_used = true
	
	selected_unit.update_state_indicators()
	# Animation
	_play_prepare_animation(selected_unit)
	
	GameRoot.event_bus.notify("üõ°Ô∏è %s se pr√©pare (+20%% ATK, +15%% DEF)" % selected_unit.unit_name, "info")
	GameRoot.global_logger.info("BATTLE", "%s se pr√©pare pour le prochain tour" % selected_unit.unit_name)
	
	_close_all_menus()
	_deselect_unit()

func _play_prepare_animation(unit: BattleUnit3D) -> void:
	"""Animation de pr√©paration"""
	
	if not unit or not unit.sprite_3d:
		return
	
	# Effet de concentration (couleur dor√©e)
	var tween = unit.create_tween()
	tween.tween_property(unit.sprite_3d, "modulate", Color(1.5, 1.5, 0.5), 0.4).set_ease(Tween.EASE_IN_OUT)
	tween.tween_property(unit.sprite_3d, "modulate", Color.WHITE, 0.4).set_ease(Tween.EASE_IN_OUT)

func _on_cancel_action_pressed() -> void:
	_close_all_menus()
	current_action_state = ActionState.IDLE

# ============================================================================
# SYST√àME DE DUO
# ============================================================================

func _open_duo_selection_menu() -> void:
	if not selected_unit:
		return
	
	var allies = unit_manager.get_alive_player_units()
	var is_last_survivor = allies.size() == 1
	
	for child in duo_options_container.get_children():
		child.queue_free()
	
	if leader_mini_card:
		leader_mini_card.setup_from_unit(selected_unit)
	
	if allies.size() > 1:
		var duo_candidates: Array[BattleUnit3D] = []
		
		for ally in allies:
			if ally == selected_unit:
				continue
			
			if not ally.can_act():
				continue
			
			if not _is_cardinal_adjacent(selected_unit.grid_position, ally.grid_position):
				continue
			
			duo_candidates.append(ally)
		
		if not duo_candidates.is_empty() and support_mini_card:
			support_mini_card.setup_from_unit(duo_candidates[0])
		
		for partner in duo_candidates:
			var leader_ring_data = _get_ring_data_from_unit(selected_unit, "mat")
			var partner_ring_data = _get_ring_data_from_unit(partner, "chan")
			
			var duo_option = DUO_ATTACK_OPTION_SCENE.instantiate()
			duo_options_container.add_child(duo_option)
			
			duo_option.setup(partner_ring_data, leader_ring_data, partner)
			
			duo_option.option_hovered.connect(
				func(hovered_partner: BattleUnit3D):
					if support_mini_card:
						support_mini_card.setup_from_unit(hovered_partner)
					_play_duo_formation_effect(selected_unit, hovered_partner)
			)
			
			duo_option.option_unhovered.connect(
				func(unhovered_partner: BattleUnit3D):
					_stop_blink_effect(selected_unit)
					_stop_blink_effect(unhovered_partner)
			)
			
			duo_option.option_selected.connect(
				func(mana_id, weapon_id):
					_stop_blink_effect(selected_unit)
					_stop_blink_effect(partner)
					
					_on_duo_option_selected(partner, {
						"mana_ring": mana_id,
						"weapon_ring": weapon_id
					})
			)
	if is_last_survivor:
		var lms_check = last_man_stand_module.can_use_last_man_stand(selected_unit)
		
		if lms_check.can_use:
			solo_button_duo.text = "üíÄ D√âCHA√éNEMENT PROFANE (LMS)"
			solo_button_duo.modulate = Color(1.5, 0.3, 0.3)  # Rouge intense
		else:
			solo_button_duo.text = "‚ùå Attaque solo impossible"
			solo_button_duo.disabled = true
			
			# Afficher la raison
			var reason_label = Label.new()
			reason_label.text = "‚ö†Ô∏è " + lms_check.reason
			reason_label.add_theme_color_override("font_color", Color(1.0, 0.7, 0.0))
			duo_options_container.add_child(reason_label)
	else:
		solo_button_duo.visible = false

	solo_button_duo.visible = is_last_survivor
	if is_last_survivor:
		solo_button_duo.text = "‚öîÔ∏è Attaquer (Dernier survivant)"
	
	var screen_size = get_viewport().get_visible_rect().size
	duo_popup.position = Vector2(screen_size.x - 1020, 20)
	
	_setup_duo_popup_transparency()
	duo_popup.popup()
	
	current_action_state = ActionState.CHOOSING_DUO

func _setup_duo_popup_transparency() -> void:
	if not duo_popup.has_theme_stylebox_override("panel"):
		var style = StyleBoxFlat.new()
		style.bg_color = Color(0.1, 0.1, 0.12, 0.85)
		style.border_color = Color(0.7, 0.7, 0.8, 0.9)
		style.border_width_left = 3
		style.border_width_top = 3
		style.border_width_right = 3
		style.border_width_bottom = 3
		style.corner_radius_top_left = 12
		style.corner_radius_top_right = 12
		style.corner_radius_bottom_left = 12
		style.corner_radius_bottom_right = 12
		
		duo_popup.add_theme_stylebox_override("panel", style)
	
	if support_card_container and not support_card_container.has_theme_stylebox_override("panel"):
		var card_style = StyleBoxFlat.new()
		card_style.bg_color = Color(0.15, 0.15, 0.18, 0.90)
		card_style.border_width_left = 2
		card_style.border_width_top = 2
		card_style.border_width_right = 2
		card_style.border_width_bottom = 2
		card_style.border_color = Color(0.6, 0.6, 0.7, 1)
		card_style.corner_radius_top_left = 10
		card_style.corner_radius_top_right = 10
		card_style.corner_radius_bottom_right = 10
		card_style.corner_radius_bottom_left = 10
		
		support_card_container.add_theme_stylebox_override("panel", card_style)
		leader_card_container.add_theme_stylebox_override("panel", card_style)

func _on_duo_option_selected(partner: BattleUnit3D, ring_combo: Dictionary) -> void:
	if not _is_cardinal_adjacent(selected_unit.grid_position, partner.grid_position):
		GameRoot.event_bus.notify("Le partenaire doit √™tre adjacent (N, S, E, O)", "error")
		return
	
	duo_partner = partner
	current_attack_profile = ring_combo
	
	duo_popup.hide()
	_show_attack_range()
	
	GameRoot.event_bus.notify("Duo : %s + %s" % [selected_unit.unit_name, partner.unit_name], "info")

func _play_duo_formation_effect(leader: BattleUnit3D, support: BattleUnit3D) -> void:
	_start_blink_effect(leader)
	_start_blink_effect(support)

func _start_blink_effect(unit: BattleUnit3D) -> void:
	if not unit or not unit.sprite_3d:
		return
	
	if unit.has_meta("blink_tween"):
		var old_tween = unit.get_meta("blink_tween") as Tween
		if old_tween and old_tween.is_valid():
			old_tween.kill()
	
	var tween = unit.sprite_3d.create_tween()
	tween.set_loops()
	
	tween.tween_property(unit.sprite_3d, "modulate:a", 0.3, 0.8).set_ease(Tween.EASE_IN_OUT)
	tween.tween_property(unit.sprite_3d, "modulate:a", 1.0, 0.8).set_ease(Tween.EASE_IN_OUT)
	
	unit.set_meta("blink_tween", tween)

func _stop_blink_effect(unit: BattleUnit3D) -> void:
	if not unit or not unit.sprite_3d:
		return
	
	if unit.has_meta("blink_tween"):
		var tween = unit.get_meta("blink_tween") as Tween
		if tween and tween.is_valid():
			tween.kill()
		unit.remove_meta("blink_tween")
	
	unit.sprite_3d.modulate.a = 1.0

func _select_duo_partner(partner: BattleUnit3D) -> void:
	if partner == selected_unit:
		return
	
	if duo_system.try_form_duo(selected_unit, partner):
		duo_partner = partner
		duo_popup.hide()
		_show_attack_range()
		
		GameRoot.global_logger.info("BATTLE", "Duo form√© via DuoSystem")
	else:
		GameRoot.event_bus.notify("Impossible de former ce duo", "warning")

func _on_solo_attack_pressed() -> void:
	"""G√®re l'attaque solo - soit Last Man Stand, soit erreur"""
	
	if not selected_unit:
		return
	
	duo_popup.hide()
	duo_partner = null
	
	# ‚úÖ V√©rifier si Last Man Stand est possible
	var lms_check = last_man_stand_module.can_use_last_man_stand(selected_unit)
	
	if lms_check.can_use:
		# Demander confirmation
		var confirm_text = "‚ö†Ô∏è D√âCHA√éNEMENT PROFANE ‚ö†Ô∏è\n\nVoulez-vous d√©clencher cette attaque interdite ?\n- Consomme 100%% du mana\n- Frappe toutes les cases adjacentes\n- Acte socialement condamn√©"
		
		# Vous pourriez cr√©er un dialogue de confirmation ici
		# Pour l'instant, on lance directement
		
		await last_man_stand_module.execute_last_man_stand(selected_unit)
		
		_close_all_menus()
		_deselect_unit()
	else:
		# Attaque solo impossible
		GameRoot.event_bus.notify("‚ùå Attaque solo impossible : %s" % lms_check.reason, "error")
		GameRoot.global_logger.warning("BATTLE", lms_check.reason)
		
		# R√©ouvrir le menu de s√©lection
		_open_action_menu()


func _on_cancel_duo_pressed() -> void:
	duo_popup.hide()
	current_action_state = ActionState.UNIT_SELECTED
	_open_action_menu()

func _show_attack_range() -> void:
	if not selected_unit:
		return
	
	current_action_state = ActionState.SHOWING_ATTACK
	
	var attack_positions = action_module.get_attack_positions(selected_unit)
	terrain_module.highlight_tiles(attack_positions, ATTACK_COLOR)
	
	GameRoot.global_logger.debug("BATTLE", "Port√©e d'attaque affich√©e")

# ============================================================================
# ACTIONS DE COMBAT
# ============================================================================

func _attack_unit(attacker: BattleUnit3D, target: BattleUnit3D) -> void:
	if not action_module.can_attack(attacker, target):
		return
	
	current_action_state = ActionState.EXECUTING_ACTION
	
	if duo_partner:
		GameRoot.global_logger.info("BATTLE", "Attaque en duo temporaire !")
	
	await action_module.execute_attack(attacker, target, duo_partner)
	
	attacker.action_used = true
	attacker.movement_used = true
	
	if duo_partner:
		duo_partner.action_used = true
		duo_partner.movement_used = true
		
		attacker.update_torus_state(true)
		duo_partner.update_torus_state(true)
	
	duo_partner = null
	current_attack_profile = {}
	
	_close_all_menus()
	_deselect_unit()

# ============================================================================
# CALLBACKS
# ============================================================================

func _on_unit_died(unit: BattleUnit3D) -> void:
	GameRoot.global_logger.info("BATTLE", "Unit√© morte : %s" % unit.unit_name)
	GameRoot.event_bus.unit_died.emit(unit)
	stats_tracker.record_death(unit)
	_check_battle_end()

func _on_unit_moved(unit: BattleUnit3D, from: Vector2i, to: Vector2i) -> void:
	json_scenario_module.trigger_position_event(unit, to)
	objective_module.check_position_objectives(unit, to)

func _on_objective_completed(objective_id: String) -> void:
	GameRoot.global_logger.info("BATTLE", "Objectif compl√©t√© : %s" % objective_id)
	GameRoot.event_bus.notify("Objectif compl√©t√©!", "success")

func _on_victory() -> void:
	GameRoot.global_logger.info("BATTLE", "=== VICTOIRE ===")
	change_phase(TurnPhase.VICTORY)
	await _end_battle(true)

func _check_battle_end() -> void:
	if unit_manager.get_alive_player_units().is_empty():
		GameRoot.global_logger.info("BATTLE", "=== D√âFAITE ===")
		change_phase(TurnPhase.DEFEAT)
		await _end_battle(false)
		return
	
	if unit_manager.get_alive_enemy_units().is_empty():
		if objective_module.are_all_completed():
			_on_victory()

func _end_battle(victory: bool) -> void:
	is_battle_active = false
	duo_system.clear_all_duos()
	
	if victory:
		_award_xp_to_survivors()
	
	if json_scenario_module.has_outro():
		change_phase(TurnPhase.CUTSCENE)
		await json_scenario_module.play_outro(victory)
	
	var battle_stats = stats_tracker.get_final_stats()
	
	var xp_earned = 0
	if victory:
		var global_stats = battle_stats.get("global", {})
		var turns = global_stats.get("turns_elapsed", 1)
		var enemies_killed = global_stats.get("units_killed", 0)
		
		xp_earned = 50 + (enemies_killed * 10)
		
		if turns < 10:
			xp_earned += 50
	
	var results = {
		"victory": victory,
		"battle_title": battle_data.get("battle_title", "Combat Tactique"),
		"turns": current_turn,
		"stats": battle_stats,
		"objectives": objective_module.get_completion_status(),
		"mvp": stats_tracker.get_mvp(),
		"rewards": _calculate_rewards(victory, battle_stats),
		"xp_earned": xp_earned
	}
	
	GameRoot.event_bus.battle_ended.emit(results)
	
	if victory:
		GameRoot.event_bus.notify("Victoire ! Tour %d - MVP: %s" % [current_turn, results.mvp.get("name", "N/A")], "success")
	else:
		GameRoot.event_bus.notify("D√©faite...", "error")
	
	GameRoot.battle_data_manager.store_battle_results(results)
	
	await get_tree().create_timer(2.0).timeout
	
	GameRoot.event_bus.change_scene(SceneRegistry.SceneID.BATTLE_RESULTS)

func _award_xp_to_survivors() -> void:
	var player_units = unit_manager.get_alive_player_units()
	var xp_per_unit = 50 + (current_turn * 10)
	
	for unit in player_units:
		unit.award_xp(xp_per_unit)

func _calculate_rewards(victory: bool, stats: Dictionary) -> Dictionary:
	if not victory:
		return {"gold": 0, "exp": 0}
	
	var base_gold = 100
	var base_exp = 50
	var efficiency_bonus = 1.0 + (stats.get("efficiency", 0) * 0.1)
	
	return {
		"gold": int(base_gold * efficiency_bonus),
		"exp": int(base_exp * efficiency_bonus)
	}

# ============================================================================
# CALLBACKS DUO
# ============================================================================

func _on_duo_formed(duo_data: Dictionary) -> void:
	var leader = duo_data.leader as BattleUnit3D
	var support = duo_data.support as BattleUnit3D
	
	GameRoot.global_logger.info("BATTLE", "Duo form√© : %s + %s" % [leader.unit_name, support.unit_name])
	GameRoot.event_bus.notify("Duo form√© : " + leader.unit_name + " + " + support.unit_name, "success")

func _on_duo_broken(duo_id: String) -> void:
	GameRoot.global_logger.debug("BATTLE", "Duo rompu : %s" % duo_id)

func _on_duo_validation_failed(reason: String) -> void:
	GameRoot.event_bus.notify("Formation de duo impossible : " + reason, "warning")

# ============================================================================
# CALLBACKS REPOS
# ============================================================================

func _on_rest_points_changed(is_player: bool, new_value: int) -> void:
	"""Callback quand les points de repos changent"""
	
	GameRoot.global_logger.debug("BATTLE", "Repos %s : %d/2" % [
		"Joueur" if is_player else "Ennemi",
		new_value
	])

# ============================================================================
# UTILITAIRES
# ============================================================================

func _get_ring_data_from_unit(unit: BattleUnit3D, ring_type: String) -> Dictionary:
	var ring_id: String = ""
	
	if ring_type == "mat":
		ring_id = unit.equipped_materialization_ring
	elif ring_type == "chan":
		ring_id = unit.equipped_channeling_ring
	
	if ring_system:
		if ring_type == "mat":
			var ring = ring_system.get_materialization_ring(ring_id)
			if ring:
				return {
					"ring_id": ring.ring_id,
					"ring_name": ring.ring_name,
					"icon": ""
				}
		elif ring_type == "chan":
			var ring = ring_system.get_channeling_ring(ring_id)
			if ring:
				return {
					"ring_id": ring.ring_id,
					"ring_name": ring.ring_name,
					"icon": ""
				}
	
	var fallback_names = {
		"mat_basic_line": "Lame Basique",
		"mat_cone": "C√¥ne d'Attaque",
		"mat_cross": "Croix Sacr√©e",
		"chan_fire": "Feu",
		"chan_ice": "Glace",
		"chan_neutral": "Neutre"
	}
	
	return {
		"ring_id": ring_id,
		"ring_name": fallback_names.get(ring_id, ring_id),
		"icon": ""
	}

func _is_cardinal_adjacent(pos_a: Vector2i, pos_b: Vector2i) -> bool:
	var diff = pos_b - pos_a
	return (abs(diff.x) == 1 and diff.y == 0) or (abs(diff.y) == 1 and diff.x == 0)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _on_battle_state_changed(from: String, to: String) -> void:
	GameRoot.global_logger.debug("BATTLE", "√âtat : %s ‚Üí %s" % [from, to])
	phase_label.text = "Phase: " + to

func _exit_tree() -> void:
	GameRoot.event_bus.disconnect_all(self)
	GameRoot.global_logger.info("BATTLE", "BattleMapManager3D nettoy√©")

func store_battle_results(results: Dictionary) -> void:
	"""Stocke les r√©sultats du combat pour l'√©cran de r√©sultats"""
	battle_data["results"] = results
	print("[BattleDataManager] R√©sultats de combat stock√©s")
	
func _on_last_man_stand_triggered(unit: BattleUnit3D) -> void:
	"""Callback quand Last Man Stand est d√©clench√©"""
	GameRoot.global_logger.info("BATTLE", "üíÄ %s d√©clenche le D√©cha√Ænement Profane" % unit.unit_name)

func _on_last_man_stand_completed(unit: BattleUnit3D, total_damage: int) -> void:
	"""Callback quand Last Man Stand est termin√©"""
	GameRoot.global_logger.info("BATTLE", "‚úÖ D√©cha√Ænement Profane termin√© : %d d√©g√¢ts totaux" % total_damage)
	
func _on_items_pressed() -> void:
	if not selected_unit:
		return
	
	action_popup.hide()
	_open_item_menu()

func _open_item_menu() -> void:
	"""Affiche le menu de s√©lection d'objets"""
	
	if not selected_unit:
		return
	
	# Nettoyer la liste
	for child in item_list_container.get_children():
		child.queue_free()
	
	# R√©cup√©rer les objets disponibles
	var available_items = item_module.get_available_items(selected_unit)
	
	if available_items.is_empty():
		var no_items_label = Label.new()
		no_items_label.text = "Aucun objet disponible"
		no_items_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		item_list_container.add_child(no_items_label)
	else:
		for item_info in available_items:
			var item_button = _create_item_button(item_info)
			item_list_container.add_child(item_button)
	
	# Bouton annuler
	var cancel_btn = Button.new()
	cancel_btn.text = "‚úï Annuler"
	cancel_btn.custom_minimum_size = Vector2(0, 40)
	cancel_btn.pressed.connect(_on_item_menu_cancel)
	item_list_container.add_child(cancel_btn)
	
	# Positionner et afficher
	var screen_size = get_viewport().get_visible_rect().size
	item_popup.position = Vector2(screen_size.x / 2 - 200, screen_size.y / 2 - 250)
	item_popup.popup()

func _create_item_button(item_info: Dictionary) -> Button:
	"""Cr√©e un bouton pour un objet"""
	
	var button = Button.new()
	button.custom_minimum_size = Vector2(380, 60)
	
	# Texte du bouton
	var item_name = item_info.get("name", "Objet")
	var quantity = item_info.get("quantity", 0)
	var description = item_info.get("description", "")
	
	button.text = "%s (x%d)\n%s" % [item_name, quantity, description]
	
	# Coloration selon la raret√©
	var rarity = item_info.get("rarity", ItemModule.ItemRarity.COMMON)
	match rarity:
		ItemModule.ItemRarity.COMMON:
			button.modulate = Color(1.0, 1.0, 1.0)
		ItemModule.ItemRarity.RARE:
			button.modulate = Color(0.5, 0.8, 1.5)
		ItemModule.ItemRarity.VERY_RARE:
			button.modulate = Color(1.5, 0.5, 1.5)
	
	# Connexion
	var item_id = item_info.get("id", "")
	button.pressed.connect(func(): _on_item_selected(item_id, item_info))
	
	return button

# ============================================================================
# S√âLECTION ET UTILISATION D'OBJET
# ============================================================================

func _on_item_selected(item_id: String, item_info: Dictionary) -> void:
	"""Quand un objet est s√©lectionn√©"""
	
	item_popup.hide()
	
	var target_type = item_info.get("target_type", "self")
	
	match target_type:
		"self":
			# Utilisation imm√©diate sur soi
			item_module.use_item(selected_unit, item_id, selected_unit)
			_close_all_menus()
			_deselect_unit()
		
		"ally_single":
			# S√©lectionner un alli√©
			current_action_state = ActionState.SELECTING_ITEM_TARGET
			set_meta("pending_item_id", item_id)
			set_meta("pending_item_type", "ally_single")
			GameRoot.event_bus.notify("S√©lectionnez un alli√©", "info")
		
		"enemy_single", "enemy_duo":
			# S√©lectionner un ennemi
			current_action_state = ActionState.SELECTING_ITEM_TARGET
			set_meta("pending_item_id", item_id)
			set_meta("pending_item_type", target_type)
			GameRoot.event_bus.notify("S√©lectionnez une cible ennemie", "info")
		
		"ally_single_position":
			# S√©lectionner une position
			current_action_state = ActionState.SELECTING_ITEM_TARGET
			set_meta("pending_item_id", item_id)
			set_meta("pending_item_type", "position")
			
			# Highlight des cases accessibles
			var effect = item_info.get("effect", {})
			var range = effect.get("range", 5)
			var positions = _get_positions_in_range(selected_unit.grid_position, range)
			terrain_module.highlight_tiles(positions, MOVEMENT_COLOR)
			
			GameRoot.event_bus.notify("S√©lectionnez une destination", "info")

func _on_item_menu_cancel() -> void:
	"""Annule la s√©lection d'objet"""
	item_popup.hide()
	_open_action_menu()
	
func _on_item_used(unit: BattleUnit3D, item_id: String, target: Variant) -> void:
	"""Callback quand un objet est utilis√©"""
	GameRoot.global_logger.info("BATTLE", "%s utilise l'objet %s" % [unit.unit_name, item_id])

func _on_item_failed(unit: BattleUnit3D, item_id: String, reason: String) -> void:
	"""Callback quand l'utilisation d'un objet √©choue"""
	GameRoot.event_bus.notify("‚ùå " + reason, "error")
	
func _get_positions_in_range(center: Vector2i, range: int) -> Array[Vector2i]:
	"""Retourne toutes les positions dans un rayon donn√©"""
	var positions: Array[Vector2i] = []
	
	for dy in range(-range, range + 1):
		for dx in range(-range, range + 1):
			var manhattan = abs(dx) + abs(dy)
			if manhattan <= range:
				var pos = center + Vector2i(dx, dy)
				if terrain_module.is_in_bounds(pos) and terrain_module.is_walkable(pos):
					positions.append(pos)
	
	return positions
```

## features/combat/logic/enemy_data_loader.gd

```text
# addons/core/data/enemy_data_loader.gd
class_name EnemyDataLoader
extends Node

## Charge les donn√©es d'ennemis depuis JSON
## Format: data/enemies/*.json

const ENEMIES_DIR = "res://data/enemies/"

var _json_loader: JSONDataLoader
var enemies: Dictionary = {}

func _init():
	_json_loader = JSONDataLoader.new()

func load_all_enemies() -> void:
	enemies = _json_loader.load_json_directory(ENEMIES_DIR, true)
	
	if enemies.is_empty():
		push_warning("No enemies loaded")
	else:
		print("Loaded %d enemy types" % enemies.size())
		GameRoot.event_bus.emit_signal("data_loaded", "enemies", enemies)

func get_enemy(enemy_id: String) -> Dictionary:
	if enemies.has(enemy_id):
		return enemies[enemy_id]
	
	push_error("Enemy not found: " + enemy_id)
	return {}

func create_enemy_instance(enemy_id: String, level: int = 1) -> Dictionary:
	var base_data = get_enemy(enemy_id).duplicate(true)
	
	if base_data.is_empty():
		return {}
	
	# Application du scaling de niveau
	if base_data.has("stats"):
		for stat in base_data.stats:
			if base_data.stats[stat] is float or base_data.stats[stat] is int:
				base_data.stats[stat] = _scale_stat(base_data.stats[stat], level)
	
	base_data["current_level"] = level
	return base_data

func _scale_stat(base_value: float, level: int) -> float:
	# Scaling simple : +10% par niveau
	return base_value * (1.0 + (level - 1) * 0.1)
```

## features/combat/logic/item_module.gd

```text
extends Node
## ItemModule - G√®re les objets de combat
## Les objets servent √† corriger une erreur, sauver une unit√©, cr√©er une ouverture ponctuelle
## ‚ö†Ô∏è NE DOIVENT JAMAIS remplacer une attaque en duo, une pr√©paration ou un bon placement

class_name ItemModule

# ============================================================================
# SIGNAUX
# ============================================================================

signal item_used(unit: BattleUnit3D, item_id: String, target: Variant)
signal item_failed(unit: BattleUnit3D, item_id: String, reason: String)

# ============================================================================
# ENUMS
# ============================================================================

enum ItemRarity {
	COMMON,      # Objets de base (soins, antidotes)
	RARE,        # Objets puissants (repositionnement, suppression √©tat)
	VERY_RARE    # Objets exceptionnels (rupture de duo adverse)
}

enum ItemCategory {
	HEALING,          # Soins
	STATUS_CURE,      # Gu√©rison d'√©tats
	MOVEMENT,         # Repositionnement
	TACTICAL,         # Rupture de duo, etc.
	BUFF,            # Bonus temporaires
}

# ============================================================================
# DONN√âES DES OBJETS
# ============================================================================

const ITEM_DATABASE: Dictionary = {
	# === OBJETS COMMUNS ===
	"potion_hp_small": {
		"name": "Potion de Soin Mineure",
		"description": "Restaure 30 HP",
		"category": ItemCategory.HEALING,
		"rarity": ItemRarity.COMMON,
		"target_type": "ally_single",
		"effect": {
			"type": "heal",
			"value": 30
		},
		"icon": "res://asset/items/potion_small.png"
	},
	
	"potion_hp_medium": {
		"name": "Potion de Soin",
		"description": "Restaure 60 HP",
		"category": ItemCategory.HEALING,
		"rarity": ItemRarity.COMMON,
		"target_type": "ally_single",
		"effect": {
			"type": "heal",
			"value": 60
		},
		"icon": "res://asset/items/potion_medium.png"
	},
	
	"antidote": {
		"name": "Antidote",
		"description": "Soigne l'empoisonnement",
		"category": ItemCategory.STATUS_CURE,
		"rarity": ItemRarity.COMMON,
		"target_type": "ally_single",
		"effect": {
			"type": "cure_status",
			"status": "poison"
		},
		"icon": "res://asset/items/antidote.png"
	},
	
	"remedy": {
		"name": "Rem√®de",
		"description": "Soigne tous les √©tats n√©gatifs",
		"category": ItemCategory.STATUS_CURE,
		"rarity": ItemRarity.COMMON,
		"target_type": "ally_single",
		"effect": {
			"type": "cure_all_status"
		},
		"icon": "res://asset/items/remedy.png"
	},
	
	# === OBJETS RARES ===
	"blink_stone": {
		"name": "Pierre de T√©l√©portation",
		"description": "Repositionnement instantan√© (port√©e 5)",
		"category": ItemCategory.MOVEMENT,
		"rarity": ItemRarity.RARE,
		"target_type": "ally_single_position",
		"effect": {
			"type": "teleport",
			"range": 5
		},
		"icon": "res://asset/items/blink_stone.png"
	},
	
	"cleansing_crystal": {
		"name": "Cristal Purificateur",
		"description": "Supprime un √©tat majeur (paralysie, p√©trification)",
		"category": ItemCategory.STATUS_CURE,
		"rarity": ItemRarity.RARE,
		"target_type": "ally_single",
		"effect": {
			"type": "cure_major_status"
		},
		"icon": "res://asset/items/crystal_cleanse.png"
	},
	
	"duo_breaker": {
		"name": "Orbe de Discorde",
		"description": "Rompt un duo adverse (port√©e 3)",
		"category": ItemCategory.TACTICAL,
		"rarity": ItemRarity.VERY_RARE,
		"target_type": "enemy_duo",
		"effect": {
			"type": "break_duo",
			"range": 3
		},
		"icon": "res://asset/items/orb_discord.png"
	},
	
	"iron_will_potion": {
		"name": "Potion de Volont√© de Fer",
		"description": "Immunit√© aux contr√¥les pendant 2 tours",
		"category": ItemCategory.BUFF,
		"rarity": ItemRarity.RARE,
		"target_type": "ally_single",
		"effect": {
			"type": "buff",
			"buff_type": "cc_immunity",
			"duration": 2
		},
		"icon": "res://asset/items/iron_will.png"
	},
	
	"mana_elixir": {
		"name": "√âlixir de Mana",
		"description": "Restaure 50 points de mana",
		"category": ItemCategory.HEALING,
		"rarity": ItemRarity.COMMON,
		"target_type": "ally_single",
		"effect": {
			"type": "restore_mana",
			"value": 50
		},
		"icon": "res://asset/items/mana_elixir.png"
	}
}

# ============================================================================
# R√âF√âRENCES
# ============================================================================

var terrain: TerrainModule3D
var unit_manager: UnitManager3D
var duo_system: DuoSystem

# ============================================================================
# INVENTAIRE
# ============================================================================

var battle_inventory: Dictionary = {}  # item_id -> quantity

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	GameRoot.global_logger.info("ITEM_MODULE", "Module d'objets initialis√© (%d objets)" % ITEM_DATABASE.size())

func setup_inventory(items: Dictionary) -> void:
	"""Configure l'inventaire pour le combat"""
	battle_inventory = items.duplicate()
	GameRoot.global_logger.debug("ITEM_MODULE", "Inventaire: %s" % battle_inventory)

# ============================================================================
# VALIDATION
# ============================================================================

func can_use_item(unit: BattleUnit3D, item_id: String) -> Dictionary:
	"""V√©rifie si un objet peut √™tre utilis√©"""
	
	if not unit or not unit.is_alive():
		return {"can_use": false, "reason": "Unit√© invalide"}
	
	if not unit.can_act():
		return {"can_use": false, "reason": "L'unit√© a d√©j√† agi ce tour"}
	
	if not battle_inventory.has(item_id) or battle_inventory[item_id] <= 0:
		return {"can_use": false, "reason": "Objet non disponible"}
	
	if not ITEM_DATABASE.has(item_id):
		return {"can_use": false, "reason": "Objet inconnu"}
	
	return {"can_use": true, "reason": ""}

# ============================================================================
# UTILISATION
# ============================================================================

func use_item(user: BattleUnit3D, item_id: String, target: Variant = null) -> bool:
	"""
	Utilise un objet
	@param user : Unit√© qui utilise l'objet
	@param item_id : ID de l'objet
	@param target : Cible (BattleUnit3D ou Vector2i selon l'objet)
	@return true si succ√®s
	"""
	
	# Validation
	var check = can_use_item(user, item_id)
	if not check.can_use:
		item_failed.emit(user, item_id, check.reason)
		return false
	
	var item_data = ITEM_DATABASE[item_id]
	
	# V√©rifier la cible
	if not _validate_target(item_data, target):
		item_failed.emit(user, item_id, "Cible invalide")
		return false
	
	# Appliquer l'effet
	var success = _apply_effect(user, item_data, target)
	
	if success:
		# Consommer l'objet
		battle_inventory[item_id] -= 1
		
		# Marquer l'action
		user.action_used = true
		
		item_used.emit(user, item_id, target)
		
		GameRoot.global_logger.info("ITEM_MODULE", "%s utilise %s" % [user.unit_name, item_data.name])
		GameRoot.event_bus.notify("üì¶ %s utilise : %s" % [user.unit_name, item_data.name], "info")
		
		return true
	
	return false

# ============================================================================
# VALIDATION DE CIBLE
# ============================================================================

func _validate_target(item_data: Dictionary, target: Variant) -> bool:
	"""Valide que la cible est correcte pour l'objet"""
	
	var target_type = item_data.get("target_type", "self")
	
	match target_type:
		"self":
			return target == null
		
		"ally_single":
			return target is BattleUnit3D and target.is_alive()
		
		"ally_single_position":
			return target is Vector2i and terrain.is_in_bounds(target)
		
		"enemy_single":
			return target is BattleUnit3D and target.is_alive()
		
		"enemy_duo":
			# V√©rifier que c'est une unit√© ennemie en duo
			if not target is BattleUnit3D or not target.is_alive():
				return false
			return duo_system.is_in_duo(target) if duo_system else false
	
	return false

# ============================================================================
# APPLICATION DES EFFETS
# ============================================================================

func _apply_effect(user: BattleUnit3D, item_data: Dictionary, target: Variant) -> bool:
	"""Applique l'effet de l'objet"""
	
	var effect = item_data.get("effect", {})
	var effect_type = effect.get("type", "")
	
	match effect_type:
		"heal":
			return _apply_heal(target as BattleUnit3D, effect.get("value", 0))
		
		"restore_mana":
			return _apply_mana_restore(target as BattleUnit3D, effect.get("value", 0))
		
		"cure_status":
			return _apply_cure_status(target as BattleUnit3D, effect.get("status", ""))
		
		"cure_all_status":
			return _apply_cure_all_status(target as BattleUnit3D)
		
		"cure_major_status":
			return _apply_cure_major_status(target as BattleUnit3D)
		
		"teleport":
			return _apply_teleport(target as BattleUnit3D, user, effect.get("range", 5))
		
		"break_duo":
			return _apply_break_duo(target as BattleUnit3D)
		
		"buff":
			return _apply_buff(target as BattleUnit3D, effect)
	
	return false

func _apply_heal(target: BattleUnit3D, amount: int) -> bool:
	"""Soigne une unit√©"""
	if not target:
		return false
	
	target.heal(amount)
	return true

func _apply_mana_restore(target: BattleUnit3D, amount: int) -> bool:
	"""Restaure du mana"""
	if not target:
		return false
	
	target.restore_mana(amount)
	return true

func _apply_cure_status(target: BattleUnit3D, status: String) -> bool:
	"""Soigne un √©tat sp√©cifique"""
	if not target or not target.has_status_effect(status):
		return false
	
	target.remove_status_effect(status)
	return true

func _apply_cure_all_status(target: BattleUnit3D) -> bool:
	"""Soigne tous les √©tats"""
	if not target:
		return false
	
	for status in target.status_effects.keys():
		target.remove_status_effect(status)
	
	return true

func _apply_cure_major_status(target: BattleUnit3D) -> bool:
	"""Soigne les √©tats majeurs (paralysie, p√©trification, etc.)"""
	if not target:
		return false
	
	var major_statuses = ["paralysis", "petrification", "stun", "freeze"]
	var cured = false
	
	for status in major_statuses:
		if target.has_status_effect(status):
			target.remove_status_effect(status)
			cured = true
	
	return cured

func _apply_teleport(target: BattleUnit3D, user: BattleUnit3D, range: int) -> bool:
	"""T√©l√©porte une unit√© (n√©cessite MovementModule)"""
	# TODO: Impl√©menter avec MovementModule
	GameRoot.global_logger.warning("ITEM_MODULE", "T√©l√©portation non impl√©ment√©e")
	return false

func _apply_break_duo(target: BattleUnit3D) -> bool:
	"""Rompt un duo adverse"""
	if not duo_system or not target:
		return false
	
	if duo_system.is_in_duo(target):
		# R√©cup√©rer l'ID du duo
		for duo_id in duo_system.active_duos:
			var duo = duo_system.active_duos[duo_id]
			if duo.leader == target or duo.support == target:
				duo_system.break_duo(duo_id)
				return true
	
	return false

func _apply_buff(target: BattleUnit3D, effect: Dictionary) -> bool:
	"""Applique un buff temporaire"""
	if not target:
		return false
	
	var buff_type = effect.get("buff_type", "")
	var duration = effect.get("duration", 1)
	
	# Utiliser le syst√®me de status_effects existant
	target.add_status_effect("buff_" + buff_type, duration)
	
	return true

# ============================================================================
# GETTERS
# ============================================================================

func get_available_items(unit: BattleUnit3D) -> Array[Dictionary]:
	"""Retourne les objets utilisables par l'unit√©"""
	
	var items: Array[Dictionary] = []
	
	for item_id in battle_inventory:
		if battle_inventory[item_id] > 0:
			var check = can_use_item(unit, item_id)
			if check.can_use:
				var item_info = ITEM_DATABASE[item_id].duplicate()
				item_info["id"] = item_id
				item_info["quantity"] = battle_inventory[item_id]
				items.append(item_info)
	
	return items

func get_item_data(item_id: String) -> Dictionary:
	"""Retourne les donn√©es d'un objet"""
	return ITEM_DATABASE.get(item_id, {})
```

## features/combat/logic/last_man_stand_module.gd

```text
extends Node
## LastManStandModule - G√®re l'attaque solo ultime (D√©cha√Ænement Profane)
## ‚ö†Ô∏è Condition stricte : UNE SEULE unit√© vivante + 50% mana minimum

class_name LastManStandModule

# ============================================================================
# SIGNAUX
# ============================================================================

signal last_man_stand_triggered(unit: BattleUnit3D)
signal last_man_stand_completed(unit: BattleUnit3D, total_damage: int)
signal last_man_stand_failed(unit: BattleUnit3D, reason: String)

# ============================================================================
# CONFIGURATION
# ============================================================================

const MIN_MANA_PERCENT: float = 0.5  # 50% minimum requis
const AREA_SIZE: int = 8  # 8 cases adjacentes
const LORE_NAME: String = "D√©cha√Ænement Profane"

# ============================================================================
# R√âF√âRENCES
# ============================================================================

var terrain: TerrainModule3D
var unit_manager: UnitManager3D

# ============================================================================
# VALIDATION
# ============================================================================

func can_use_last_man_stand(unit: BattleUnit3D) -> Dictionary:
	"""
	V√©rifie si une unit√© peut utiliser Last Man Stand
	@return Dictionary avec {can_use: bool, reason: String}
	"""
	
	if not unit or not unit.is_alive():
		return {"can_use": false, "reason": "Unit√© morte ou invalide"}
	
	# ‚úÖ R√àGLE 1 : Une seule unit√© vivante dans l'√©quipe
	var allies = unit_manager.get_alive_player_units() if unit.is_player_unit else unit_manager.get_alive_enemy_units()
	
	if allies.size() != 1:
		return {
			"can_use": false, 
			"reason": "Last Man Stand impossible : %d unit√©(s) vivante(s) (requis: 1)" % allies.size()
		}
	
	# ‚úÖ R√àGLE 2 : Au moins 50% de mana
	var mana_percent = unit.get_mana_percentage()
	
	if mana_percent < MIN_MANA_PERCENT:
		return {
			"can_use": false,
			"reason": "Mana insuffisant : %.0f%% (requis: 50%%)" % (mana_percent * 100)
		}
	
	# ‚úÖ R√àGLE 3 : Doit pouvoir agir
	if not unit.can_act():
		return {
			"can_use": false,
			"reason": "L'unit√© a d√©j√† agi ce tour"
		}
	
	return {"can_use": true, "reason": ""}

# ============================================================================
# EX√âCUTION
# ============================================================================

func execute_last_man_stand(unit: BattleUnit3D) -> void:
	"""
	Ex√©cute le Last Man Stand
	Consomme 100% du mana et inflige des d√©g√¢ts en AOE 3x3
	"""
	
	# V√©rification finale
	var check = can_use_last_man_stand(unit)
	if not check.can_use:
		last_man_stand_failed.emit(unit, check.reason)
		GameRoot.global_logger.warning("LAST_MAN_STAND", check.reason)
		return
	
	GameRoot.global_logger.info("LAST_MAN_STAND", "üî• %s d√©clenche le %s !" % [unit.unit_name, LORE_NAME])
	last_man_stand_triggered.emit(unit)
	
	# ‚úÖ Animation pr√©paratoire
	await _play_charge_animation(unit)
	
	# ‚úÖ Calculer le multiplicateur bas√© sur le mana actuel
	var mana_percent = unit.get_mana_percentage()
	var damage_multiplier = 1.0 + mana_percent
	
	# ‚úÖ D√©g√¢ts de base
	var base_damage = unit.attack_power
	var total_damage = int(base_damage * damage_multiplier)
	
	# ‚úÖ Diviser en 8 portions pour les 8 cases adjacentes
	var damage_per_cell = total_damage / 8.0
	
	GameRoot.global_logger.info("LAST_MAN_STAND", "Multiplicateur: %.2fx | D√©g√¢ts totaux: %d | Par case: %.1f" % [
		damage_multiplier,
		total_damage,
		damage_per_cell
	])
	
	# ‚úÖ Obtenir les 8 positions adjacentes
	var affected_positions = _get_adjacent_positions(unit.grid_position)
	
	# ‚úÖ Infliger les d√©g√¢ts
	var enemies_hit = 0
	var total_damage_dealt = 0
	
	for pos in affected_positions:
		var target = unit_manager.get_unit_at(pos)
		
		if target and target.is_alive() and target.is_player_unit != unit.is_player_unit:
			var damage = int(damage_per_cell)
			target.take_damage(damage)
			
			_spawn_damage_number(target, damage)
			await get_tree().create_timer(0.1).timeout
			
			enemies_hit += 1
			total_damage_dealt += damage
			
			GameRoot.global_logger.debug("LAST_MAN_STAND", "‚Üí %s touch√© : %d d√©g√¢ts" % [target.unit_name, damage])
	
	# ‚úÖ Consommer 100% du mana
	unit.current_mana = 0
	unit._update_mana_bar()
	unit.mana_changed.emit(0, unit.max_mana)
	
	# ‚úÖ Marquer l'action comme utilis√©e
	unit.action_used = true
	unit.movement_used = true
	
	GameRoot.global_logger.info("LAST_MAN_STAND", "‚úÖ %d ennemi(s) touch√©(s) | Total: %d d√©g√¢ts" % [
		enemies_hit,
		total_damage_dealt
	])
	
	last_man_stand_completed.emit(unit, total_damage_dealt)
	
	# ‚úÖ Message au joueur
	GameRoot.event_bus.notify("üíÄ %s : %s ! (%d d√©g√¢ts)" % [unit.unit_name, LORE_NAME, total_damage_dealt], "critical")

# ============================================================================
# UTILITAIRES
# ============================================================================

func _get_adjacent_positions(center: Vector2i) -> Array[Vector2i]:
	"""Retourne les 8 positions adjacentes (cardinales + diagonales)"""
	
	var positions: Array[Vector2i] = []
	
	var offsets = [
		Vector2i(-1, -1), Vector2i(0, -1), Vector2i(1, -1),  # Haut
		Vector2i(-1,  0),                  Vector2i(1,  0),  # Centre
		Vector2i(-1,  1), Vector2i(0,  1), Vector2i(1,  1)   # Bas
	]
	
	for offset in offsets:
		var pos = center + offset
		if terrain.is_in_bounds(pos):
			positions.append(pos)
	
	return positions

func _spawn_damage_number(target: BattleUnit3D, damage: int) -> void:
	"""Cr√©e un nombre de d√©g√¢ts au-dessus de la cible"""
	
	var damage_number = preload("res://features/combat/visuals/damage_number.gd").new()
	var spawn_pos = target.global_position + Vector3(0, 2.5, 0)
	var random_offset = Vector3(randf_range(-0.3, 0.3), 0, randf_range(-0.3, 0.3))
	
	damage_number.setup(damage, spawn_pos, random_offset)
	target.get_parent().add_child(damage_number)

# ============================================================================
# ANIMATIONS
# ============================================================================

func _play_charge_animation(unit: BattleUnit3D) -> void:
	"""Animation de charge avant l'attaque"""
	
	if not unit.sprite_3d:
		return
	
	# Effet de charge (pulsation + √©l√©vation)
	var tween = unit.create_tween()
	tween.set_parallel(true)
	
	# Pulsation
	tween.tween_property(unit.sprite_3d, "scale", Vector3(1.3, 1.3, 1.3), 0.5).set_ease(Tween.EASE_IN_OUT)
	
	# √âl√©vation
	var original_y = unit.position.y
	tween.tween_property(unit, "position:y", original_y + 0.5, 0.5).set_ease(Tween.EASE_OUT)
	
	# Effet de couleur (rouge intense)
	tween.tween_property(unit.sprite_3d, "modulate", Color(1.5, 0.3, 0.3), 0.5)
	
	await tween.finished
	
	# Retour brutal
	var release = unit.create_tween()
	release.set_parallel(true)
	release.tween_property(unit.sprite_3d, "scale", Vector3.ONE, 0.2)
	release.tween_property(unit, "position:y", original_y, 0.2)
	release.tween_property(unit.sprite_3d, "modulate", Color.WHITE, 0.3)
	
	await release.finished

# ============================================================================
# DEBUG
# ============================================================================

func debug_check_status(unit: BattleUnit3D) -> void:
	"""Affiche l'√©tat du Last Man Stand pour une unit√©"""
	
	var check = can_use_last_man_stand(unit)
	
	print("\n=== Last Man Stand - %s ===" % unit.unit_name)
	print("Peut utiliser : %s" % ("OUI" if check.can_use else "NON"))
	if not check.can_use:
		print("Raison : %s" % check.reason)
	print("Mana : %.0f%%" % (unit.get_mana_percentage() * 100))
	
	var allies = unit_manager.get_alive_player_units() if unit.is_player_unit else unit_manager.get_alive_enemy_units()
	print("Alli√©s vivants : %d" % allies.size())
	print("============================\n")
```

## features/combat/logic/movement_module_3d.gd

```text
extends Node
## MovementModule3D - G√®re le d√©placement des unit√©s en 3D

class_name MovementModule3D

signal movement_started(unit: BattleUnit3D)
signal movement_completed(unit: BattleUnit3D, path: Array)

var terrain: TerrainModule3D
var unit_manager: UnitManager3D

const MOVEMENT_SPEED: float = 3.0  # unit√©s/sec
const MOVEMENT_COLOR: Color = Color(0.3, 0.6, 1.0, 0.5)

# ============================================================================
# VALIDATION
# ============================================================================

func can_move_to(unit: BattleUnit3D, target: Vector2i) -> bool:
	if not unit.can_move():
		return false
	if not terrain.is_in_bounds(target):
		return false
	if not terrain.is_walkable(target):
		return false
	if unit_manager.is_position_occupied(target):
		return false
	
	var path = calculate_path(unit.grid_position, target, unit.movement_range)
	return not path.is_empty()

# ============================================================================
# MOUVEMENT
# ============================================================================

func move_unit(unit: BattleUnit3D, target: Vector2i) -> void:
	if not can_move_to(unit, target):
		push_warning("[MovementModule3D] Mouvement invalide")
		return
	
	var path = calculate_path(unit.grid_position, target, unit.movement_range)
	if path.is_empty():
		return
	
	movement_started.emit(unit)
	await _animate_movement_3d(unit, path)
	unit_manager.move_unit(unit, target)
	movement_completed.emit(unit, path)
	
	print("[MovementModule3D] ", unit.unit_name, " d√©plac√© √† ", target)

func _animate_movement_3d(unit: BattleUnit3D, path: Array) -> void:
	"""Anime le d√©placement 3D le long d'un chemin"""
	for i in range(1, path.size()):
		var next_pos = path[i]
		var world_2d = terrain.grid_to_world(next_pos)
		var world_3d = Vector3(world_2d.x, unit.position.y, world_2d.y)
		
		var distance = unit.position.distance_to(world_3d)
		var duration = distance / MOVEMENT_SPEED
		
		var tween = unit.create_tween()
		tween.tween_property(unit, "position", world_3d, duration).set_ease(Tween.EASE_IN_OUT)
		await tween.finished
		
		await unit.get_tree().create_timer(0.05).timeout

# ============================================================================
# PORT√âE & PATHFINDING
# ============================================================================

func calculate_reachable_positions(unit: BattleUnit3D) -> Array[Vector2i]:
	"""Calcule toutes les positions accessibles"""
	var start = unit.grid_position
	var max_movement = unit.movement_range
	
	var reachable: Array[Vector2i] = []
	var visited: Dictionary = {start: 0}
	var frontier: Array = [start]
	
	while not frontier.is_empty():
		var current = frontier.pop_front()
		var current_cost = visited[current]
		
		for neighbor in terrain.get_neighbors(current):
			if not terrain.is_walkable(neighbor):
				continue
			
			var move_cost = terrain.get_movement_cost(neighbor)
			var new_cost = current_cost + move_cost
			
			if new_cost > max_movement:
				continue
			
			if visited.has(neighbor) and visited[neighbor] <= new_cost:
				continue
			
			if neighbor != start and unit_manager.is_position_occupied(neighbor):
				continue
			
			visited[neighbor] = new_cost
			frontier.append(neighbor)
	
	for pos in visited.keys():
		if pos != start:
			reachable.append(pos)
	
	return reachable

func calculate_path(from: Vector2i, to: Vector2i, max_movement: float) -> Array:
	"""Calcule le chemin optimal avec A*"""
	if from == to:
		return [from]
	
	var open_set: Array[Vector2i] = [from]
	var came_from: Dictionary = {}
	var g_score: Dictionary = {from: 0.0}
	var f_score: Dictionary = {from: _heuristic(from, to)}
	
	while not open_set.is_empty():
		var current = _get_lowest_f_score(open_set, f_score)
		
		if current == to:
			return _reconstruct_path(came_from, current)
		
		open_set.erase(current)
		
		for neighbor in terrain.get_neighbors(current):
			if not terrain.is_walkable(neighbor):
				continue
			
			if neighbor != to and unit_manager.is_position_occupied(neighbor):
				continue
			
			var move_cost = terrain.get_movement_cost(neighbor)
			var tentative_g_score = g_score[current] + move_cost
			
			if neighbor != to and tentative_g_score > max_movement:
				continue
			
			if not g_score.has(neighbor) or tentative_g_score < g_score[neighbor]:
				came_from[neighbor] = current
				g_score[neighbor] = tentative_g_score
				f_score[neighbor] = tentative_g_score + _heuristic(neighbor, to)
				
				if neighbor not in open_set:
					open_set.append(neighbor)
	
	return []

func _heuristic(from: Vector2i, to: Vector2i) -> float:
	return abs(to.x - from.x) + abs(to.y - from.y)

func _get_lowest_f_score(open_set: Array, f_score: Dictionary) -> Vector2i:
	var lowest = open_set[0]
	var lowest_score = f_score.get(lowest, INF)
	
	for node in open_set:
		var score = f_score.get(node, INF)
		if score < lowest_score:
			lowest = node
			lowest_score = score
	
	return lowest

func _reconstruct_path(came_from: Dictionary, current: Vector2i) -> Array:
	var path: Array[Vector2i] = [current]
	while came_from.has(current):
		current = came_from[current]
		path.insert(0, current)
	return path

# ============================================================================
# REPOS : D√âPLACEMENT D'UNE CASE (NOUVEAU - AJOUTER)
# ============================================================================

func calculate_single_step_positions(unit: BattleUnit3D) -> Array[Vector2i]:
	"""
	Calcule les positions accessibles √† exactement 1 case de distance
	Utilis√© pour le syst√®me de repos (inertie)
	
	@param unit : Unit√© qui utilise le repos
	@return Array de positions accessibles en 1 d√©placement
	"""
	
	if not unit:
		GameRoot.global_logger.warning("MOVEMENT_MODULE", "calculate_single_step_positions : unit√© nulle")
		return []
	
	var positions: Array[Vector2i] = []
	
	# Les 4 directions cardinales
	var directions = [
		Vector2i(1, 0),   # Droite
		Vector2i(-1, 0),  # Gauche
		Vector2i(0, 1),   # Bas
		Vector2i(0, -1)   # Haut
	]
	
	for dir in directions:
		var neighbor = unit.grid_position + dir
		
		# V√©rifier les limites de la carte
		if not terrain.is_in_bounds(neighbor):
			continue
		
		# V√©rifier si la case est marchable
		if not terrain.is_walkable(neighbor):
			continue
		
		# V√©rifier le co√ªt de d√©placement (doit √™tre ‚â§ 1)
		var move_cost = terrain.get_movement_cost(neighbor)
		if move_cost > 1.0:
			GameRoot.global_logger.debug("MOVEMENT_MODULE", "Case %s ignor√©e (co√ªt: %.1f > 1)" % [neighbor, move_cost])
			continue
		
		# V√©rifier que la case n'est pas occup√©e
		if unit_manager.is_position_occupied(neighbor):
			GameRoot.global_logger.debug("MOVEMENT_MODULE", "Case %s occup√©e" % neighbor)
			continue
		
		# Case valide !
		positions.append(neighbor)
	
	GameRoot.global_logger.debug("MOVEMENT_MODULE", "%s : %d case(s) accessible(s) avec repos" % [
		unit.unit_name,
		positions.size()
	])
	
	return positions
```

## features/combat/logic/objective_module.gd

```text
extends Node
## ObjectiveModule - G√®re les objectifs de mission

class_name ObjectiveModule

# ============================================================================
# SIGNAUX
# ============================================================================

signal objective_completed(objective_id: String)
signal all_objectives_completed()
signal objective_failed(objective_id: String)

# ============================================================================
# DONN√âES
# ============================================================================

var objectives: Dictionary = {}
# Format: objective_id -> {type, status, data, description}

var primary_objectives: Array[String] = []
var secondary_objectives: Array[String] = []

# ============================================================================
# SETUP
# ============================================================================

func setup_objectives(data: Dictionary) -> void:
	"""Configure les objectifs de la mission"""
	
	objectives.clear()
	primary_objectives.clear()
	secondary_objectives.clear()
	
	# Objectifs primaires
	for obj_data in data.get("primary", []):
		var obj_id = _generate_id()
		objectives[obj_id] = {
			"type": obj_data.type,
			"status": "pending",
			"data": obj_data,
			"description": obj_data.get("description", ""),
			"is_primary": true
		}
		primary_objectives.append(obj_id)
	
	# Objectifs secondaires
	for obj_data in data.get("secondary", []):
		var obj_id = _generate_id()
		objectives[obj_id] = {
			"type": obj_data.type,
			"status": "pending",
			"data": obj_data,
			"description": obj_data.get("description", ""),
			"is_primary": false
		}
		secondary_objectives.append(obj_id)
	
	print("[ObjectiveModule] Objectifs charg√©s: ", objectives.size())

# ============================================================================
# V√âRIFICATION
# ============================================================================

func check_objectives() -> void:
	"""V√©rifie l'√©tat de tous les objectifs"""
	
	for obj_id in objectives:
		if objectives[obj_id].status == "completed":
			continue
		
		var obj = objectives[obj_id]
		_check_objective(obj_id, obj)

func _check_objective(obj_id: String, obj: Dictionary) -> void:
	"""V√©rifie un objectif sp√©cifique"""
	
	match obj.type:
		"defeat_all_enemies":
			if _check_defeat_all():
				_complete_objective(obj_id)
		
		"survive_turns":
			# Sera v√©rifi√© depuis le BattleMapManager
			pass
		
		"reach_position":
			# Sera v√©rifi√© via check_position_objectives
			pass
		
		"protect_unit":
			if not _check_unit_alive(obj.data.unit_id):
				_fail_objective(obj_id)

func check_position_objectives(unit: BattleUnit3D, pos: Vector2i) -> void:
	"""V√©rifie les objectifs bas√©s sur la position"""
	
	for obj_id in objectives:
		var obj = objectives[obj_id]
		
		if obj.status != "pending":
			continue
		
		if obj.type == "reach_position":
			var target = obj.data.get("position", Vector2i(-1, -1))
			if pos == target and unit.is_player_unit:
				_complete_objective(obj_id)

# ============================================================================
# CHECKS SP√âCIFIQUES
# ============================================================================

func _check_defeat_all() -> bool:
	"""V√©rifie si tous les ennemis sont morts"""
	
	# Sera impl√©ment√© via r√©f√©rence au UnitManager
	# ou via EventBus
	return false

func _check_unit_alive(unit_id: String) -> bool:
	"""V√©rifie si une unit√© est vivante"""
	
	# √Ä impl√©menter
	return true

# ============================================================================
# COMPLETION
# ============================================================================

func _complete_objective(obj_id: String) -> void:
	"""Marque un objectif comme compl√©t√©"""
	
	if not objectives.has(obj_id):
		return
	
	objectives[obj_id].status = "completed"
	objective_completed.emit(obj_id)
	
	print("[ObjectiveModule] Objectif compl√©t√©: ", objectives[obj_id].description)
	
	# V√©rifier si tous les primaires sont compl√©t√©s
	if are_all_primary_completed():
		all_objectives_completed.emit()

func _fail_objective(obj_id: String) -> void:
	"""Marque un objectif comme √©chou√©"""
	
	if not objectives.has(obj_id):
		return
	
	objectives[obj_id].status = "failed"
	objective_failed.emit(obj_id)
	
	print("[ObjectiveModule] Objectif √©chou√©: ", objectives[obj_id].description)

# ============================================================================
# GETTERS
# ============================================================================

func are_all_completed() -> bool:
	"""V√©rifie si tous les objectifs sont compl√©t√©s"""
	
	for obj_id in objectives:
		if objectives[obj_id].status != "completed":
			return false
	return true

func are_all_primary_completed() -> bool:
	"""V√©rifie si tous les objectifs primaires sont compl√©t√©s"""
	
	for obj_id in primary_objectives:
		if objectives[obj_id].status != "completed":
			return false
	return true

func get_completion_status() -> Dictionary:
	"""Retourne le statut de compl√©tion"""
	
	var completed = 0
	var total = objectives.size()
	
	for obj_id in objectives:
		if objectives[obj_id].status == "completed":
			completed += 1
	
	return {
		"completed": completed,
		"total": total,
		"percentage": float(completed) / float(total) if total > 0 else 0.0
	}

func _generate_id() -> String:
	"""G√©n√®re un ID unique"""
	
	return "obj_" + str(Time.get_ticks_msec())
```

## features/combat/logic/rest_module.gd

```text
extends Node
## RestModule - G√®re le syst√®me de repos (inertie) global
## Jauge commune par faction, permet de parcourir des cases suppl√©mentaires

class_name RestModule

# ============================================================================
# SIGNAUX
# ============================================================================

signal rest_points_changed(is_player_faction: bool, new_value: int)
signal rest_point_used(unit: BattleUnit3D)
signal rest_depleted(is_player_faction: bool)

# ============================================================================
# CONFIGURATION
# ============================================================================

const MAX_REST_POINTS: int = 2
const INITIAL_REST_POINTS: int = 2

# ============================================================================
# DONN√âES
# ============================================================================

var player_rest_points: int = INITIAL_REST_POINTS
var enemy_rest_points: int = INITIAL_REST_POINTS

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	GameRoot.global_logger.info("REST_MODULE", "Module de repos initialis√© (Max: %d points)" % MAX_REST_POINTS)

func reset_for_new_battle() -> void:
	"""R√©initialise les jauges de repos pour un nouveau combat"""
	player_rest_points = INITIAL_REST_POINTS
	enemy_rest_points = INITIAL_REST_POINTS
	
	rest_points_changed.emit(true, player_rest_points)
	rest_points_changed.emit(false, enemy_rest_points)
	
	GameRoot.global_logger.info("REST_MODULE", "Jauges de repos r√©initialis√©es (%d points chacune)" % INITIAL_REST_POINTS)

# ============================================================================
# GETTERS
# ============================================================================

func get_rest_points(is_player: bool) -> int:
	"""Retourne les points de repos d'une faction"""
	return player_rest_points if is_player else enemy_rest_points

func can_use_rest(unit: BattleUnit3D) -> bool:
	"""V√©rifie si une unit√© peut utiliser le repos"""
	if not unit or not unit.is_alive():
		return false
	
	var rest = get_rest_points(unit.is_player_unit)
	return rest > 0

# ============================================================================
# ACTIONS
# ============================================================================

func use_rest_point(unit: BattleUnit3D) -> bool:
	"""
	Consomme un point de repos pour une unit√©
	
	@return true si succ√®s, false si impossible
	"""
	if not can_use_rest(unit):
		GameRoot.global_logger.warning("REST_MODULE", "%s : impossible d'utiliser le repos" % unit.unit_name)
		return false
	
	# Consommer le point
	if unit.is_player_unit:
		player_rest_points -= 1
		rest_points_changed.emit(true, player_rest_points)
		
		if player_rest_points == 0:
			rest_depleted.emit(true)
	else:
		enemy_rest_points -= 1
		rest_points_changed.emit(false, enemy_rest_points)
		
		if enemy_rest_points == 0:
			rest_depleted.emit(false)
	
	rest_point_used.emit(unit)
	
	GameRoot.global_logger.info("REST_MODULE", "%s utilise 1 repos (reste: %d)" % [
		unit.unit_name,
		get_rest_points(unit.is_player_unit)
	])
	
	return true

func add_rest_point(is_player: bool, amount: int = 1) -> void:
	"""
	Ajoute des points de repos (via conditions de combat)
	
	@param is_player : Faction concern√©e
	@param amount : Nombre de points √† ajouter
	"""
	if is_player:
		player_rest_points = min(MAX_REST_POINTS, player_rest_points + amount)
		rest_points_changed.emit(true, player_rest_points)
	else:
		enemy_rest_points = min(MAX_REST_POINTS, enemy_rest_points + amount)
		rest_points_changed.emit(false, enemy_rest_points)
	
	GameRoot.global_logger.info("REST_MODULE", "Faction %s : +%d repos (total: %d)" % [
		"Joueur" if is_player else "Ennemi",
		amount,
		get_rest_points(is_player)
	])

# ============================================================================
# DEBUG
# ============================================================================

func debug_print_state() -> void:
	"""Affiche l'√©tat actuel des jauges de repos"""
	print("\n=== RestModule - √âtat ===")
	print("Joueur : %d/%d" % [player_rest_points, MAX_REST_POINTS])
	print("Ennemi : %d/%d" % [enemy_rest_points, MAX_REST_POINTS])
	print("=========================\n")
```

## features/combat/logic/unit_manager_3d.gd

```text
extends Node3D
## UnitManager3D - G√®re toutes les unit√©s du combat en 3D

class_name UnitManager3D

# ============================================================================
# SIGNAUX
# ============================================================================

signal unit_spawned(unit: BattleUnit3D)
signal unit_died(unit: BattleUnit3D)
signal unit_moved(unit: BattleUnit3D, from: Vector2i, to: Vector2i)

# ============================================================================
# CONFIGURATION
# ============================================================================

var tile_size: float = 1.0
var terrain: TerrainModule3D

# ============================================================================
# DONN√âES
# ============================================================================

var all_units: Array[BattleUnit3D] = []
var player_units: Array[BattleUnit3D] = []
var enemy_units: Array[BattleUnit3D] = []
var unit_grid: Dictionary = {}  # Vector2i -> BattleUnit3D

# ============================================================================
# SPAWNING
# ============================================================================

func spawn_unit(unit_data: Dictionary, is_player: bool) -> BattleUnit3D:
	"""Spawne une unit√© 3D sur le terrain"""
	
	# === DEBUG ===
	print("\n[UnitManager3D] üéØ Spawning unit: ", unit_data.get("name", "UNKNOWN"))
	print("  - is_player: ", is_player)
	print("  - grid_position from data: ", unit_data.get("position", Vector2i(-1, -1)))
	
	# Cr√©er l'unit√©
	var unit = BattleUnit3D.new()
	
	# Configuration de base
	unit.is_player_unit = is_player
	unit.tile_size = tile_size
	
	# Initialiser avec les donn√©es
	unit.initialize_unit(unit_data)
	
	# Position 3D
	var spawn_pos = unit.grid_position
	unit.position = _grid_to_world_3d(spawn_pos)
	
	# Ajouter √† la sc√®ne
	add_child(unit)
	all_units.append(unit)
	
	if is_player:
		player_units.append(unit)
	else:
		enemy_units.append(unit)
	
	unit_grid[spawn_pos] = unit
	
	# Connexions
	unit.died.connect(_on_unit_died.bind(unit))
	
	unit_spawned.emit(unit)
	print("[UnitManager3D] Unit√© spawn√©e: ", unit.unit_name, " √† ", spawn_pos)
	
	return unit

# ============================================================================
# GETTERS
# ============================================================================

func get_unit_at(grid_pos: Vector2i) -> BattleUnit3D:
	return unit_grid.get(grid_pos, null)

func get_all_units() -> Array[BattleUnit3D]:
	return all_units.duplicate()

func get_player_units() -> Array[BattleUnit3D]:
	return player_units.duplicate()

func get_enemy_units() -> Array[BattleUnit3D]:
	return enemy_units.duplicate()

func get_alive_player_units() -> Array[BattleUnit3D]:
	return player_units.filter(func(u): return u.is_alive())

func get_alive_enemy_units() -> Array[BattleUnit3D]:
	return enemy_units.filter(func(u): return u.is_alive())

func is_position_occupied(grid_pos: Vector2i) -> bool:
	return unit_grid.has(grid_pos)

# ============================================================================
# MOUVEMENT 3D
# ============================================================================

func move_unit(unit: BattleUnit3D, new_pos: Vector2i) -> void:
	"""D√©place une unit√© vers une nouvelle position"""
	
	var old_pos = unit.grid_position
	
	# Retirer de l'ancienne position
	unit_grid.erase(old_pos)
	
	# Mettre √† jour la position
	unit.grid_position = new_pos
	unit.position = _grid_to_world_3d(new_pos)
	
	# Ajouter √† la nouvelle position
	unit_grid[new_pos] = unit
	
	unit_moved.emit(unit, old_pos, new_pos)

# ============================================================================
# TOURS
# ============================================================================

func reset_player_units() -> void:
	for unit in player_units:
		if unit.is_alive():
			unit.reset_for_new_turn()

func reset_enemy_units() -> void:
	for unit in enemy_units:
		if unit.is_alive():
			unit.reset_for_new_turn()

# ============================================================================
# MORT & SUPPRESSION
# ============================================================================

func _on_unit_died(unit: BattleUnit3D) -> void:
	unit_grid.erase(unit.grid_position)
	all_units.erase(unit)
	player_units.erase(unit)
	enemy_units.erase(unit)
	
	unit_died.emit(unit)
	print("[UnitManager3D] Unit√© morte: ", unit.unit_name)

func remove_unit(unit: BattleUnit3D) -> void:
	if unit in all_units:
		unit_grid.erase(unit.grid_position)
		all_units.erase(unit)
		player_units.erase(unit)
		enemy_units.erase(unit)
		unit.queue_free()

func clear_all_units() -> void:
	for unit in all_units.duplicate():
		remove_unit(unit)
	unit_grid.clear()
	print("[UnitManager3D] Toutes les unit√©s supprim√©es")

# ============================================================================
# UTILITAIRES 3D
# ============================================================================

func _grid_to_world_3d(grid_pos: Vector2i) -> Vector3:
	"""Convertit une position grille en position monde 3D avec hauteur du terrain"""
	if terrain:
		var world_2d = terrain.grid_to_world(grid_pos)
		
		# CORRECTION : Obtenir la hauteur du terrain
		var tile_type = terrain.get_tile_type(grid_pos)
		var tile_height = terrain.TILE_HEIGHTS.get(tile_type, 0.0)
		
		# Ajouter 0.5 pour que l'unit√© soit AU-DESSUS du sol
		return Vector3(world_2d.x, tile_height + 0.5, world_2d.y)
	
	# Fallback si pas de terrain
	var offset_x = (20 - 1) * tile_size / 2.0
	var offset_z = (15 - 1) * tile_size / 2.0
	return Vector3(
		grid_pos.x * tile_size - offset_x,
		0,
		grid_pos.y * tile_size - offset_z
	)
```

## features/combat/visuals/battle_3d.tscn

```text
[gd_scene load_steps=3 format=3 uid="uid://4bj7etivw784"]

[ext_resource type="Script" uid="uid://4cemg4rkdvrd" path="res://features/combat/logic/battle_map_manager_3d.gd" id="1_07t6a"]
[ext_resource type="PackedScene" uid="uid://byp8xytm75beo" path="res://shared/ui/dialogue_box.tscn" id="2_x1cvm"]

[node name="BattleMap3D" type="Node3D"]
script = ExtResource("1_07t6a")

[node name="GridContainer" type="Node3D" parent="."]

[node name="UnitsContainer" type="Node3D" parent="."]

[node name="CameraRig" type="Node3D" parent="."]

[node name="Camera3D" type="Camera3D" parent="CameraRig"]
transform = Transform3D(1, 0, 0, 0, 0.707107, 0.707107, 0, -0.707107, 0.707107, 0, 15, 15)
fov = 50.0

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(0.866025, -0.433013, 0.25, 0, 0.5, 0.866025, -0.5, -0.75, 0.433013, 0, 10, 0)
shadow_enabled = true

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]

[node name="UILayer" type="CanvasLayer" parent="."]

[node name="BattleUI" type="Control" parent="UILayer"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ItemPopup" type="PopupPanel" parent="UILayer/BattleUI"]

[node name="MarginContainer" type="MarginContainer" parent="UILayer/BattleUI/ItemPopup"]
offset_left = 4.0
offset_top = 4.0
offset_right = 159.0
offset_bottom = 488.0
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="VBoxContainer" type="VBoxContainer" parent="UILayer/BattleUI/ItemPopup/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="TitleLabel" type="Label" parent="UILayer/BattleUI/ItemPopup/MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "üì¶ Objets"
horizontal_alignment = 1

[node name="ScrollContainer" type="ScrollContainer" parent="UILayer/BattleUI/ItemPopup/MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 400)
layout_mode = 2

[node name="ItemListContainer" type="VBoxContainer" parent="UILayer/BattleUI/ItemPopup/MarginContainer/VBoxContainer/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 10

[node name="TopBar" type="PanelContainer" parent="UILayer/BattleUI"]
layout_mode = 1
anchors_preset = 10
anchor_right = 1.0
offset_bottom = 80.0
grow_horizontal = 2

[node name="TopBarBg" type="ColorRect" parent="UILayer/BattleUI/TopBar"]
layout_mode = 2
color = Color(0.1, 0.1, 0.12, 0.9)

[node name="MarginContainer" type="MarginContainer" parent="UILayer/BattleUI/TopBar"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 10

[node name="HBoxContainer" type="HBoxContainer" parent="UILayer/BattleUI/TopBar/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 40

[node name="TurnLabel" type="Label" parent="UILayer/BattleUI/TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "Tour 1"

[node name="PhaseLabel" type="Label" parent="UILayer/BattleUI/TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Phase: Joueur"

[node name="CameraHint" type="Label" parent="UILayer/BattleUI/TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "A/E: Rotation"

[node name="BottomBar" type="PanelContainer" parent="UILayer/BattleUI"]
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -120.0
grow_horizontal = 2
grow_vertical = 0

[node name="BottomBarBg" type="ColorRect" parent="UILayer/BattleUI/BottomBar"]
layout_mode = 2
color = Color(0.1, 0.1, 0.12, 0.9)

[node name="MarginContainer" type="MarginContainer" parent="UILayer/BattleUI/BottomBar"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 10

[node name="HBoxContainer" type="HBoxContainer" parent="UILayer/BattleUI/BottomBar/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="ButtonsContainer" type="HBoxContainer" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 8
theme_override_constants/separation = 10

[node name="EndTurnButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Fin du Tour"

[node name="WaitButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Attendre"

[node name="MenuButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Menu"

[node name="CameraCompass" type="Control" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer"]
custom_minimum_size = Vector2(120, 120)
layout_mode = 2
size_flags_horizontal = 8

[node name="CompassBg" type="Panel" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="CenterButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(30, 30)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -15.0
offset_top = -15.0
offset_right = 15.0
offset_bottom = 15.0
grow_horizontal = 2
grow_vertical = 2
text = "üì∑"

[node name="NButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(25, 25)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -12.5
offset_top = -55.0
offset_right = 12.5
offset_bottom = -30.0
grow_horizontal = 2
grow_vertical = 2
text = "N"

[node name="NEButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(25, 25)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = 24.0
offset_top = -43.0
offset_right = 49.0
offset_bottom = -18.0
grow_horizontal = 2
grow_vertical = 2
text = "NE"

[node name="EButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(25, 25)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = 42.0
offset_top = -12.5
offset_right = 67.0
offset_bottom = 12.5
grow_horizontal = 2
grow_vertical = 2
text = "E"

[node name="SEButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(25, 25)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = 24.0
offset_top = 18.0
offset_right = 49.0
offset_bottom = 43.0
grow_horizontal = 2
grow_vertical = 2
text = "SE"

[node name="SButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(25, 25)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -12.5
offset_top = 30.0
offset_right = 12.5
offset_bottom = 55.0
grow_horizontal = 2
grow_vertical = 2
text = "S"

[node name="SWButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(25, 25)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -49.0
offset_top = 18.0
offset_right = -24.0
offset_bottom = 43.0
grow_horizontal = 2
grow_vertical = 2
text = "SW"

[node name="WButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(25, 25)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -67.0
offset_top = -12.5
offset_right = -42.0
offset_bottom = 12.5
grow_horizontal = 2
grow_vertical = 2
text = "W"

[node name="NWButton" type="Button" parent="UILayer/BattleUI/BottomBar/MarginContainer/HBoxContainer/CameraCompass"]
custom_minimum_size = Vector2(25, 25)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -49.0
offset_top = -43.0
offset_right = -24.0
offset_bottom = -18.0
grow_horizontal = 2
grow_vertical = 2
text = "NW"

[node name="ActionPopup" type="PopupPanel" parent="UILayer/BattleUI"]

[node name="VBoxContainer" type="VBoxContainer" parent="UILayer/BattleUI/ActionPopup"]
offset_left = 4.0
offset_top = 4.0
offset_right = 184.0
offset_bottom = 344.0
theme_override_constants/separation = 10

[node name="MoveButton" type="Button" parent="UILayer/BattleUI/ActionPopup/VBoxContainer"]
custom_minimum_size = Vector2(180, 40)
layout_mode = 2
text = "üë£ D√©placer"

[node name="AttackButton" type="Button" parent="UILayer/BattleUI/ActionPopup/VBoxContainer"]
custom_minimum_size = Vector2(180, 40)
layout_mode = 2
text = "‚öî Attaquer"

[node name="DefendButton" type="Button" parent="UILayer/BattleUI/ActionPopup/VBoxContainer"]
custom_minimum_size = Vector2(180, 40)
layout_mode = 2
text = "üõ° D√©fendre"

[node name="DrawManaButton" type="Button" parent="UILayer/BattleUI/ActionPopup/VBoxContainer"]
custom_minimum_size = Vector2(180, 40)
layout_mode = 2
text = "üíß Puiser du Mana"

[node name="ItemsButton" type="Button" parent="UILayer/BattleUI/ActionPopup/VBoxContainer"]
custom_minimum_size = Vector2(180, 40)
layout_mode = 2
text = "üéí Objets"

[node name="PrepareButton" type="Button" parent="UILayer/BattleUI/ActionPopup/VBoxContainer"]
custom_minimum_size = Vector2(180, 40)
layout_mode = 2
text = "üõ°Ô∏è Se Pr√©parer"

[node name="CancelButton" type="Button" parent="UILayer/BattleUI/ActionPopup/VBoxContainer"]
custom_minimum_size = Vector2(180, 40)
layout_mode = 2
text = "‚úï Annuler"

[node name="UnitInfoPanel" type="PanelContainer" parent="UILayer/BattleUI"]
layout_mode = 0
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -320.0
offset_top = -300.0
offset_right = -20.0
offset_bottom = -140.0
grow_horizontal = 0
grow_vertical = 0

[node name="UnitInfoBg" type="ColorRect" parent="UILayer/BattleUI/UnitInfoPanel"]
layout_mode = 2
color = Color(0.1, 0.1, 0.12, 0.95)

[node name="MarginContainer" type="MarginContainer" parent="UILayer/BattleUI/UnitInfoPanel"]
layout_mode = 2
theme_override_constants/margin_left = 15
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 15
theme_override_constants/margin_bottom = 15

[node name="VBoxContainer" type="VBoxContainer" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="UnitNameLabel" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.9, 0.6, 1)
theme_override_font_sizes/font_size = 22
text = "[Aucune s√©lection]"

[node name="ClassLabel" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
theme_override_font_sizes/font_size = 16
text = "Classe: --"

[node name="HSeparator" type="HSeparator" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="StatsGrid" type="GridContainer" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer"]
layout_mode = 2
columns = 2

[node name="HPLabel" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
text = "HP:"

[node name="HPValue" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 1, 0.5, 1)
text = "--/--"

[node name="ATKLabel" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
text = "ATK:"

[node name="ATKValue" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
text = "--"

[node name="DEFLabel" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
text = "DEF:"

[node name="DEFValue" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
text = "--"

[node name="MOVLabel" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
text = "MOV:"

[node name="MOVValue" type="Label" parent="UILayer/BattleUI/UnitInfoPanel/MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
text = "--"

[node name="DuoSelectionPopup" type="PopupPanel" parent="UILayer/BattleUI"]

[node name="MarginContainer" type="MarginContainer" parent="UILayer/BattleUI/DuoSelectionPopup"]
offset_left = 4.0
offset_top = 4.0
offset_right = 854.0
offset_bottom = 234.0
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="HBoxContainer" type="HBoxContainer" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="SupportMiniCard" type="PanelContainer" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer"]
custom_minimum_size = Vector2(180, 0)
layout_mode = 2
size_flags_vertical = 0

[node name="CenterContainer" type="VBoxContainer" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 15

[node name="TitleLabel" type="Label" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "‚öîÔ∏è Formation de Duo ‚öîÔ∏è"
horizontal_alignment = 1

[node name="SubtitleLabel" type="Label" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
theme_override_font_sizes/font_size = 16
text = "Choisissez votre combinaison Mana + Arme"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer"]
layout_mode = 2

[node name="DuoOptionsContainer" type="VBoxContainer" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="HSeparator2" type="HSeparator" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer"]
layout_mode = 2

[node name="ButtonsContainer" type="HBoxContainer" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 10

[node name="SoloButton" type="Button" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer/ButtonsContainer"]
custom_minimum_size = Vector2(200, 50)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "üö∂ Attaquer Seul"

[node name="CancelDuoButton" type="Button" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer/CenterContainer/ButtonsContainer"]
custom_minimum_size = Vector2(200, 50)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "‚úï Annuler"

[node name="LeaderMiniCard" type="PanelContainer" parent="UILayer/BattleUI/DuoSelectionPopup/MarginContainer/HBoxContainer"]
custom_minimum_size = Vector2(180, 0)
layout_mode = 2
size_flags_vertical = 0

[node name="DialogueBox" parent="UILayer" instance=ExtResource("2_x1cvm")]
```

## features/combat/visuals/battle_unit_3d.gd

```text
extends Node3D
## BattleUnit3D - Unit√© de combat avec sprite billboard
## ‚úÖ VERSION FINALE : Mana sans regen + Repos g√©r√© globalement

class_name BattleUnit3D

# ============================================================================
# ENUMS
# ============================================================================

enum TorusState {
	CAN_ACT_AND_MOVE,
	CAN_ACT_ONLY,
	CAN_MOVE_ONLY,
	CANNOT_ACT,
	SELECTED,
	ENEMY_TURN
}

# ============================================================================
# SIGNAUX
# ============================================================================

signal died()
signal health_changed(new_hp: int, max_hp: int)
signal mana_changed(new_mana: int, max_mana: int)
signal selected_changed(is_selected: bool)
signal status_effect_applied(effect_name: String)
signal status_effect_removed(effect_name: String)

# ============================================================================
# CONFIGURATION VISUELLE
# ============================================================================

const TILE_SIZE_DEFAULT: float = 1.0
const SPRITE_HEIGHT_DEFAULT: float = 0.2
const SHADOW_OPACITY: float = 0.3
const HP_BAR_WIDTH_RATIO: float = 0.8
const HP_BAR_HEIGHT_OFFSET: float = 0.6

const AURA_PETAL_COUNT := 6
const AURA_HEIGHT := 2.5
const AURA_BASE_RADIUS := 0.4
const AURA_RADIUS_STEP := 0.15
const AURA_ALPHA_MIN := 0.15
const AURA_ALPHA_MAX := 0.45
const DUO_AURA_LIFETIME := 2.0

# Couleurs du torus
const TORUS_COLORS: Dictionary = {
	TorusState.CAN_ACT_AND_MOVE: Color.GREEN,
	TorusState.CAN_ACT_ONLY: Color.YELLOW,
	TorusState.CAN_MOVE_ONLY: Color.CYAN,
	TorusState.CANNOT_ACT: Color.GRAY,
	TorusState.SELECTED: Color.RED,
	TorusState.ENEMY_TURN: Color.GRAY
}

# Respiration
const BREATH_INTENSITY: float = 0.05
const BREATH_DURATION_MIN: float = 2.5
const BREATH_DURATION_MAX: float = 3.5
const BREATH_DELAY_MAX: float = 2.0

const BREATH_SPEED_HEALTHY: float = 1.0
const BREATH_SPEED_WOUNDED: float = 1.5
const BREATH_SPEED_CRITICAL: float = 2.5

# ‚úÖ Couleurs de mana par type
const MANA_COLORS: Dictionary = {
	"neutral": Color(0.8, 0.8, 1.0),
	"fire": Color(1.0, 0.3, 0.1),
	"ice": Color(0.2, 0.7, 1.0),
	"lightning": Color(1.0, 1.0, 0.3),
	"earth": Color(0.6, 0.4, 0.2),
	"wind": Color(0.7, 1.0, 0.8),
	"light": Color(1.0, 1.0, 0.9),
	"dark": Color(0.3, 0.1, 0.4),
}

# ============================================================================
# PROPRI√âT√âS
# ============================================================================

var tile_size: float = TILE_SIZE_DEFAULT
var sprite_height: float = SPRITE_HEIGHT_DEFAULT

# Identit√©
var unit_name: String = "Unit"
var is_player_unit: bool = false
var unit_id: String = ""

# Stats
var max_hp: int = 100
var current_hp: int = 100
var attack_power: int = 20
var defense_power: int = 10
var movement_range: int = 5
var attack_range: int = 1

# ‚úÖ Stats de Mana (SANS r√©g√©n√©ration automatique)
var max_mana: int = 100
var current_mana: int = 100
var mana_type: String = "neutral"

# √âtat
var movement_used: bool = false
var action_used: bool = false
var has_acted_this_turn: bool = false
var grid_position: Vector2i = Vector2i(0, 0)

# Capacit√©s & Effets
var abilities: Array[String] = []
var status_effects: Dictionary = {}

# Apparence
var unit_color: Color = Color.BLUE
var is_selected: bool = false
var current_torus_state: TorusState = TorusState.CAN_ACT_AND_MOVE

# Sprite externe
var sprite_path: String = "res://asset/unit/unit.png"
var sprite_frame: int = 20
var sprite_hframes: int = 7
var sprite_vframes: int = 3

# Anneaux √©quip√©s
var equipped_materialization_ring: String = "mat_basic_line"
var equipped_channeling_ring: String = "chan_neutral"

# Progression
var level: int = 1
var xp: int = 0

# ============================================================================
# R√âF√âRENCES VISUELLES 3D
# ============================================================================

var sprite_3d: Sprite3D
var hp_bar_container: Node3D
var hp_bar_3d: MeshInstance3D
var hp_bar_bg: MeshInstance3D
var mana_bar_3d: MeshInstance3D
var mana_bar_bg: MeshInstance3D
var team_indicator: MeshInstance3D
var selection_indicator: MeshInstance3D
var shadow_sprite: Sprite3D

# Cache de materials
var torus_material: StandardMaterial3D
var hp_bar_material: StandardMaterial3D
var mana_bar_material: StandardMaterial3D

var defend_indicator: Sprite3D = null  # Diamant bleu (d√©fense)
var prepared_indicator: Sprite3D = null  # Diamant rouge (pr√©par√©)
# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	if unit_id == "":
		unit_id = unit_name + "_" + str(Time.get_ticks_msec())
	
	_create_visuals_3d()
	_update_hp_bar()
	_update_mana_bar()
	
	GameRoot.global_logger.debug("BATTLE_UNIT", "Unit√© %s initialis√©e (ID: %s, Mana: %s)" % [unit_name, unit_id, mana_type])

# ============================================================================
# CR√âATION DES VISUELS 3D (IDENTIQUE)
# ============================================================================

func _create_visuals_3d() -> void:
	shadow_sprite = Sprite3D.new()
	shadow_sprite.billboard = BaseMaterial3D.BILLBOARD_DISABLED
	shadow_sprite.texture = _create_circle_texture(64, Color(0, 0, 0, SHADOW_OPACITY))
	shadow_sprite.pixel_size = 0.02
	shadow_sprite.rotation.x = -PI / 2
	shadow_sprite.position.y = 0.05
	shadow_sprite.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	add_child(shadow_sprite)
	
	sprite_3d = Sprite3D.new()
	sprite_3d.billboard = BaseMaterial3D.BILLBOARD_ENABLED
	sprite_3d.pixel_size = 0.04
	sprite_3d.position.y = sprite_height
	sprite_3d.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	_load_sprite_texture()
	add_child(sprite_3d)
	
	selection_indicator = _create_selection_ring()
	selection_indicator.visible = true
	add_child(selection_indicator)
	
	_create_status_bars()
	_create_collision()
	
	visible = true
	show()
	
	_start_breathing_animation()
	_create_state_indicators()
	GameRoot.global_logger.debug("BATTLE_UNIT", "Visuels cr√©√©s pour %s" % unit_name)

func _load_sprite_texture() -> void:
	if sprite_path != "" and ResourceLoader.exists(sprite_path):
		var external_texture = load(sprite_path) as Texture2D
		
		if external_texture:
			sprite_3d.texture = external_texture
			sprite_3d.hframes = sprite_hframes
			sprite_3d.vframes = sprite_vframes
			sprite_3d.frame = sprite_frame
			GameRoot.global_logger.info("BATTLE_UNIT", "Sprite externe charg√© : %s (frame %d)" % [sprite_path, sprite_frame])
			return
	
	sprite_3d.texture = _create_unit_texture()
	sprite_3d.hframes = 1
	sprite_3d.vframes = 1
	sprite_3d.frame = 0
	GameRoot.global_logger.warning("BATTLE_UNIT", "Sprite fallback utilis√© pour %s" % unit_name)

func _create_unit_texture() -> ImageTexture:
	var image = Image.create(128, 128, false, Image.FORMAT_RGBA8)
	image.fill(Color.TRANSPARENT)
	
	for y in range(128):
		for x in range(128):
			var dx = x - 64
			var dy = y - 64
			var dist = sqrt(dx*dx + dy*dy)
			
			if dist < 50:
				var alpha = 1.0 - (dist / 50.0) * 0.3
				image.set_pixel(x, y, Color(unit_color.r, unit_color.g, unit_color.b, alpha))
			
			if dist > 45 and dist < 50:
				image.set_pixel(x, y, unit_color.darkened(0.5))
	
	return ImageTexture.create_from_image(image)

func _create_circle_texture(size: int, color: Color) -> ImageTexture:
	var image = Image.create(size, size, false, Image.FORMAT_RGBA8)
	image.fill(Color.TRANSPARENT)
	
	var center = size / 2
	for y in range(size):
		for x in range(size):
			var dx = x - center
			var dy = y - center
			var dist = sqrt(dx*dx + dy*dy)
			
			if dist < center:
				var alpha = color.a * (1.0 - dist / center)
				image.set_pixel(x, y, Color(color.r, color.g, color.b, alpha))
	
	return ImageTexture.create_from_image(image)

func _create_selection_ring() -> MeshInstance3D:
	var mesh_instance = MeshInstance3D.new()
	
	var torus = TorusMesh.new()
	torus.inner_radius = tile_size * 0.35
	torus.outer_radius = tile_size * 0.45
	torus.rings = 24
	torus.ring_segments = 48
	
	mesh_instance.mesh = torus
	mesh_instance.rotation_degrees.y = -90
	mesh_instance.position.y = -0.4
	
	torus_material = StandardMaterial3D.new()
	torus_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	torus_material.emission_enabled = true
	torus_material.emission_energy_multiplier = 2.0
	
	mesh_instance.set_surface_override_material(0, torus_material)
	mesh_instance.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	
	return mesh_instance

func _create_status_bars() -> void:
	hp_bar_container = Node3D.new()
	hp_bar_container.position = Vector3(0, sprite_height + HP_BAR_HEIGHT_OFFSET, 0)
	hp_bar_container.top_level = false
	add_child(hp_bar_container)
	
	# Fond HP
	hp_bar_bg = MeshInstance3D.new()
	var bg_box = BoxMesh.new()
	bg_box.size = Vector3(tile_size * HP_BAR_WIDTH_RATIO, 0.08, 0.02)
	hp_bar_bg.mesh = bg_box
	
	var bg_material = StandardMaterial3D.new()
	bg_material.albedo_color = Color(0.2, 0.2, 0.2)
	bg_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	bg_material.cull_mode = BaseMaterial3D.CULL_DISABLED
	bg_material.transparency = BaseMaterial3D.TRANSPARENCY_DISABLED
	hp_bar_bg.set_surface_override_material(0, bg_material)
	hp_bar_bg.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	hp_bar_container.add_child(hp_bar_bg)
	
	# Barre HP
	hp_bar_3d = MeshInstance3D.new()
	var hp_box = BoxMesh.new()
	hp_box.size = Vector3(tile_size * HP_BAR_WIDTH_RATIO, 0.06, 0.04)
	hp_bar_3d.mesh = hp_box
	hp_bar_3d.position.z = 0.03
	
	hp_bar_material = StandardMaterial3D.new()
	hp_bar_material.albedo_color = Color.GREEN
	hp_bar_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	hp_bar_material.cull_mode = BaseMaterial3D.CULL_DISABLED
	hp_bar_material.transparency = BaseMaterial3D.TRANSPARENCY_DISABLED
	hp_bar_material.depth_draw_mode = BaseMaterial3D.DEPTH_DRAW_ALWAYS
	hp_bar_material.no_depth_test = false
	hp_bar_3d.set_surface_override_material(0, hp_bar_material)
	hp_bar_3d.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	hp_bar_3d.sorting_offset = 0.1
	hp_bar_container.add_child(hp_bar_3d)
	
	# Fond Mana
	mana_bar_bg = MeshInstance3D.new()
	var mana_bg_box = BoxMesh.new()
	mana_bg_box.size = Vector3(tile_size * HP_BAR_WIDTH_RATIO, 0.06, 0.02)
	mana_bar_bg.mesh = mana_bg_box
	mana_bar_bg.position.y = -0.12
	
	var mana_bg_material = StandardMaterial3D.new()
	mana_bg_material.albedo_color = Color(0.15, 0.15, 0.2)
	mana_bg_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	mana_bg_material.cull_mode = BaseMaterial3D.CULL_DISABLED
	mana_bg_material.transparency = BaseMaterial3D.TRANSPARENCY_DISABLED
	mana_bar_bg.set_surface_override_material(0, mana_bg_material)
	mana_bar_bg.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	hp_bar_container.add_child(mana_bar_bg)
	
	# Barre Mana
	mana_bar_3d = MeshInstance3D.new()
	var mana_box = BoxMesh.new()
	mana_box.size = Vector3(tile_size * HP_BAR_WIDTH_RATIO, 0.05, 0.04)
	mana_bar_3d.mesh = mana_box
	mana_bar_3d.position = Vector3(0, -0.12, 0.03)
	
	mana_bar_material = StandardMaterial3D.new()
	mana_bar_material.albedo_color = MANA_COLORS.get(mana_type, Color.CYAN)
	mana_bar_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	mana_bar_material.cull_mode = BaseMaterial3D.CULL_DISABLED
	mana_bar_material.transparency = BaseMaterial3D.TRANSPARENCY_DISABLED
	mana_bar_material.depth_draw_mode = BaseMaterial3D.DEPTH_DRAW_ALWAYS
	mana_bar_material.no_depth_test = false
	mana_bar_material.emission_enabled = true
	mana_bar_material.emission = mana_bar_material.albedo_color * 0.5
	mana_bar_3d.set_surface_override_material(0, mana_bar_material)
	mana_bar_3d.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	mana_bar_3d.sorting_offset = 0.1
	hp_bar_container.add_child(mana_bar_3d)
	
	# Team Indicator
	team_indicator = MeshInstance3D.new()
	var indicator_box = BoxMesh.new()
	indicator_box.size = Vector3(0.12, 0.12, 0.04)
	team_indicator.mesh = indicator_box
	
	var bar_width = tile_size * HP_BAR_WIDTH_RATIO
	team_indicator.position = Vector3(bar_width / 2 + 0.08, -0.06, 0.03)
	
	var team_material = StandardMaterial3D.new()
	team_material.albedo_color = Color.GREEN if is_player_unit else Color.RED
	team_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	team_material.emission_enabled = true
	team_material.emission = team_material.albedo_color * 0.5
	team_material.cull_mode = BaseMaterial3D.CULL_DISABLED
	team_material.transparency = BaseMaterial3D.TRANSPARENCY_DISABLED
	team_indicator.set_surface_override_material(0, team_material)
	team_indicator.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	hp_bar_container.add_child(team_indicator)

func _create_collision() -> void:
	var area = Area3D.new()
	var collision_shape = CollisionShape3D.new()
	
	var shape = CylinderShape3D.new()
	shape.radius = tile_size * 0.4
	shape.height = sprite_height * 2
	collision_shape.shape = shape
	collision_shape.position.y = sprite_height
	
	area.add_child(collision_shape)
	add_child(area)
	
	area.set_meta("unit", self)
	area.collision_layer = 2
	area.collision_mask = 0

# ============================================================================
# RESPIRATION (IDENTIQUE)
# ============================================================================

func _start_breathing_animation() -> void:
	if not sprite_3d:
		return
	
	await get_tree().create_timer(randf_range(0.0, BREATH_DELAY_MAX)).timeout
	
	var hp_percent = get_hp_percentage()
	var breath_speed_multiplier: float
	
	if hp_percent > 0.6:
		breath_speed_multiplier = BREATH_SPEED_HEALTHY
	elif hp_percent > 0.3:
		breath_speed_multiplier = BREATH_SPEED_WOUNDED
	else:
		breath_speed_multiplier = BREATH_SPEED_CRITICAL
	
	var base_breath_duration = randf_range(BREATH_DURATION_MIN, BREATH_DURATION_MAX)
	var breath_duration = base_breath_duration / breath_speed_multiplier
	
	var is_height_breathing = randf() < 0.5
	
	var scale_min = 1.0 - BREATH_INTENSITY
	var scale_max = 1.0 + BREATH_INTENSITY
	
	var base_position_y = sprite_3d.position.y
	set_meta("breathing_base_y", base_position_y)
	
	var tween = sprite_3d.create_tween()
	tween.set_loops()
	
	if is_height_breathing:
		tween.tween_method(_set_height_scale_keep_bottom, 1.0, scale_max, breath_duration / 3.0).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
		tween.tween_method(_set_height_scale_keep_bottom, scale_max, scale_min, breath_duration / 3.0).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
		tween.tween_method(_set_height_scale_keep_bottom, scale_min, 1.0, breath_duration / 3.0).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
	else:
		tween.tween_property(sprite_3d, "scale:x", scale_max, breath_duration / 3.0).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
		tween.tween_property(sprite_3d, "scale:x", scale_min, breath_duration / 3.0).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
		tween.tween_property(sprite_3d, "scale:x", 1.0, breath_duration / 3.0).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
	
	set_meta("breathing_tween", tween)

func _set_height_scale_keep_bottom(new_scale_y: float) -> void:
	if not sprite_3d:
		return
	
	var base_y = get_meta("breathing_base_y", sprite_height)
	var sprite_visual_height = 1.0
	var delta_y = (new_scale_y - 1.0) * sprite_visual_height / 2.0
	
	sprite_3d.scale.y = new_scale_y
	sprite_3d.position.y = base_y + delta_y

# ============================================================================
# PROCESS
# ============================================================================

func _process(_delta: float) -> void:
	if not hp_bar_container:
		return
	
	var camera = get_viewport().get_camera_3d()
	if camera:
		hp_bar_container.global_transform.basis = camera.global_transform.basis

# ============================================================================
# TORUS
# ============================================================================

func update_torus_state(is_current_turn: bool) -> void:
	if not selection_indicator:
		return
	
	if is_selected:
		current_torus_state = TorusState.SELECTED
	elif not is_current_turn:
		current_torus_state = TorusState.ENEMY_TURN
	elif not can_move() and not can_act():
		current_torus_state = TorusState.CANNOT_ACT
	elif can_act() and not can_move():
		current_torus_state = TorusState.CAN_ACT_ONLY
	elif can_move() and not can_act():
		current_torus_state = TorusState.CAN_MOVE_ONLY
	else:
		current_torus_state = TorusState.CAN_ACT_AND_MOVE
	
	_apply_torus_color()

func _apply_torus_color() -> void:
	if not torus_material:
		return
	
	var color = TORUS_COLORS.get(current_torus_state, Color.WHITE)
	torus_material.albedo_color = color
	torus_material.emission = color * 0.8

func set_selected(selected: bool) -> void:
	is_selected = selected
	update_torus_state(true)
	selected_changed.emit(selected)

# ============================================================================
# SANT√â
# ============================================================================

func take_damage(damage: int) -> int:
	var actual_damage = max(1, damage - defense_power)
	current_hp = max(0, current_hp - actual_damage)
	_update_hp_bar()
	
	health_changed.emit(current_hp, max_hp)
	
	GameRoot.global_logger.info("BATTLE_UNIT", "%s prend %d d√©g√¢ts (HP: %d/%d)" % [unit_name, actual_damage, current_hp, max_hp])
	
	_animate_damage()
	
	if current_hp <= 0:
		die()
	
	return actual_damage

func heal(amount: int) -> int:
	var old_hp = current_hp
	current_hp = min(max_hp, current_hp + amount)
	var actual_heal = current_hp - old_hp
	
	_update_hp_bar()
	health_changed.emit(current_hp, max_hp)
	
	GameRoot.global_logger.info("BATTLE_UNIT", "%s soign√© de %d HP" % [unit_name, actual_heal])
	_animate_heal()
	
	return actual_heal

func die() -> void:
	GameRoot.global_logger.info("BATTLE_UNIT", "%s est mort" % unit_name)
	_animate_death()
	died.emit()

func is_alive() -> bool:
	return current_hp > 0

func get_hp_percentage() -> float:
	if max_hp <= 0:
		return 0.0
	return float(current_hp) / float(max_hp)

# ============================================================================
# ‚úÖ SYST√àME DE MANA (SANS R√âG√âN√âRATION)
# ============================================================================

func consume_mana(amount: int) -> bool:
	"""
	Consomme du mana
	@return true si succ√®s, false si mana insuffisant
	"""
	if current_mana < amount:
		GameRoot.global_logger.warning("BATTLE_UNIT", "%s : mana insuffisant (%d/%d)" % [unit_name, current_mana, amount])
		return false
	
	current_mana -= amount
	current_mana = max(0, current_mana)
	
	_update_mana_bar()
	mana_changed.emit(current_mana, max_mana)
	
	GameRoot.global_logger.info("BATTLE_UNIT", "%s consomme %d mana (reste: %d/%d)" % [unit_name, amount, current_mana, max_mana])
	
	_animate_mana_consumption()
	
	return true

func restore_mana(amount: int) -> int:
	"""
	Restaure du mana (via action Puiser ou potion)
	@return Quantit√© r√©ellement restaur√©e
	"""
	var old_mana = current_mana
	current_mana = min(max_mana, current_mana + amount)
	var actual_restore = current_mana - old_mana
	
	_update_mana_bar()
	mana_changed.emit(current_mana, max_mana)
	
	if actual_restore > 0:
		GameRoot.global_logger.info("BATTLE_UNIT", "%s restaure %d mana (%d/%d)" % [unit_name, actual_restore, current_mana, max_mana])
		_animate_mana_restore()
	
	return actual_restore

func get_mana_percentage() -> float:
	if max_mana <= 0:
		return 0.0
	return float(current_mana) / float(max_mana)

func has_enough_mana(amount: int) -> bool:
	return current_mana >= amount

func get_mana_color() -> Color:
	return MANA_COLORS.get(mana_type, Color.CYAN)

# ============================================================================
# BARRE DE HP
# ============================================================================

func _update_hp_bar() -> void:
	if not hp_bar_3d or not hp_bar_3d.mesh or not hp_bar_material:
		return
	
	if max_hp <= 0:
		return
	
	var hp_percent = get_hp_percentage()
	
	var bar_max_width = tile_size * HP_BAR_WIDTH_RATIO
	var box_mesh = hp_bar_3d.mesh as BoxMesh
	
	if box_mesh:
		var current_width = bar_max_width * hp_percent
		box_mesh.size.x = current_width
		
		var offset = (bar_max_width - current_width) / 2.0
		hp_bar_3d.position.x = -offset
	
	if hp_percent > 0.6:
		hp_bar_material.albedo_color = Color.GREEN
	elif hp_percent > 0.3:
		hp_bar_material.albedo_color = Color.YELLOW
	else:
		hp_bar_material.albedo_color = Color.RED

# ============================================================================
# BARRE DE MANA
# ============================================================================

func _update_mana_bar() -> void:
	if not mana_bar_3d or not mana_bar_3d.mesh or not mana_bar_material:
		return
	
	if max_mana <= 0:
		return
	
	var mana_percent = get_mana_percentage()
	
	var bar_max_width = tile_size * HP_BAR_WIDTH_RATIO
	var box_mesh = mana_bar_3d.mesh as BoxMesh
	
	if box_mesh:
		var current_width = bar_max_width * mana_percent
		box_mesh.size.x = current_width
		
		var offset = (bar_max_width - current_width) / 2.0
		mana_bar_3d.position.x = -offset
	
	var base_color = get_mana_color()
	
	if mana_percent < 0.3:
		base_color = base_color.darkened(0.3)
	
	mana_bar_material.albedo_color = base_color
	mana_bar_material.emission = base_color * 0.5

# ============================================================================
# ACTIONS & √âTAT
# ============================================================================

func can_move() -> bool:
	return is_alive() and not movement_used

func can_act() -> bool:
	return is_alive() and not action_used

func can_do_anything() -> bool:
	return can_move() or can_act()

func reset_for_new_turn() -> void:
	"""R√©initialise l'unit√© pour un nouveau tour"""
	
	movement_used = false
	action_used = false
	has_acted_this_turn = false
	
	# Retirer la d√©fense
	if has_meta("is_defending"):
		remove_meta("is_defending")
		remove_meta("defense_bonus")
	
	_process_status_effects()
	update_torus_state(true)
	update_state_indicators() 



func _process_status_effects() -> void:
	var effects_to_remove: Array[String] = []
	
	for effect_name in status_effects:
		status_effects[effect_name] -= 1
		if status_effects[effect_name] <= 0:
			effects_to_remove.append(effect_name)
	
	for effect_name in effects_to_remove:
		remove_status_effect(effect_name)

# ============================================================================
# EFFETS DE STATUT
# ============================================================================

func add_status_effect(effect_name: String, duration: int) -> void:
	status_effects[effect_name] = duration
	status_effect_applied.emit(effect_name)
	GameRoot.global_logger.info("BATTLE_UNIT", "%s : effet ajout√© : %s" % [unit_name, effect_name])

func remove_status_effect(effect_name: String) -> void:
	if status_effects.has(effect_name):
		status_effects.erase(effect_name)
		status_effect_removed.emit(effect_name)
		GameRoot.global_logger.info("BATTLE_UNIT", "%s : effet retir√© : %s" % [unit_name, effect_name])

func has_status_effect(effect_name: String) -> bool:
	return status_effects.has(effect_name)

# ============================================================================
# ANIMATIONS
# ============================================================================

func _animate_damage() -> void:
	var tween = create_tween()
	tween.tween_property(sprite_3d, "modulate", Color(1, 0.3, 0.3), 0.1)
	tween.tween_property(sprite_3d, "modulate", Color(1, 1, 1), 0.1)

func _animate_heal() -> void:
	var tween = create_tween()
	tween.tween_property(sprite_3d, "modulate", Color(0.3, 1, 0.3), 0.1)
	tween.tween_property(sprite_3d, "modulate", Color(1, 1, 1), 0.1)

func _animate_mana_consumption() -> void:
	if not mana_bar_3d:
		return
	
	var tween = create_tween()
	tween.tween_property(mana_bar_3d, "scale", Vector3(0.9, 0.9, 1.0), 0.1)
	tween.tween_property(mana_bar_3d, "scale", Vector3.ONE, 0.1)

func _animate_mana_restore() -> void:
	if not mana_bar_3d:
		return
	
	var tween = create_tween()
	tween.tween_property(mana_bar_3d, "modulate", Color(1.5, 1.5, 1.5), 0.15)
	tween.tween_property(mana_bar_3d, "modulate", Color.WHITE, 0.15)

func _animate_death() -> void:
	var tween = create_tween()
	tween.set_parallel(true)
	
	if sprite_3d:
		tween.tween_property(sprite_3d, "modulate:a", 0.0, 0.5)
	
	if hp_bar_container:
		tween.tween_property(hp_bar_container, "scale", Vector3.ZERO, 0.5)
	
	if selection_indicator:
		tween.tween_property(selection_indicator, "scale", Vector3.ZERO, 0.3)
	
	tween.tween_property(self, "scale", Vector3(0.5, 0.5, 0.5), 0.5)
	
	tween.set_parallel(false)
	tween.tween_callback(queue_free)

# ============================================================================
# DONN√âES
# ============================================================================

func get_unit_data() -> Dictionary:
	return {
		"id": unit_id,
		"name": unit_name,
		"is_player": is_player_unit,
		"position": grid_position,
		"hp": current_hp,
		"max_hp": max_hp,
		"mana": current_mana,
		"max_mana": max_mana,
		"mana_type": mana_type,
		"attack": attack_power,
		"defense": defense_power,
		"movement": movement_range,
		"range": attack_range,
		"abilities": abilities.duplicate(),
		"status_effects": status_effects.duplicate(),
		"can_move": can_move(),
		"can_act": can_act()
	}

func initialize_unit(data: Dictionary) -> void:
	if data.has("name"):
		unit_name = data.name
	if data.has("id"):
		unit_id = data.id
	elif unit_id == "":
		unit_id = unit_name + "_" + str(Time.get_ticks_msec())
	
	if data.has("is_player"):
		is_player_unit = data.is_player
	
	if data.has("position"):
		grid_position = data.position
	
	var temp_max_hp = 100
	var temp_current_hp = -1
	var temp_max_mana = 100
	var temp_current_mana = -1
	
	if data.has("stats"):
		var stats = data.stats
		if stats.has("hp"):
			temp_max_hp = stats.hp
		if stats.has("attack"):
			attack_power = stats.attack
		if stats.has("defense"):
			defense_power = stats.defense
		if stats.has("movement"):
			movement_range = stats.movement
		if stats.has("range"):
			attack_range = stats.range
		if stats.has("mana"):
			temp_max_mana = stats.mana
	
	if data.has("max_hp"):
		temp_max_hp = data.max_hp
	if data.has("hp"):
		temp_current_hp = data.hp
	if data.has("max_mana"):
		temp_max_mana = data.max_mana
	if data.has("mana"):
		temp_current_mana = data.mana
	if data.has("mana_type"):
		mana_type = data.mana_type
	
	max_hp = temp_max_hp
	current_hp = temp_current_hp if temp_current_hp >= 0 else max_hp
	current_hp = min(current_hp, max_hp)
	
	max_mana = temp_max_mana
	current_mana = temp_current_mana if temp_current_mana >= 0 else max_mana
	current_mana = min(current_mana, max_mana)
	
	if data.has("attack"):
		attack_power = data.attack
	if data.has("defense"):
		defense_power = data.defense
	if data.has("movement"):
		movement_range = data.movement
	if data.has("range"):
		attack_range = data.range
	
	if data.has("abilities"):
		abilities.clear()
		var abilities_array = data.abilities
		if abilities_array is Array:
			for ability in abilities_array:
				if ability is String:
					abilities.append(ability)
	
	if data.has("status_effects"):
		status_effects.clear()
		var effects = data.status_effects
		if effects is Dictionary:
			for effect_name in effects:
				status_effects[effect_name] = effects[effect_name]
	
	if data.has("sprite_path"):
		sprite_path = data.sprite_path
	if data.has("sprite_frame"):
		sprite_frame = data.sprite_frame
	if data.has("sprite_hframes"):
		sprite_hframes = data.sprite_hframes
	if data.has("sprite_vframes"):
		sprite_vframes = data.sprite_vframes
	
	if data.has("materialization_ring"):
		equipped_materialization_ring = data.materialization_ring
	if data.has("channeling_ring"):
		equipped_channeling_ring = data.channeling_ring
	
	if data.has("color"):
		if typeof(data.color) == TYPE_DICTIONARY:
			unit_color = Color(
				data.color.get("r", 1.0),
				data.color.get("g", 1.0),
				data.color.get("b", 1.0),
				data.color.get("a", 1.0)
			)
		else:
			unit_color = data.color
	else:
		unit_color = Color(0.2, 0.2, 0.8) if is_player_unit else Color(0.8, 0.2, 0.2)
	
	level = data.get("level", 1)
	xp = data.get("xp", 0)
	
	GameRoot.global_logger.info("BATTLE_UNIT", "Unit√© initialis√©e : %s (ID: %s)" % [unit_name, unit_id])
	GameRoot.global_logger.debug("BATTLE_UNIT", "  ‚Üí HP: %d/%d" % [current_hp, max_hp])
	GameRoot.global_logger.debug("BATTLE_UNIT", "  ‚Üí Mana: %d/%d (%s)" % [current_mana, max_mana, mana_type])

func award_xp(amount: int) -> void:
	if not is_player_unit:
		return
	
	xp += amount
	GameRoot.global_logger.info("BATTLE_UNIT", "%s : +%d XP (Total: %d)" % [unit_name, amount, xp])
	GameRoot.team_manager.add_xp(unit_id, amount)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if has_meta("breathing_tween"):
		var tween = get_meta("breathing_tween") as Tween
		if tween and tween.is_valid():
			tween.kill()
	
	if has_meta("blink_tween"):
		var tween = get_meta("blink_tween") as Tween
		if tween and tween.is_valid():
			tween.kill()
	
	GameRoot.global_logger.debug("BATTLE_UNIT", "Unit√© %s nettoy√©e" % unit_name)

# ============================================================================
# DUO AURA (conserv√©)
# ============================================================================

func show_duo_aura(is_enemy_duo: bool = false) -> void:
	if not sprite_3d:
		return

	if has_meta("duo_aura"):
		var old_aura := get_meta("duo_aura") as Node3D
		if old_aura and is_instance_valid(old_aura):
			_fade_and_destroy_duo_aura(old_aura)
		remove_meta("duo_aura")

	var aura := Node3D.new()
	aura.name = "DuoAura"
	add_child(aura)
	set_meta("duo_aura", aura)

	var base_color := Color(1.0, 0.25, 0.25) if is_enemy_duo else Color(0.25, 0.6, 1.0)

	var beam_count := 14
	var radius := 0.65
	var height := 1.6

	for i in range(beam_count):
		var beam := MeshInstance3D.new()

		var mesh := CylinderMesh.new()
		mesh.top_radius = 0.05
		mesh.bottom_radius = 0.05
		mesh.height = height * randf_range(0.85, 1.1)
		mesh.radial_segments = 12
		beam.mesh = mesh
		beam.cast_shadow = GeometryInstance3D.SHADOW_CASTING_SETTING_OFF

		var angle := TAU * float(i) / beam_count
		beam.position = Vector3(
			cos(angle) * radius,
			mesh.height * 0.5,
			sin(angle) * radius
		)

		beam.position.x += randf_range(-0.05, 0.05)
		beam.position.z += randf_range(-0.05, 0.05)

		beam.rotation.y = angle

		var tilt_strength := 0.25
		beam.rotate_object_local(Vector3.RIGHT, randf_range(-tilt_strength, tilt_strength))
		beam.rotate_object_local(Vector3.FORWARD, randf_range(-tilt_strength, tilt_strength))

		var mat := ShaderMaterial.new()
		mat.shader = preload("res://asset/shader/aura_ring.gdshader")
		mat.set_shader_parameter("base_color", base_color)
		mat.set_shader_parameter("time_offset", randf() * 6.0)
		mat.set_shader_parameter("alpha_multiplier", 0.0)
		beam.material_override = mat

		aura.add_child(beam)

		var fade := aura.create_tween()
		fade.tween_property(
			mat,
			"shader_parameter/alpha_multiplier",
			1.0,
			0.3
		).set_delay(i * 0.025).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

		var sway := beam.create_tween()
		sway.set_loops()
		sway.tween_property(
			beam,
			"rotation:x",
			beam.rotation.x + randf_range(-0.05, 0.05),
			randf_range(1.8, 2.8)
		).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_IN_OUT)

		sway.tween_property(
			beam,
			"rotation:z",
			beam.rotation.z + randf_range(-0.05, 0.05),
			randf_range(1.8, 2.8)
		).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_IN_OUT)

	var pulse := aura.create_tween()
	pulse.set_loops()
	pulse.tween_property(aura, "scale", Vector3(1.05, 1.0, 1.05), 0.9)
	pulse.tween_property(aura, "scale", Vector3.ONE, 0.9)

	var rot := aura.create_tween()
	rot.set_loops()
	rot.tween_property(aura, "rotation:y", TAU, 5.0)

	await get_tree().create_timer(DUO_AURA_LIFETIME).timeout

	if is_instance_valid(aura):
		_fade_and_destroy_duo_aura(aura)

func _fade_and_destroy_duo_aura(aura: Node3D) -> void:
	if not aura or not is_instance_valid(aura):
		return

	var t := aura.create_tween()
	t.tween_property(aura, "scale", Vector3.ZERO, 0.25).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_IN)

	t.tween_callback(func():
		if is_instance_valid(aura):
			aura.queue_free()
	)

func hide_duo_aura() -> void:
	if not has_meta("duo_aura"):
		return

	var aura := get_meta("duo_aura") as Node3D
	if aura and is_instance_valid(aura):
		_fade_and_destroy_duo_aura(aura)

	remove_meta("duo_aura")

func _create_state_indicators() -> void:
	"""Cr√©e les diamants d'√©tat au-dessus de l'unit√©"""
	
	# Diamant bleu (d√©fense)
	defend_indicator = Sprite3D.new()
	defend_indicator.billboard = BaseMaterial3D.BILLBOARD_ENABLED
	defend_indicator.texture = _create_diamond_texture(Color(0.3, 0.6, 1.0))  # Bleu
	defend_indicator.pixel_size = 0.02
	defend_indicator.position = Vector3(0, sprite_height + 1.2, 0)
	defend_indicator.visible = false
	add_child(defend_indicator)
	
	# Diamant rouge (pr√©par√©)
	prepared_indicator = Sprite3D.new()
	prepared_indicator.billboard = BaseMaterial3D.BILLBOARD_ENABLED
	prepared_indicator.texture = _create_diamond_texture(Color(1.0, 0.3, 0.3))  # Rouge
	prepared_indicator.pixel_size = 0.02
	prepared_indicator.position = Vector3(0, sprite_height + 1.2, 0)
	prepared_indicator.visible = false
	add_child(prepared_indicator)
	
func _create_diamond_texture(color: Color) -> ImageTexture:
	"""Cr√©e une texture de diamant"""
	var size = 64
	var image = Image.create(size, size, false, Image.FORMAT_RGBA8)
	image.fill(Color.TRANSPARENT)
	
	var center = size / 2
	
	# Dessiner un losange
	for y in range(size):
		for x in range(size):
			var dx = abs(x - center)
			var dy = abs(y - center)
			
			# Distance Manhattan pour former un losange
			if dx + dy < center:
				var edge_dist = center - (dx + dy)
				var alpha = 1.0
				
				# Bordure plus sombre
				if edge_dist < 3:
					image.set_pixel(x, y, color.darkened(0.5))
				else:
					image.set_pixel(x, y, color)
	
	return ImageTexture.create_from_image(image)

func update_state_indicators() -> void:
	"""Met √† jour la visibilit√© des indicateurs d'√©tat"""
	
	if defend_indicator:
		defend_indicator.visible = has_meta("is_defending")
	
	if prepared_indicator:
		prepared_indicator.visible = has_meta("is_prepared")

# Modifier reset_for_new_turn pour mettre √† jour les indicateurs :
```

## features/combat/visuals/damage_number.gd

```text
extends Node3D
## DamageNumber - Affiche un nombre de d√©g√¢ts avec animation parabolique

class_name DamageNumber

var damage_value: int = 0
var label_3d: Label3D
var lifetime: float = 1.5  # Dur√©e totale de l'animation
var elapsed: float = 0.0

# Param√®tres de la parabole
var start_position: Vector3
var peak_height: float = 2.0
var horizontal_offset: Vector3 = Vector3(0, 0, 0)

func _ready() -> void:
	label_3d = Label3D.new()
	label_3d.billboard = BaseMaterial3D.BILLBOARD_ENABLED
	label_3d.no_depth_test = true
	label_3d.render_priority = 10
	label_3d.outline_size = 4
	label_3d.outline_modulate = Color.BLACK
	add_child(label_3d)

	label_3d.font_size = 48
	label_3d.modulate = Color.YELLOW
	label_3d.text = str(damage_value)

	# ‚úÖ Maintenant le node est dans l‚Äôarbre
	global_position = start_position


func _process(delta: float) -> void:
	elapsed += delta
	
	if elapsed >= lifetime:
		queue_free()
		return
	
	# Progression normalis√©e (0.0 -> 1.0)
	var t = elapsed / lifetime
	
	# Calcul de la parabole (y = -4h * t * (t - 1))
	var parabola = -4.0 * peak_height * t * (t - 1.0)
	
	# Position finale
	var final_pos = start_position + horizontal_offset * t
	final_pos.y += parabola
	
	global_position = final_pos
	
	# Fade out sur la phase descendante (apr√®s t = 0.5)
	if t > 0.5:
		var fade = 1.0 - (t - 0.5) * 2.0  # 1.0 -> 0.0
		label_3d.modulate.a = fade

func setup(damage: int, spawn_pos: Vector3, offset: Vector3 = Vector3.ZERO) -> void:
	"""Configure le nombre de d√©g√¢ts"""
	damage_value = damage
	#global_position = spawn_pos
	start_position = spawn_pos
	horizontal_offset = offset
```

## features/combat/visuals/damage_number.tscn

```text
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" uid="uid://dumnjbl51vvyt" path="res://features/combat/visuals/damage_number.gd" id="1_damage"]

[node name="DamageNumber" type="Node3D"]
script = ExtResource("1_damage")
```

## features/combat/visuals/terrain_module_3d.gd

```text
extends Node3D
## TerrainModule3D - G√®re le terrain 3D avec des cases cubiques
## Version 3D du module original avec MeshInstance3D

class_name TerrainModule3D

# ============================================================================
# SIGNAUX
# ============================================================================

signal generation_complete()
signal tile_changed(grid_pos: Vector2i, tile_type: int)

# ============================================================================
# ENUMS
# ============================================================================

enum TileType {
	GRASS,       # Plaine
	FOREST,      # For√™t
	MOUNTAIN,    # Montagne
	WATER,       # Eau
	ROAD,        # Route
	WALL,        # Mur
	BRIDGE,      # Pont
	CASTLE,      # Ch√¢teau
}

# ============================================================================
# CONFIGURATION
# ============================================================================

var tile_size: float = 1.0  # Taille d'une case en unit√©s 3D
var tile_height: float = 0.2  # Hauteur des cases
var grid_width: int = 20
var grid_height: int = 15

# Co√ªts et bonus (identiques √† la version 2D)
const MOVEMENT_COSTS: Dictionary = {
	TileType.GRASS: 1.0,
	TileType.FOREST: 2.0,
	TileType.MOUNTAIN: 3.0,
	TileType.WATER: INF,
	TileType.ROAD: 0.5,
	TileType.WALL: INF,
	TileType.BRIDGE: 1.0,
	TileType.CASTLE: 1.0,
}

const DEFENSE_BONUS: Dictionary = {
	TileType.GRASS: 0,
	TileType.FOREST: 10,
	TileType.MOUNTAIN: 20,
	TileType.WATER: 0,
	TileType.ROAD: 0,
	TileType.WALL: 0,
	TileType.BRIDGE: 0,
	TileType.CASTLE: 30,
}

# Couleurs des tuiles
const TILE_COLORS: Dictionary = {
	TileType.GRASS: Color(0.2, 0.7, 0.2),
	TileType.FOREST: Color(0.1, 0.5, 0.1),
	TileType.MOUNTAIN: Color(0.5, 0.5, 0.5),
	TileType.WATER: Color(0.2, 0.4, 0.8),
	TileType.ROAD: Color(0.6, 0.5, 0.4),
	TileType.WALL: Color(0.3, 0.3, 0.3),
	TileType.BRIDGE: Color(0.5, 0.4, 0.3),
	TileType.CASTLE: Color(0.7, 0.7, 0.8),
}

# Hauteurs des tuiles (pour variation de terrain)
const TILE_HEIGHTS: Dictionary = {
	TileType.GRASS: 0.0,
	TileType.FOREST: 0.1,
	TileType.MOUNTAIN: 0.5,
	TileType.WATER: -0.1,
	TileType.ROAD: 0.0,
	TileType.WALL: 0.3,
	TileType.BRIDGE: 0.0,
	TileType.CASTLE: 0.2,
}

# ============================================================================
# DONN√âES
# ============================================================================

var grid: Array[Array] = []  # Array 2D de TileType
var tile_meshes: Array[Array] = []  # Array 2D de MeshInstance3D
var tile_materials: Array[Array] = []  # Array 2D de StandardMaterial3D

# Meshes r√©utilisables
var box_mesh: BoxMesh
var plane_mesh: PlaneMesh

# Presets (identiques √† la version 2D)
const PRESETS: Dictionary = {
	"plains": {
		"base": TileType.GRASS,
		"features": [
			{"type": TileType.FOREST, "density": 0.1},
			{"type": TileType.ROAD, "density": 0.05}
		]
	},
	"forest": {
		"base": TileType.FOREST,
		"features": [
			{"type": TileType.GRASS, "density": 0.2},
			{"type": TileType.MOUNTAIN, "density": 0.05}
		]
	},
	"castle": {
		"base": TileType.GRASS,
		"features": [
			{"type": TileType.CASTLE, "positions": [Vector2i(10, 7)]},
			{"type": TileType.WALL, "density": 0.15},
			{"type": TileType.ROAD, "density": 0.1}
		]
	},
	"mountain": {
		"base": TileType.MOUNTAIN,
		"features": [
			{"type": TileType.GRASS, "density": 0.15},
			{"type": TileType.FOREST, "density": 0.1},
			{"type": TileType.ROAD, "density": 0.05}
		]
	}
}

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_setup_meshes()
	_initialize_grid()
	print("[TerrainModule3D] Initialis√© (", grid_width, "x", grid_height, ")")

func _setup_meshes() -> void:
	"""Pr√©pare les meshes r√©utilisables"""
	box_mesh = BoxMesh.new()
	box_mesh.size = Vector3(tile_size * 0.98, tile_height, tile_size * 0.98)
	
	plane_mesh = PlaneMesh.new()
	plane_mesh.size = Vector2(tile_size * 0.95, tile_size * 0.95)

func _initialize_grid() -> void:
	"""Initialise la grille vide"""
	grid.clear()
	tile_meshes.clear()
	tile_materials.clear()
	
	for y in range(grid_height):
		var row: Array[int] = []
		var mesh_row: Array = []
		var mat_row: Array = []
		
		for x in range(grid_width):
			row.append(TileType.GRASS)
			mesh_row.append(null)
			mat_row.append(null)
		
		grid.append(row)
		tile_meshes.append(mesh_row)
		tile_materials.append(mat_row)

# ============================================================================
# CHARGEMENT
# ============================================================================

func load_preset(preset_name: String) -> void:
	"""Charge un terrain pr√©d√©fini"""
	if not PRESETS.has(preset_name):
		push_error("[TerrainModule3D] Preset introuvable: ", preset_name)
		return
	
	var preset = PRESETS[preset_name]
	_generate_from_preset(preset)
	_create_visuals()
	
	generation_complete.emit()
	print("[TerrainModule3D] Preset charg√©: ", preset_name)

func load_custom(terrain_data: Dictionary) -> void:
	"""Charge un terrain personnalis√©"""
	if terrain_data.has("grid"):
		_load_from_grid(terrain_data.grid)
	elif terrain_data.has("base") and terrain_data.has("features"):
		_generate_from_preset(terrain_data)
	else:
		push_error("[TerrainModule3D] Format de terrain invalide")
		return
	
	_create_visuals()
	generation_complete.emit()
	print("[TerrainModule3D] Terrain personnalis√© charg√©")

func _generate_from_preset(preset: Dictionary) -> void:
	"""G√©n√®re le terrain depuis un preset"""
	var base_type = preset.get("base", TileType.GRASS)
	for y in range(grid_height):
		for x in range(grid_width):
			grid[y][x] = base_type
	
	for feature in preset.get("features", []):
		_add_feature(feature)

func _add_feature(feature: Dictionary) -> void:
	"""Ajoute une feature au terrain"""
	var tile_type = feature.get("type", TileType.GRASS)
	
	if feature.has("positions"):
		for pos in feature.positions:
			if _is_valid_position(pos):
				grid[pos.y][pos.x] = tile_type
		return
	
	var density = feature.get("density", 0.1)
	for y in range(grid_height):
		for x in range(grid_width):
			if randf() < density:
				grid[y][x] = tile_type

func _load_from_grid(grid_data: Array) -> void:
	"""Charge depuis une grille pr√©d√©finie"""
	for y in range(min(grid_height, grid_data.size())):
		for x in range(min(grid_width, grid_data[y].size())):
			grid[y][x] = grid_data[y][x]

# ============================================================================
# VISUELS 3D
# ============================================================================

func _create_visuals() -> void:
	"""Cr√©e les meshes 3D pour chaque tuile"""
	# Nettoyer les anciens meshes
	for child in get_children():
		child.queue_free()
	
	# Cr√©er les nouveaux
	for y in range(grid_height):
		for x in range(grid_width):
			var tile_mesh = _create_tile_mesh(Vector2i(x, y))
			tile_meshes[y][x] = tile_mesh
			add_child(tile_mesh)

func _create_tile_mesh(grid_pos: Vector2i) -> MeshInstance3D:
	"""Cr√©e le mesh 3D d'une tuile"""
	var mesh_instance = MeshInstance3D.new()
	var tile_type = grid[grid_pos.y][grid_pos.x]
	
	# Position 3D (centrer la grille)
	var world_pos = grid_to_world(grid_pos)
	var height_offset = TILE_HEIGHTS.get(tile_type, 0.0)
	mesh_instance.position = Vector3(world_pos.x, height_offset, world_pos.y)
	
	# Mesh
	mesh_instance.mesh = box_mesh
	
	# Mat√©riau
	var material = StandardMaterial3D.new()
	material.albedo_color = TILE_COLORS.get(tile_type, Color.WHITE)
	material.metallic = 0.0
	material.roughness = 0.8
	
	# Effets sp√©ciaux pour certains types
	if tile_type == TileType.WATER:
		material.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
		material.albedo_color.a = 0.7
		material.metallic = 0.3
		material.roughness = 0.2
	elif tile_type == TileType.MOUNTAIN:
		material.roughness = 1.0
	
	mesh_instance.set_surface_override_material(0, material)
	tile_materials[grid_pos.y][grid_pos.x] = material
	
	# Collision pour le raycasting
	var static_body = StaticBody3D.new()
	var collision_shape = CollisionShape3D.new()
	var shape = BoxShape3D.new()
	shape.size = Vector3(tile_size, tile_height, tile_size)
	collision_shape.shape = shape
	static_body.add_child(collision_shape)
	mesh_instance.add_child(static_body)
	
	# M√©tadonn√©es pour l'identification
	mesh_instance.set_meta("grid_position", grid_pos)
	mesh_instance.set_meta("tile_type", tile_type)
	
	return mesh_instance

func update_tile_visual(grid_pos: Vector2i) -> void:
	"""Met √† jour le visuel d'une tuile"""
	if not _is_valid_position(grid_pos):
		return
	
	var old_mesh = tile_meshes[grid_pos.y][grid_pos.x]
	if old_mesh:
		old_mesh.queue_free()
	
	var new_mesh = _create_tile_mesh(grid_pos)
	tile_meshes[grid_pos.y][grid_pos.x] = new_mesh
	add_child(new_mesh)

# ============================================================================
# HIGHLIGHTING (coloration des cases)
# ============================================================================

func highlight_tile(grid_pos: Vector2i, color: Color) -> void:
	"""Colore une case (pour mouvement/attaque)"""
	if not _is_valid_position(grid_pos):
		return
	
	var material = tile_materials[grid_pos.y][grid_pos.x]
	if material:
		var original_color = TILE_COLORS.get(grid[grid_pos.y][grid_pos.x], Color.WHITE)
		material.albedo_color = original_color.lerp(color, 0.5)
		material.emission_enabled = true
		material.emission = color * 0.3

func clear_highlight(grid_pos: Vector2i) -> void:
	"""Retire la coloration d'une case"""
	if not _is_valid_position(grid_pos):
		return
	
	var material = tile_materials[grid_pos.y][grid_pos.x]
	if material:
		var tile_type = grid[grid_pos.y][grid_pos.x]
		material.albedo_color = TILE_COLORS.get(tile_type, Color.WHITE)
		material.emission_enabled = false

func highlight_tiles(positions: Array[Vector2i], color: Color) -> void:
	"""Colore plusieurs cases"""
	for pos in positions:
		highlight_tile(pos, color)

func clear_all_highlights() -> void:
	"""Retire toutes les colorations"""
	for y in range(grid_height):
		for x in range(grid_width):
			clear_highlight(Vector2i(x, y))

# ============================================================================
# GETTERS (identiques √† la version 2D)
# ============================================================================

func get_tile_type(grid_pos: Vector2i) -> int:
	if not _is_valid_position(grid_pos):
		return TileType.WALL
	return grid[grid_pos.y][grid_pos.x]

func get_movement_cost(grid_pos: Vector2i) -> float:
	var tile_type = get_tile_type(grid_pos)
	return MOVEMENT_COSTS.get(tile_type, 1.0)

func get_defense_bonus(grid_pos: Vector2i) -> int:
	var tile_type = get_tile_type(grid_pos)
	return DEFENSE_BONUS.get(tile_type, 0)

func is_walkable(grid_pos: Vector2i) -> bool:
	return get_movement_cost(grid_pos) < INF

func is_in_bounds(grid_pos: Vector2i) -> bool:
	return grid_pos.x >= 0 and grid_pos.x < grid_width and \
		   grid_pos.y >= 0 and grid_pos.y < grid_height

# ============================================================================
# CONVERSIONS 3D
# ============================================================================

func grid_to_world(grid_pos: Vector2i) -> Vector2:
	"""Convertit une position grille en position monde 3D (X, Z)"""
	# Centrer la grille autour de l'origine
	var offset_x = (grid_width - 1) * tile_size / 2.0
	var offset_z = (grid_height - 1) * tile_size / 2.0
	
	return Vector2(
		grid_pos.x * tile_size - offset_x,
		grid_pos.y * tile_size - offset_z
	)

func world_to_grid(world_pos: Vector3) -> Vector2i:
	"""Convertit une position monde 3D en position grille"""
	var offset_x = (grid_width - 1) * tile_size / 2.0
	var offset_z = (grid_height - 1) * tile_size / 2.0
	
	var grid_x = int((world_pos.x + offset_x) / tile_size + 0.5)
	var grid_z = int((world_pos.z + offset_z) / tile_size + 0.5)
	
	return Vector2i(grid_x, grid_z)

# ============================================================================
# PATHFINDING HELPERS (identiques √† la version 2D)
# ============================================================================

func get_neighbors(grid_pos: Vector2i) -> Array[Vector2i]:
	var neighbors: Array[Vector2i] = []
	var directions = [
		Vector2i(1, 0), Vector2i(-1, 0),
		Vector2i(0, 1), Vector2i(0, -1)
	]
	
	for dir in directions:
		var neighbor = grid_pos + dir
		if is_in_bounds(neighbor):
			neighbors.append(neighbor)
	
	return neighbors

func get_distance(from: Vector2i, to: Vector2i) -> int:
	return abs(to.x - from.x) + abs(to.y - from.y)

# ============================================================================
# SETTERS
# ============================================================================

func set_tile_type(grid_pos: Vector2i, tile_type: int) -> void:
	if not _is_valid_position(grid_pos):
		return
	
	grid[grid_pos.y][grid_pos.x] = tile_type
	update_tile_visual(grid_pos)
	tile_changed.emit(grid_pos, tile_type)

# ============================================================================
# UTILITAIRES
# ============================================================================

func _is_valid_position(grid_pos: Vector2i) -> bool:
	return is_in_bounds(grid_pos)

func get_random_walkable_position() -> Vector2i:
	for attempt in range(100):
		var pos = Vector2i(randi() % grid_width, randi() % grid_height)
		if is_walkable(pos):
			return pos
	return Vector2i(0, 0)

func clear() -> void:
	for child in get_children():
		child.queue_free()
	_initialize_grid()
	print("[TerrainModule3D] Terrain nettoy√©")
```

## features/debug/debug_version_panel.gd

```text
extends Control

@onready var label = self


func _ready():
	var text := "=== DEBUG VERSION INFO ===\n\n"
	text += load_build_info()
	text += "\n"
	text += load_doc_status()

	label.text = text


func load_build_info() -> String:
	var path = "res://documentation/build_info.json"
	if not FileAccess.file_exists(path):
		return "Build info: NOT AVAILABLE\n"

	var file = FileAccess.open(path, FileAccess.READ)
	if file == null:
		return "Build info: FAILED TO OPEN\n"

	var content = file.get_as_text()
	var data = JSON.parse_string(content)

	if typeof(data) != TYPE_DICTIONARY:
		return "Build info: INVALID JSON\n"

	var text := "=== BUILD INFO ===\n"
	text += "Game Version : %s\n" % data.get("game_version", "unknown")
	text += "Git Commit   : %s\n" % data.get("git_commit", "unknown")
	text += "Git Branch   : %s\n" % data.get("git_branch", "unknown")
	text += "Build Date   : %s\n" % data.get("build_date", "unknown")

	if data.get("git_dirty", false):
		text += "Working Tree : DIRTY ‚ö†Ô∏è\n"
	else:
		text += "Working Tree : CLEAN\n"

	return text


func load_doc_status() -> String:
	var path = "res://documentation/DOCUMENTATION_STATUS.md"
	if not FileAccess.file_exists(path):
		return "Documentation status: NOT AVAILABLE\n"

	var file = FileAccess.open(path, FileAccess.READ)
	if file == null:
		return "Documentation status: FAILED TO OPEN\n"

	return "Documentation status: AVAILABLE\n"
```

## features/Duo/duo_system.gd

```text
# scripts/systems/duo/duo_system.gd
extends Node
class_name DuoSystem

## ‚≠ê MODULE CRITIQUE : Syst√®me de Duo
## G√®re la formation, validation et rupture des duos de combat

# ============================================================================
# SIGNAUX
# ============================================================================

signal duo_formed(duo_data: Dictionary)
signal duo_broken(duo_id: String)
signal roles_swapped(duo_id: String)
signal duo_validation_failed(reason: String)

# ============================================================================
# CONFIGURATION
# ============================================================================

const MAX_DUO_DISTANCE: int = 1  # Distance max en cases (adjacence)
const DUO_FORMATION_COST: int = 0  # Co√ªt en action (0 = gratuit)

# ============================================================================
# DONN√âES
# ============================================================================

## Structure d'un duo
class DuoData:
	var duo_id: String
	var leader: BattleUnit3D
	var support: BattleUnit3D
	var formation_time: float
	var is_active: bool = true
	
	func _init(p_leader: BattleUnit3D, p_support: BattleUnit3D):
		leader = p_leader
		support = p_support
		duo_id = _generate_duo_id(leader, support)
		formation_time = Time.get_unix_time_from_system()
	
	static func _generate_duo_id(unit_a: BattleUnit3D, unit_b: BattleUnit3D) -> String:
		var ids = [unit_a.unit_id, unit_b.unit_id]
		ids.sort()
		return ids[0] + "_" + ids[1]

## Stockage des duos actifs
var active_duos: Dictionary = {}  # duo_id -> DuoData

## R√©f√©rence au terrain (inject√©e)
var terrain_module: TerrainModule3D = null

# ============================================================================
# FORMATION DE DUO
# ============================================================================

func try_form_duo(unit_a: BattleUnit3D, unit_b: BattleUnit3D) -> bool:
	"""
	Tente de former un duo entre deux unit√©s
	
	@return true si succ√®s, false sinon
	"""
	
	# Validation
	var validation_result = validate_duo_formation(unit_a, unit_b)
	
	if not validation_result.is_valid:
		duo_validation_failed.emit(validation_result.reason)
		print("[DuoSystem] ‚ùå Formation √©chou√©e : ", validation_result.reason)
		return false
	
	# Cr√©er le duo
	var duo = DuoData.new(unit_a, unit_b)
	active_duos[duo.duo_id] = duo
	
	# √âmettre le signal
	var duo_dict = _duo_to_dict(duo)
	duo_formed.emit(duo_dict)
	
	print("[DuoSystem] ‚úÖ Duo form√© : ", unit_a.unit_name, " + ", unit_b.unit_name)
	
	return true

func break_duo(duo_id: String) -> void:
	"""Rompt un duo existant"""
	
	if not active_duos.has(duo_id):
		push_warning("[DuoSystem] Duo inexistant : ", duo_id)
		return
	
	var duo = active_duos[duo_id]
	duo.is_active = false
	active_duos.erase(duo_id)
	
	duo_broken.emit(duo_id)
	
	print("[DuoSystem] üíî Duo rompu : ", duo_id)

func swap_roles(duo_id: String) -> bool:
	"""Inverse les r√¥les leader/support"""
	
	if not active_duos.has(duo_id):
		return false
	
	var duo = active_duos[duo_id]
	var temp = duo.leader
	duo.leader = duo.support
	duo.support = temp
	
	roles_swapped.emit(duo_id)
	
	print("[DuoSystem] üîÑ R√¥les invers√©s : ", duo_id)
	
	return true

# ============================================================================
# VALIDATION
# ============================================================================

class DuoValidationResult:
	var is_valid: bool = true
	var reason: String = ""

func validate_duo_formation(unit_a: BattleUnit3D, unit_b: BattleUnit3D) -> DuoValidationResult:
	"""Valide si deux unit√©s peuvent former un duo"""
	
	var result = DuoValidationResult.new()
	
	# V√©rifier que les unit√©s existent
	if not unit_a or not unit_b:
		result.is_valid = false
		result.reason = "Unit√© nulle"
		return result
	
	# V√©rifier que ce sont des unit√©s diff√©rentes
	if unit_a == unit_b:
		result.is_valid = false
		result.reason = "M√™me unit√©"
		return result
	
	# V√©rifier la m√™me √©quipe
	if not validate_same_team(unit_a, unit_b):
		result.is_valid = false
		result.reason = "√âquipes diff√©rentes"
		return result
	
	# V√©rifier disponibilit√©
	if not validate_availability(unit_a, unit_b):
		result.is_valid = false
		result.reason = "Unit√©(s) d√©j√† en duo"
		return result
	
	# V√©rifier adjacence
	if not validate_adjacency(unit_a, unit_b):
		result.is_valid = false
		result.reason = "Unit√©s trop √©loign√©es"
		return result
	
	return result

func validate_adjacency(unit_a: BattleUnit3D, unit_b: BattleUnit3D) -> bool:
	"""V√©rifie si deux unit√©s sont adjacentes"""
	
	if not terrain_module:
		push_error("[DuoSystem] TerrainModule non inject√©!")
		return false
	
	var distance = terrain_module.get_distance(
		unit_a.grid_position,
		unit_b.grid_position
	)
	
	return distance <= MAX_DUO_DISTANCE

func validate_same_team(unit_a: BattleUnit3D, unit_b: BattleUnit3D) -> bool:
	"""V√©rifie si deux unit√©s sont dans la m√™me √©quipe"""
	return unit_a.is_player_unit == unit_b.is_player_unit

func validate_availability(unit_a: BattleUnit3D, unit_b: BattleUnit3D) -> bool:
	"""V√©rifie qu'aucune unit√© n'est d√©j√† en duo"""
	
	for duo_id in active_duos:
		var duo = active_duos[duo_id]
		
		if duo.leader == unit_a or duo.support == unit_a:
			return false
		
		if duo.leader == unit_b or duo.support == unit_b:
			return false
	
	return true

# ============================================================================
# GETTERS
# ============================================================================

func get_duo_for_unit(unit: BattleUnit3D) -> Dictionary:
	"""Retourne le duo contenant cette unit√©, ou {} si aucun"""
	
	for duo_id in active_duos:
		var duo = active_duos[duo_id]
		
		if duo.leader == unit or duo.support == unit:
			return _duo_to_dict(duo)
	
	return {}

func get_all_active_duos() -> Array[Dictionary]:
	"""Retourne tous les duos actifs"""
	
	var result: Array[Dictionary] = []
	
	for duo_id in active_duos:
		result.append(_duo_to_dict(active_duos[duo_id]))
	
	return result

func is_unit_in_duo(unit: BattleUnit3D) -> bool:
	"""V√©rifie si une unit√© est dans un duo"""
	return not get_duo_for_unit(unit).is_empty()

func get_duo_by_id(duo_id: String) -> Dictionary:
	"""Retourne un duo par son ID"""
	
	if active_duos.has(duo_id):
		return _duo_to_dict(active_duos[duo_id])
	
	return {}

# ============================================================================
# HELPERS
# ============================================================================

func _duo_to_dict(duo: DuoData) -> Dictionary:
	"""Convertit un DuoData en Dictionary"""
	
	return {
		"duo_id": duo.duo_id,
		"leader": duo.leader,
		"support": duo.support,
		"formation_time": duo.formation_time,
		"is_active": duo.is_active
	}

func clear_all_duos() -> void:
	"""Rompt tous les duos (fin de combat)"""
	
	var duo_ids = active_duos.keys()
	
	for duo_id in duo_ids:
		break_duo(duo_id)
	
	print("[DuoSystem] üßπ Tous les duos rompus")

# ============================================================================
# DEBUG
# ============================================================================

func debug_print_duos() -> void:
	"""Affiche tous les duos actifs (debug)"""
	
	print("\n=== DuoSystem - Duos Actifs ===")
	print("Nombre de duos : ", active_duos.size())
	
	for duo_id in active_duos:
		var duo = active_duos[duo_id]
		print("  - ", duo.leader.unit_name, " + ", duo.support.unit_name)
	
	print("================================\n")
```

## features/Duo/ring_system.gd

```text
# scripts/systems/ring/ring_system.gd
extends Node
class_name RingSystem

## ‚≠ê MODULE CRITIQUE : Syst√®me des Anneaux
## G√®re les anneaux de mat√©rialisation et canalisation

# ============================================================================
# SIGNAUX
# ============================================================================

signal rings_loaded(count: int)
signal ring_equipped(unit_id: String, ring_id: String, slot: String)
signal attack_profile_generated(profile: AttackProfile)

# ============================================================================
# STRUCTURES DE DONN√âES
# ============================================================================

## Anneau de Mat√©rialisation (forme d'attaque)
class MaterializationRing:
	var ring_id: String
	var ring_name: String
	var attack_shape: String  # "line", "cone", "circle", "cross"
	var base_range: int
	var area_size: int
	var description: String
	
	func _init(data: Dictionary):
		ring_id = data.get("ring_id", "")
		ring_name = data.get("ring_name", "Unknown Ring")
		attack_shape = data.get("attack_shape", "line")
		base_range = data.get("base_range", 1)
		area_size = data.get("area_size", 1)
		description = data.get("description", "")

## Anneau de Canalisation (effet mana)
class ChannelingRing:
	var ring_id: String
	var ring_name: String
	var mana_effect_id: String
	var mana_potency: float
	var effect_duration: float
	var description: String
	
	func _init(data: Dictionary):
		ring_id = data.get("ring_id", "")
		ring_name = data.get("ring_name", "Unknown Ring")
		mana_effect_id = data.get("mana_effect_id", "")
		mana_potency = data.get("mana_potency", 1.0)
		effect_duration = data.get("effect_duration", 3.0)
		description = data.get("description", "")

## Profil d'Attaque Combin√©
class AttackProfile:
	var shape: String
	var range: int
	var area: int
	var mana_effect: String
	var potency: float
	var duration: float
	
	func _init():
		shape = "line"
		range = 1
		area = 1
		mana_effect = ""
		potency = 1.0
		duration = 3.0

# ============================================================================
# DONN√âES
# ============================================================================

var materialization_rings: Dictionary = {}  # ring_id -> MaterializationRing
var channeling_rings: Dictionary = {}  # ring_id -> ChannelingRing

var json_loader: JSONDataLoader = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	json_loader = JSONDataLoader.new()
	print("[RingSystem] ‚úÖ Initialis√©")

# ============================================================================
# CHARGEMENT
# ============================================================================

func load_rings_from_json(json_path: String) -> bool:
	"""
	Charge tous les anneaux depuis un fichier JSON
	
	Format attendu:
	{
		"materialization_rings": [...],
		"channeling_rings": [...]
	}
	"""
	
	var data = json_loader.load_json_file(json_path, true)
	
	if typeof(data) != TYPE_DICTIONARY or data.is_empty():
		push_error("[RingSystem] ‚ùå Impossible de charger : ", json_path)
		return false
	
	# Charger anneaux de mat√©rialisation
	if data.has("materialization_rings"):
		for ring_data in data.materialization_rings:
			var ring = MaterializationRing.new(ring_data)
			materialization_rings[ring.ring_id] = ring
	
	# Charger anneaux de canalisation
	if data.has("channeling_rings"):
		for ring_data in data.channeling_rings:
			var ring = ChannelingRing.new(ring_data)
			channeling_rings[ring.ring_id] = ring
	
	var total_count = materialization_rings.size() + channeling_rings.size()
	rings_loaded.emit(total_count)
	
	print("[RingSystem] ‚úÖ Charg√© : ", materialization_rings.size(), " mat√©rialisation + ", channeling_rings.size(), " canalisation")
	
	return true

# ============================================================================
# GETTERS
# ============================================================================

func get_materialization_ring(ring_id: String) -> MaterializationRing:
	"""Retourne un anneau de mat√©rialisation"""
	
	if materialization_rings.has(ring_id):
		return materialization_rings[ring_id]
	
	push_warning("[RingSystem] Anneau de mat√©rialisation introuvable : ", ring_id)
	return null

func get_channeling_ring(ring_id: String) -> ChannelingRing:
	"""Retourne un anneau de canalisation"""
	
	if channeling_rings.has(ring_id):
		return channeling_rings[ring_id]
	
	push_warning("[RingSystem] Anneau de canalisation introuvable : ", ring_id)
	return null

func get_all_materialization_rings() -> Array:
	"""Retourne tous les anneaux de mat√©rialisation"""
	return materialization_rings.values()

func get_all_channeling_rings() -> Array:
	"""Retourne tous les anneaux de canalisation"""
	return channeling_rings.values()

# ============================================================================
# G√âN√âRATION DE PROFIL D'ATTAQUE
# ============================================================================

func generate_attack_profile(mat_ring_id: String, chan_ring_id: String) -> AttackProfile:
	"""
	Combine deux anneaux pour g√©n√©rer un profil d'attaque
	
	@param mat_ring_id : ID de l'anneau de mat√©rialisation
	@param chan_ring_id : ID de l'anneau de canalisation
	@return AttackProfile combin√©
	"""
	
	var mat_ring = get_materialization_ring(mat_ring_id)
	var chan_ring = get_channeling_ring(chan_ring_id)
	
	var profile = AttackProfile.new()
	
	# Donn√©es de mat√©rialisation
	if mat_ring:
		profile.shape = mat_ring.attack_shape
		profile.range = mat_ring.base_range
		profile.area = mat_ring.area_size
	
	# Donn√©es de canalisation
	if chan_ring:
		profile.mana_effect = chan_ring.mana_effect_id
		profile.potency = chan_ring.mana_potency
		profile.duration = chan_ring.effect_duration
	
	attack_profile_generated.emit(profile)
	
	return profile

# ============================================================================
# √âQUIPEMENT (pour plus tard)
# ============================================================================

## Stockage temporaire des √©quipements
var unit_equipment: Dictionary = {}  # unit_id -> {"mat": ring_id, "chan": ring_id}

func equip_materialization_ring(unit_id: String, ring_id: String) -> bool:
	"""√âquipe un anneau de mat√©rialisation √† une unit√©"""
	
	if not materialization_rings.has(ring_id):
		return false
	
	if not unit_equipment.has(unit_id):
		unit_equipment[unit_id] = {}
	
	unit_equipment[unit_id]["mat"] = ring_id
	ring_equipped.emit(unit_id, ring_id, "materialization")
	
	return true

func equip_channeling_ring(unit_id: String, ring_id: String) -> bool:
	"""√âquipe un anneau de canalisation √† une unit√©"""
	
	if not channeling_rings.has(ring_id):
		return false
	
	if not unit_equipment.has(unit_id):
		unit_equipment[unit_id] = {}
	
	unit_equipment[unit_id]["chan"] = ring_id
	ring_equipped.emit(unit_id, ring_id, "channeling")
	
	return true

func get_unit_rings(unit_id: String) -> Dictionary:
	"""Retourne les anneaux √©quip√©s par une unit√©"""
	return unit_equipment.get(unit_id, {})

# ============================================================================
# DEBUG
# ============================================================================

func debug_print_rings() -> void:
	"""Affiche tous les anneaux (debug)"""
	
	print("\n=== RingSystem - Anneaux ===")
	print("Mat√©rialisation (", materialization_rings.size(), "):")
	for ring_id in materialization_rings:
		var ring = materialization_rings[ring_id]
		print("  - ", ring.ring_name, " (", ring.attack_shape, ", range:", ring.base_range, ")")
	
	print("\nCanalisation (", channeling_rings.size(), "):")
	for ring_id in channeling_rings:
		var ring = channeling_rings[ring_id]
		print("  - ", ring.ring_name, " (", ring.mana_effect_id, ", potency:", ring.mana_potency, ")")
	
	print("=============================\n")
```

## features/Duo/ui/battle_results.gd

```text
# scenes/battle/battle_results.gd
extends Control
class_name BattleResults

# ============================================================================
# R√âF√âRENCES UI
# ============================================================================

@onready var title_label: Label = $MarginContainer/VBoxContainer/TitleLabel
@onready var winner_label: Label = $MarginContainer/VBoxContainer/WinnerLabel
@onready var fallen_units_container: VBoxContainer = $MarginContainer/VBoxContainer/Panel/MarginContainer/ScrollContainer/FallenUnitsList
@onready var xp_label: Label = $MarginContainer/VBoxContainer/XPLabel
@onready var continue_button: Button = $MarginContainer/VBoxContainer/ContinueButton

# ============================================================================
# DONN√âES
# ============================================================================

var battle_results: Dictionary = {}

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	# Connecter le bouton
	if continue_button:
		continue_button.pressed.connect(_on_continue_pressed)
	
	# R√©cup√©rer les r√©sultats depuis BattleDataManager ou autre
	# Pour l'instant, on va utiliser des donn√©es de test si non disponibles
	if BattleDataManager.has_battle_data():
		var battle_data = BattleDataManager.get_battle_data()
		battle_results = battle_data.get("results", {})
	
	# Afficher les r√©sultats
	_display_results()

# ============================================================================
# AFFICHAGE
# ============================================================================

func _display_results() -> void:
	"""Affiche tous les r√©sultats du combat"""
	
	# Titre du combat
	var battle_title = battle_results.get("battle_title", "Combat Termin√©")
	if title_label:
		title_label.text = battle_title
	
	# √âquipe gagnante
	var is_victory = battle_results.get("victory", false)
	var winner_team = "L'√âquipe du Joueur" if is_victory else "L'√âquipe Ennemie"
	
	if winner_label:
		winner_label.text = "Vainqueur : " + winner_team
		
		# Colorer selon le r√©sultat
		if is_victory:
			winner_label.add_theme_color_override("font_color", Color(0.3, 1.0, 0.3))  # Vert
		else:
			winner_label.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))  # Rouge
	
	# Unit√©s tomb√©es au combat
	_display_fallen_units()
	
	# XP gagn√©
	var xp_earned = battle_results.get("xp_earned", 0)
	
	# Si pas de calcul d'XP, inventer un chiffre bas√© sur les stats
	if xp_earned == 0 and is_victory:
		var stats = battle_results.get("stats", {})
		var global_stats = stats.get("global", {})
		var turns = global_stats.get("turns_elapsed", 1)
		var enemies_killed = global_stats.get("units_killed", 0)
		
		# Formule simple : 50 XP de base + 10 par ennemi tu√© + bonus de rapidit√©
		xp_earned = 50 + (enemies_killed * 10)
		
		# Bonus si victoire rapide (moins de 10 tours)
		if turns < 10:
			xp_earned += 50
	
	if xp_label:
		xp_label.text = "XP Gagn√© : " + str(xp_earned)

func _display_fallen_units() -> void:
	"""Affiche la liste des unit√©s tomb√©es au combat"""
	
	if not fallen_units_container:
		return
	
	# Nettoyer le conteneur
	for child in fallen_units_container.get_children():
		child.queue_free()
	
	# R√©cup√©rer les stats des unit√©s
	var stats = battle_results.get("stats", {})
	var unit_summaries = stats.get("units", [])
	
	# Filtrer les unit√©s mortes
	var fallen: Array[Dictionary] = []
	
	for unit_summary in unit_summaries:
		if not unit_summary.get("is_alive", true):
			fallen.append(unit_summary)
	
	# Afficher un message si aucune unit√© n'est tomb√©e
	if fallen.is_empty():
		var no_casualties_label = Label.new()
		no_casualties_label.text = "Aucune perte !"
		no_casualties_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		no_casualties_label.add_theme_font_size_override("font_size", 18)
		no_casualties_label.add_theme_color_override("font_color", Color(0.3, 1.0, 0.3))
		fallen_units_container.add_child(no_casualties_label)
		return
	
	# Cr√©er une entr√©e pour chaque unit√© tomb√©e
	for unit in fallen:
		var unit_entry = _create_fallen_unit_entry(unit)
		fallen_units_container.add_child(unit_entry)

func _create_fallen_unit_entry(unit: Dictionary) -> HBoxContainer:
	"""Cr√©e une entr√©e visuelle pour une unit√© tomb√©e"""
	
	var container = HBoxContainer.new()
	container.custom_minimum_size = Vector2(0, 40)
	
	# Ic√¥ne (skull emoji)
	var icon_label = Label.new()
	icon_label.text = "üíÄ"
	icon_label.custom_minimum_size = Vector2(40, 0)
	container.add_child(icon_label)
	
	# Nom de l'unit√©
	var name_label = Label.new()
	var unit_name = unit.get("name", "Inconnu")
	var is_player = unit.get("is_player", false)
	var team_tag = "[Joueur]" if is_player else "[Ennemi]"
	
	name_label.text = unit_name + " " + team_tag
	name_label.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	# Colorer selon l'√©quipe
	if is_player:
		name_label.add_theme_color_override("font_color", Color(0.7, 0.7, 1.0))
	else:
		name_label.add_theme_color_override("font_color", Color(1.0, 0.7, 0.7))
	
	container.add_child(name_label)
	
	# Stats finales (d√©g√¢ts inflig√©s, etc.)
	var stats_label = Label.new()
	var damage_dealt = unit.get("damage_dealt", 0)
	var kills = unit.get("kills", 0)
	
	stats_label.text = "DMG: %d | Kills: %d" % [damage_dealt, kills]
	stats_label.add_theme_font_size_override("font_size", 14)
	stats_label.add_theme_color_override("font_color", Color(0.7, 0.7, 0.7))
	container.add_child(stats_label)
	
	return container

# ============================================================================
# CALLBACKS
# ============================================================================

func _on_continue_pressed() -> void:
	"""Retour √† la carte du monde"""
	GameRoot.event_bus.change_scene(SceneRegistry.SceneID.WORLD_MAP)

# ============================================================================
# SETUP EXTERNE
# ============================================================================

func setup_results(results: Dictionary) -> void:
	"""Configure les r√©sultats depuis l'ext√©rieur"""
	battle_results = results
	
	if is_inside_tree():
		_display_results()
```

## features/Duo/ui/battle_results.tscn

```text
[gd_scene load_steps=3 format=3]

[ext_resource type="Script" uid="uid://cato3lg6g6mx1" path="res://features/Duo/ui/battle_results.gd" id="1_script"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_panel"]
bg_color = Color(0.1, 0.1, 0.12, 0.95)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.7, 0.7, 0.8, 1)
corner_radius_top_left = 12
corner_radius_top_right = 12
corner_radius_bottom_right = 12
corner_radius_bottom_left = 12

[node name="BattleResults" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.07, 1)

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 100
theme_override_constants/margin_top = 50
theme_override_constants/margin_right = 100
theme_override_constants/margin_bottom = 50

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 30

[node name="TitleLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.9, 0.5, 1)
theme_override_font_sizes/font_size = 48
text = "Combat Termin√©"
horizontal_alignment = 1

[node name="WinnerLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Vainqueur : L'√âquipe du Joueur"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
theme_override_font_sizes/font_size = 24
text = "‚ö∞Ô∏è Unit√©s Tomb√©es au Combat"
horizontal_alignment = 1

[node name="Panel" type="PanelContainer" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
theme_override_styles/panel = SubResource("StyleBoxFlat_panel")

[node name="MarginContainer" type="MarginContainer" parent="MarginContainer/VBoxContainer/Panel"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="ScrollContainer" type="ScrollContainer" parent="MarginContainer/VBoxContainer/Panel/MarginContainer"]
layout_mode = 2

[node name="FallenUnitsList" type="VBoxContainer" parent="MarginContainer/VBoxContainer/Panel/MarginContainer/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 10

[node name="HSeparator2" type="HSeparator" parent="MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="XPLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 1, 0.5, 1)
theme_override_font_sizes/font_size = 28
text = "XP Gagn√© : 150"
horizontal_alignment = 1

[node name="ContinueButton" type="Button" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(300, 60)
layout_mode = 2
size_flags_horizontal = 4
theme_override_font_sizes/font_size = 24
text = "‚ûú Continuer"
```

## features/Duo/ui/character_mini_card.gd

```text
extends PanelContainer
## CharacterMiniCard - Mini-fiche d'un personnage pour le menu de duo
## Affiche portrait, nom, classe et stats principales

class_name CharacterMiniCard

# ============================================================================
# R√âF√âRENCES UI
# ============================================================================

@onready var portrait: TextureRect = $MarginContainer/VBoxContainer/Portrait
@onready var name_label: Label = $MarginContainer/VBoxContainer/NameLabel
@onready var class_label: Label = $MarginContainer/VBoxContainer/ClassLabel
@onready var hp_label: Label = $MarginContainer/VBoxContainer/StatsGrid/HPValue
@onready var atk_label: Label = $MarginContainer/VBoxContainer/StatsGrid/ATKValue
@onready var def_label: Label = $MarginContainer/VBoxContainer/StatsGrid/DEFValue
@onready var mana_label: Label = $MarginContainer/VBoxContainer/StatsGrid/ManaValue 


# ============================================================================
# CONFIGURATION
# ============================================================================

@export var card_width: int = 180
@export var portrait_size: Vector2 = Vector2(80, 80)

# ============================================================================
# DONN√âES
# ============================================================================

var unit_data: Dictionary = {}

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	custom_minimum_size = Vector2(card_width, 0)
	if portrait:
		portrait.custom_minimum_size = portrait_size

# ============================================================================
# SETUP
# ============================================================================

func setup_from_unit(unit: BattleUnit3D) -> void:
	if not is_inside_tree():
		await ready
	
	if name_label:
		name_label.text = unit.unit_name
	
	if class_label:
		var unit_class = unit.get_meta("unit_class", "Guerrier")
		class_label.text = unit_class
	
	if hp_label:
		hp_label.text = "%d/%d" % [unit.current_hp, unit.max_hp]
		_colorize_hp(unit.current_hp, unit.max_hp)
	
	# ‚úÖ NOUVEAU : Mana
	if mana_label:
		mana_label.text = "%d/%d (%s)" % [unit.current_mana, unit.max_mana, unit.mana_type.capitalize()]
		_colorize_mana(unit.current_mana, unit.max_mana, unit.mana_type)
	
	if atk_label:
		atk_label.text = str(unit.attack_power)
	
	if def_label:
		def_label.text = str(unit.defense_power)
	
	_set_portrait_from_unit(unit)

func setup_from_data(data: Dictionary) -> void:
	"""Configure la carte √† partir d'un dictionnaire de donn√©es"""
	
	unit_data = data
	
	if not is_inside_tree():
		await ready
	
	# Nom
	if name_label:
		name_label.text = data.get("name", "Unknown")
	
	# Classe
	if class_label:
		class_label.text = data.get("class", "Guerrier")
	
	# Stats
	var stats = data.get("stats", {})
	
	if hp_label:
		var current_hp = data.get("current_hp", stats.get("hp", 100))
		var max_hp = stats.get("hp", 100)
		hp_label.text = "%d/%d" % [current_hp, max_hp]
		_colorize_hp(current_hp, max_hp)
	
	if atk_label:
		atk_label.text = str(stats.get("attack", 0))
	
	if def_label:
		def_label.text = str(stats.get("defense", 0))
	
	# Portrait
	var portrait_path = data.get("portrait", "")
	if portrait_path != "":
		_set_portrait(portrait_path)

# ============================================================================
# HELPERS
# ============================================================================

func _set_portrait_from_unit(unit: BattleUnit3D) -> void:
	if not portrait:
		return
	
	# ‚úÖ NOUVEAU : Capturer le sprite de l'unit√©
	if unit.sprite_3d and unit.sprite_3d.texture:
		var sprite_texture = unit.sprite_3d.texture
		portrait.texture = sprite_texture
		
		# Si c'est un sprite sheet, utiliser la m√™me frame
		if unit.sprite_3d.hframes > 1 or unit.sprite_3d.vframes > 1:
			# Cr√©er un AtlasTexture pour afficher la bonne frame
			var atlas = AtlasTexture.new()
			atlas.atlas = sprite_texture
			
			var frame_width = sprite_texture.get_width() / unit.sprite_3d.hframes
			var frame_height = sprite_texture.get_height() / unit.sprite_3d.vframes
			
			var frame_x = (unit.sprite_frame % unit.sprite_3d.hframes) * frame_width
			var frame_y = (unit.sprite_frame / unit.sprite_3d.hframes) * frame_height
			
			atlas.region = Rect2(frame_x, frame_y, frame_width, frame_height)
			portrait.texture = atlas
		
		return
	
	# Fallback : couleur unie
	if unit.has_meta("portrait"):
		var portrait_path = unit.get_meta("portrait")
		_set_portrait(portrait_path)

func _set_portrait(path: String) -> void:
	"""Charge une texture de portrait"""
	
	if not portrait or path == "":
		return
	
	if ResourceLoader.exists(path):
		var texture = load(path)
		if texture is Texture2D:
			portrait.texture = texture

func _colorize_hp(current: int, maximum: int) -> void:
	"""Colorie le label HP selon le pourcentage"""
	
	if not hp_label:
		return
	
	var percent = float(current) / float(maximum)
	
	if percent > 0.7:
		hp_label.add_theme_color_override("font_color", Color(0.5, 1.0, 0.5))  # Vert
	elif percent > 0.3:
		hp_label.add_theme_color_override("font_color", Color(1.0, 1.0, 0.5))  # Jaune
	else:
		hp_label.add_theme_color_override("font_color", Color(1.0, 0.5, 0.5))  # Rouge

# ============================================================================
# CLEAR
# ============================================================================

func clear() -> void:
	"""R√©initialise la carte"""
	
	if name_label:
		name_label.text = "---"
	if class_label:
		class_label.text = "---"
	if hp_label:
		hp_label.text = "--/--"
	if atk_label:
		atk_label.text = "--"
	if def_label:
		def_label.text = "--"
	if portrait:
		portrait.texture = null


func _colorize_mana(current: int, maximum: int, mana_type: String) -> void:
	if not mana_label:
		return
	
	# Utiliser la couleur du type de mana
	var mana_colors = {
		"neutral": Color(0.8, 0.8, 1.0),
		"fire": Color(1.0, 0.3, 0.1),
		"ice": Color(0.2, 0.7, 1.0),
		"lightning": Color(1.0, 1.0, 0.3),
	}
	
	var color = mana_colors.get(mana_type, Color(0.5, 0.8, 1.0))
	mana_label.add_theme_color_override("font_color", color)
```

## features/Duo/ui/character_mini_card.tscn

```text
[gd_scene load_steps=3 format=3 uid="uid://s2v7pw0kg1jp"]

[ext_resource type="Script" uid="uid://cu8ujnyywytvb" path="res://features/Duo/ui/character_mini_card.gd" id="1_script"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_card"]
bg_color = Color(0.15, 0.15, 0.18, 0.95)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.6, 0.6, 0.7, 1)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[node name="CharacterMiniCard" type="PanelContainer"]
custom_minimum_size = Vector2(180, 0)
theme_override_styles/panel = SubResource("StyleBoxFlat_card")
script = ExtResource("1_script")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 15
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 15
theme_override_constants/margin_bottom = 15

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="Portrait" type="TextureRect" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(80, 80)
layout_mode = 2
size_flags_horizontal = 4
expand_mode = 1
stretch_mode = 5

[node name="NameLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.9, 0.6, 1)
theme_override_font_sizes/font_size = 18
text = "Nom"
horizontal_alignment = 1

[node name="ClassLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
theme_override_font_sizes/font_size = 14
text = "Classe"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="StatsGrid" type="GridContainer" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 5
columns = 2

[node name="HPLabel" type="Label" parent="MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "HP:"

[node name="HPValue" type="Label" parent="MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 1, 0.5, 1)
theme_override_font_sizes/font_size = 14
text = "--/--"

[node name="ManaLabel" type="Label" parent="MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "Mana:"

[node name="ManaValue" type="Label" parent="MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 0.8, 1, 1)
theme_override_font_sizes/font_size = 14
text = "--/--"

[node name="ATKLabel" type="Label" parent="MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "ATK:"

[node name="ATKValue" type="Label" parent="MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "--"

[node name="DEFLabel" type="Label" parent="MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "DEF:"

[node name="DEFValue" type="Label" parent="MarginContainer/VBoxContainer/StatsGrid"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "--"
```

## features/Duo/ui/duo_attack_option.gd

```text
extends Button
## DuoAttackOption - Bouton unique pour s√©lectionner une combinaison Mana + Arme

class_name DuoAttackOption

signal option_selected(mana_ring_id: String, weapon_ring_id: String)
signal option_hovered(partner: BattleUnit3D)
signal option_unhovered(partner: BattleUnit3D)  # ‚úÖ NOUVEAU

@onready var mana_name_label: Label = $HBoxContainer/ManaSection/ManaName
@onready var weapon_name_label: Label = $HBoxContainer/WeaponSection/WeaponName

var mana_ring_id: String = ""
var weapon_ring_id: String = ""
var partner_unit: BattleUnit3D = null

func _ready() -> void:
	pressed.connect(_on_pressed)
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)  # ‚úÖ NOUVEAU

func setup(mana_data: Dictionary, weapon_data: Dictionary, partner: BattleUnit3D = null) -> void:
	"""Configure le bouton avec les donn√©es de mana et d'arme"""
	
	mana_ring_id = mana_data.get("ring_id", "")
	weapon_ring_id = weapon_data.get("ring_id", "")
	partner_unit = partner
	
	mana_name_label.text = mana_data.get("ring_name", "Inconnu")
	weapon_name_label.text = weapon_data.get("ring_name", "Inconnu")

func _on_pressed() -> void:
	option_selected.emit(mana_ring_id, weapon_ring_id)

func _on_mouse_entered() -> void:
	if partner_unit:
		option_hovered.emit(partner_unit)

# ‚úÖ NOUVEAU
func _on_mouse_exited() -> void:
	if partner_unit:
		option_unhovered.emit(partner_unit)
```

## features/Duo/ui/duo_attack_option.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://d1m1nyasv52ue"]

[ext_resource type="Script" uid="uid://cp5lvmnbwkp2w" path="res://features/Duo/ui/duo_attack_option.gd" id="1"]

[node name="DuoAttackOption" type="Button"]
custom_minimum_size = Vector2(400, 80)
theme_override_font_sizes/font_size = 18
script = ExtResource("1")

[node name="HBoxContainer" type="HBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 10.0
offset_top = 10.0
offset_right = -10.0
offset_bottom = -10.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 20

[node name="ManaSection" type="VBoxContainer" parent="HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ManaLabel" type="Label" parent="HBoxContainer/ManaSection"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "üíß MANA"
horizontal_alignment = 1

[node name="ManaName" type="Label" parent="HBoxContainer/ManaSection"]
layout_mode = 2
theme_override_colors/font_color = Color(0.4, 0.8, 1, 1)
theme_override_font_sizes/font_size = 16
text = "Feu"
horizontal_alignment = 1

[node name="Separator" type="VSeparator" parent="HBoxContainer"]
layout_mode = 2

[node name="WeaponSection" type="VBoxContainer" parent="HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="WeaponLabel" type="Label" parent="HBoxContainer/WeaponSection"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "‚öîÔ∏è ARME"
horizontal_alignment = 1

[node name="WeaponName" type="Label" parent="HBoxContainer/WeaponSection"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.8, 0.4, 1)
theme_override_font_sizes/font_size = 16
text = "√âp√©e"
horizontal_alignment = 1
```

## features/menu/main_menu.gd

```text
extends Control
## Menu Principal - Point d'entr√©e du jeu
##
## Le bouton "Nouvelle Partie" √©met game_started via EventBus.
## CampaignManager re√ßoit ce signal et orchestre la s√©quence d'intro
## (dialogues via DialogueManager, UI via UIManager, puis transition vers WorldMap)

class_name MainMenu

# R√©f√©rences aux n≈ìuds UI
@onready var start_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/StartButton
@onready var continue_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/ContinueButton
@onready var options_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/OptionsButton
@onready var credits_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/CreditsButton
@onready var quit_button: Button = $MarginContainer/VBoxContainer/ButtonsContainer/QuitButton
@onready var title_label: Label = $MarginContainer/VBoxContainer/TitleLabel
@onready var version_label: Label = $MarginContainer/VBoxContainer/VersionLabel

var has_save: bool = false

func _ready() -> void:
	_check_save_availability()
	_connect_buttons()
	_play_intro_animation()
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("game_started", _on_game_started)
		GameRoot.event_bus.safe_connect("game_loaded", _on_game_loaded)
	
	print("[MainMenu] ‚úÖ Initialis√©")

func _connect_buttons() -> void:
	"""Connecte les boutons manuellement"""
	start_button.pressed.connect(_on_start_pressed)
	continue_button.pressed.connect(_on_continue_pressed)
	options_button.pressed.connect(_on_options_pressed)
	credits_button.pressed.connect(_on_credits_pressed)
	quit_button.pressed.connect(_on_quit_pressed)

func _check_save_availability() -> void:
	has_save = false
	if GameRoot and GameRoot.game_manager:
		has_save = GameRoot.game_manager.has_save("auto_save")
	
	continue_button.disabled = not has_save
	if not has_save:
		continue_button.modulate.a = 0.5

func _play_intro_animation() -> void:
	title_label.modulate.a = 0.0
	
	var tween = create_tween()
	tween.set_parallel(true)
	tween.tween_property(title_label, "modulate:a", 1.0, 0.8).set_ease(Tween.EASE_OUT)
	tween.tween_property(title_label, "position:y", title_label.position.y, 0.8).from(title_label.position.y - 50).set_ease(Tween.EASE_OUT)

# ============================================================================
# CALLBACKS BOUTONS
# ============================================================================

func _on_start_pressed() -> void:
	"""Nouvelle partie : √©met game_started, CampaignManager g√®re la suite"""
	print("[MainMenu] ‚ñ∂ Nouvelle partie")
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("D√©marrage d'une nouvelle partie...", "info")
		# CampaignManager √©coute ce signal et lance la s√©quence d'intro
		# puis transite vers la WorldMap automatiquement
		GameRoot.event_bus.game_started.emit()

func _on_continue_pressed() -> void:
	if not has_save:
		return
	
	print("[MainMenu] ‚Üª Chargement de la derni√®re sauvegarde")
	
	if GameRoot:
		GameRoot.event_bus.notify("Chargement de la partie...", "info")
		GameRoot.game_manager.load_game("auto_save")

func _on_options_pressed() -> void:
	print("[MainMenu] ‚öô Options")
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Options (√† impl√©menter)", "info")

func _on_credits_pressed() -> void:
	print("[MainMenu] ‚Ñπ Cr√©dits")
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.notify("Cr√©dits (√† impl√©menter)", "info")

func _on_quit_pressed() -> void:
	print("[MainMenu] ‚úï Quitter le jeu")
	
	var tween = create_tween()
	tween.tween_property(self, "modulate:a", 0.0, 0.3)
	await tween.finished
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.quit_game_requested.emit()

# ============================================================================
# CALLBACKS EVENTBUS
# ============================================================================

func _on_game_started() -> void:
	print("[MainMenu] Le jeu d√©marre (EventBus)")

func _on_game_loaded(save_name: String) -> void:
	print("[MainMenu] Sauvegarde charg√©e : %s" % save_name)

# ============================================================================
# INPUT
# ============================================================================

func _input(event: InputEvent) -> void:
	if OS.is_debug_build():
		if event.is_action_pressed("ui_accept") and not event.is_echo():
			_on_start_pressed()

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## features/menu/main_menu.tscn

```text
[gd_scene load_steps=4 format=3 uid="uid://ceiip1bmiqtbi"]

[ext_resource type="Script" uid="uid://cj5p8ylemcqq8" path="res://features/menu/main_menu.gd" id="1_main_menu"]
[ext_resource type="Script" uid="uid://bqr3y5fer6hv3" path="res://features/debug/debug_version_panel.gd" id="2_3rkf3"]
[ext_resource type="Texture2D" uid="uid://c2wwmbmqrjpes" path="res://asset/twinbound_bg.png" id="2_xlk05"]

[node name="MainMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_main_menu")

[node name="Background" type="Sprite2D" parent="."]
position = Vector2(1033.2, 541.8)
scale = Vector2(1.3460938, 1.053125)
texture = ExtResource("2_xlk05")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 100
theme_override_constants/margin_top = 80
theme_override_constants/margin_right = 100
theme_override_constants/margin_bottom = 80

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 30
alignment = 1

[node name="TitleLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 6
theme_override_colors/font_color = Color(0.9, 0.85, 0.7, 1)
theme_override_font_sizes/font_size = 72
horizontal_alignment = 1

[node name="SubtitleLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 0
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_colors/font_shadow_color = Color(1, 1, 1, 1)
theme_override_colors/font_outline_color = Color(1, 1, 1, 1)
theme_override_font_sizes/font_size = 24
text = "documentation status"
horizontal_alignment = 1
script = ExtResource("2_3rkf3")

[node name="Spacer1" type="Control" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2

[node name="ButtonsContainer" type="VBoxContainer" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 20

[node name="StartButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚ñ∂ Nouvelle Partie"

[node name="ContinueButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚Üª Continuer"

[node name="OptionsButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚öô Options"

[node name="CreditsButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚Ñπ Cr√©dits"

[node name="QuitButton" type="Button" parent="MarginContainer/VBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(400, 60)
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.9, 0.9, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 28
text = "‚úï Quitter"

[node name="Spacer2" type="Control" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2

[node name="VersionLabel" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(0.7, 0.65, 0.5, 1)
theme_override_font_sizes/font_size = 24
text = "documentation status"
horizontal_alignment = 1
```

## features/roster/team_roster_ui.gd

```text
extends Control
class_name TeamRosterUI

signal team_updated()

@onready var roster_list: VBoxContainer = $Panel/MarginContainer/HBoxContainer/RosterPanel/ScrollContainer/RosterList
@onready var team_list: VBoxContainer = $Panel/MarginContainer/HBoxContainer/TeamPanel/ScrollContainer/TeamList
@onready var close_button: Button = $Panel/MarginContainer/VBoxContainer/CloseButton

func _ready() -> void:
	close_button.pressed.connect(_on_close_pressed)
	_refresh_ui()

func _refresh_ui() -> void:
	_clear_lists()
	_populate_roster()
	_populate_team()

func _clear_lists() -> void:
	for child in roster_list.get_children():
		child.queue_free()
	
	for child in team_list.get_children():
		child.queue_free()

func _populate_roster() -> void:
	var roster = GameRoot.team_manager.get_roster()
	
	for unit in roster:
		var button = Button.new()
		button.text = "%s (Lv.%d)" % [unit.get("name"), unit.get("level", 1)]
		button.custom_minimum_size = Vector2(200, 40)
		
		button.pressed.connect(func(): _on_roster_unit_clicked(unit))
		
		roster_list.add_child(button)

func _populate_team() -> void:
	var team = GameRoot.team_manager.get_current_team()
	
	for unit in team:
		var button = Button.new()
		button.text = "%s (Lv.%d)" % [unit.get("name"), unit.get("level", 1)]
		button.custom_minimum_size = Vector2(200, 40)
		
		button.pressed.connect(func(): _on_team_unit_clicked(unit))
		
		team_list.add_child(button)

func _on_roster_unit_clicked(unit: Dictionary) -> void:
	if GameRoot.team_manager.add_to_team(unit):
		_refresh_ui()

func _on_team_unit_clicked(unit: Dictionary) -> void:
	GameRoot.team_manager.remove_from_team(unit.get("id"))
	_refresh_ui()

func _on_close_pressed() -> void:
	queue_free()
```

## features/roster/team_roster_ui.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://c1cn804tc8bwk"]

[ext_resource type="Script" uid="uid://biujp7o2u1lhb" path="res://features/roster/team_roster_ui.gd" id="1"]

[node name="TeamRosterUI" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1")

[node name="Panel" type="PanelContainer" parent="."]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -400.0
offset_top = -300.0
offset_right = 400.0
offset_bottom = 300.0
grow_horizontal = 2
grow_vertical = 2

[node name="MarginContainer" type="MarginContainer" parent="Panel"]
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="Panel/MarginContainer"]
layout_mode = 2

[node name="TitleLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "Gestion d'√âquipe"
horizontal_alignment = 1

[node name="CloseButton" type="Button" parent="Panel/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "Fermer"

[node name="HBoxContainer" type="HBoxContainer" parent="Panel/MarginContainer"]
layout_mode = 2

[node name="RosterPanel" type="PanelContainer" parent="Panel/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ScrollContainer" type="ScrollContainer" parent="Panel/MarginContainer/HBoxContainer/RosterPanel"]
layout_mode = 2

[node name="RosterList" type="VBoxContainer" parent="Panel/MarginContainer/HBoxContainer/RosterPanel/ScrollContainer"]
layout_mode = 2

[node name="TeamPanel" type="PanelContainer" parent="Panel/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ScrollContainer" type="ScrollContainer" parent="Panel/MarginContainer/HBoxContainer/TeamPanel"]
layout_mode = 2

[node name="TeamList" type="VBoxContainer" parent="Panel/MarginContainer/HBoxContainer/TeamPanel/ScrollContainer"]
layout_mode = 2
```

## features/world_map/logic/world_map.gd

```text
# features/world_map/logic/world_map.gd
extends Node2D
## World Map - Carte du monde
## Sc√®ne charg√©e dans le SceneContainer par SceneLoader
##
## Les dialogues utilisent DialogueManager + UIManager (persistants)
## Les combats sont d√©l√©gu√©s √† CampaignManager

class_name WorldMap

# ============================================================================
# R√âF√âRENCES
# ============================================================================

@onready var camera: Camera2D = $Camera2D
@onready var ui_layer: CanvasLayer = $UI
@onready var locations_container: Node2D = $LocationsContainer
@onready var connections_container: Node2D = $ConnectionsContainer
@onready var player_container: Node2D = $PlayerContainer

# Labels UI existants
@onready var info_label: Label = $UI/BottomBar/MarginContainer/HBoxContainer/InfoLabel
@onready var party_button: Button = $UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer/PartyButton
@onready var inventory_button: Button = $UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer/InventoryButton
@onready var menu_button: Button = $UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer/MenuButton
@onready var notification_panel: PanelContainer = $UI/NotificationPanel
@onready var notification_label: Label = $UI/NotificationPanel/MarginContainer/NotificationLabel

# ============================================================================
# DONN√âES
# ============================================================================

var world_map_data: Dictionary = {}
var locations: Dictionary = {}  # location_id -> WorldMapLocation
var player: WorldMapPlayer = null
var connections: Dictionary = {}  # connection_id -> WorldMapConnection

# ============================================================================
# √âTAT
# ============================================================================

var current_step: int = 0
var selected_location: WorldMapLocation = null

# Menu d'actions
var action_menu: PopupPanel = null
var action_menu_container: VBoxContainer = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_create_action_menu()
	_connect_ui_buttons()
	_load_world_map_data()
	_generate_map()
	_spawn_player()
	
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.safe_connect("notification_posted", _on_notification_posted)
	
	print("[WorldMap] ‚úÖ Carte g√©n√©r√©e")

func _create_action_menu() -> void:
	action_menu = PopupPanel.new()
	action_menu.name = "ActionMenu"
	action_menu.visible = false
	action_menu.popup_window = false
	action_menu.transparent_bg = false
	action_menu.borderless = false
	
	var stylebox = StyleBoxFlat.new()
	stylebox.bg_color = Color(0.1, 0.1, 0.15, 0.95)
	stylebox.border_width_left = 2
	stylebox.border_width_top = 2
	stylebox.border_width_right = 2
	stylebox.border_width_bottom = 2
	stylebox.border_color = Color(0.9, 0.9, 0.9)
	stylebox.corner_radius_top_left = 8
	stylebox.corner_radius_top_right = 8
	stylebox.corner_radius_bottom_left = 8
	stylebox.corner_radius_bottom_right = 8
	action_menu.add_theme_stylebox_override("panel", stylebox)
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 10)
	margin.add_theme_constant_override("margin_top", 10)
	margin.add_theme_constant_override("margin_right", 10)
	margin.add_theme_constant_override("margin_bottom", 10)
	action_menu.add_child(margin)
	
	action_menu_container = VBoxContainer.new()
	action_menu_container.custom_minimum_size = Vector2(220, 100)
	action_menu_container.add_theme_constant_override("separation", 5)
	margin.add_child(action_menu_container)
	
	ui_layer.add_child(action_menu)

func _connect_ui_buttons() -> void:
	if party_button:
		party_button.pressed.connect(_on_party_pressed)
	if inventory_button:
		inventory_button.pressed.connect(_on_inventory_pressed)
	if menu_button:
		menu_button.pressed.connect(_on_menu_pressed)

# ============================================================================
# CHARGEMENT DES DONN√âES
# ============================================================================

func _load_world_map_data() -> void:
	world_map_data = WorldMapDataLoader.load_world_map_data("world_map_data", true)
	
	if world_map_data.is_empty():
		push_error("[WorldMap] ‚ùå Impossible de charger les donn√©es de la carte")
		return
	
	print("[WorldMap] üì¶ Donn√©es charg√©es : %s" % world_map_data.get("name", "???"))

# ============================================================================
# G√âN√âRATION DE LA CARTE
# ============================================================================

func _generate_map() -> void:
	if world_map_data.is_empty():
		return
	
	_create_locations()
	_create_connections()
	
	print("[WorldMap] ‚úÖ Carte g√©n√©r√©e : %d locations" % locations.size())

func _create_locations() -> void:
	var locations_data = world_map_data.get("locations", [])
	
	for location_data in locations_data:
		var location = WorldMapLocation.new()
		locations_container.add_child(location)
		location.setup(location_data)
		
		var unlocked = location_data.get("unlocked_at_step", 0) <= current_step
		location.set_unlocked(unlocked)
		
		location.clicked.connect(_on_location_clicked)
		location.hovered.connect(_on_location_hovered)
		location.unhovered.connect(_on_location_unhovered)
		
		locations[location_data.id] = location

func _create_connections() -> void:
	var visual_config = world_map_data.get("connections_visual", {})
	
	if visual_config.has("width"):
		WorldMapConnection.default_line_width = visual_config.width
	if visual_config.has("dash_length"):
		WorldMapConnection.default_dash_length = visual_config.dash_length
	
	if visual_config.has("color"):
		var c = visual_config.color
		WorldMapConnection.default_color_unlocked = Color(
			c.get("r", 0.7), c.get("g", 0.7), c.get("b", 0.7), c.get("a", 0.8)
		)
	
	if visual_config.has("color_locked"):
		var c = visual_config.color_locked
		WorldMapConnection.default_color_locked = Color(
			c.get("r", 0.3), c.get("g", 0.3), c.get("b", 0.3), c.get("a", 0.4)
		)
	
	var connection_states = world_map_data.get("connection_states", {})
	
	for location_id in locations:
		var location = locations[location_id]
		var location_connections = location.get_connections()
		
		for target_id in location_connections:
			if not locations.has(target_id):
				continue
			
			var target_location = locations[target_id]
			var connection_id = _get_connection_id(location_id, target_id)
			if connections.has(connection_id):
				continue
			
			var connection = WorldMapConnection.new()
			var initial_state = _get_connection_state(location_id, target_id, connection_states)
			connection.setup(location, target_location, initial_state)
			connections_container.add_child(connection)
			connections[connection_id] = connection
	
	print("[WorldMap] ‚úÖ %d connexions cr√©√©es" % connections.size())

# ============================================================================
# HELPERS CONNEXIONS
# ============================================================================

func _get_connection_id(from_id: String, to_id: String) -> String:
	var ids = [from_id, to_id]
	ids.sort()
	return ids[0] + "_to_" + ids[1]

func _get_connection_state(from_id: String, to_id: String, states: Dictionary) -> WorldMapConnection.ConnectionState:
	var connection_id = _get_connection_id(from_id, to_id)
	
	if states.has(connection_id):
		var state_str = states[connection_id]
		match state_str:
			"unlocked":
				return WorldMapConnection.ConnectionState.UNLOCKED
			"locked":
				return WorldMapConnection.ConnectionState.LOCKED
			"hidden":
				return WorldMapConnection.ConnectionState.HIDDEN
	
	var from_loc = locations.get(from_id)
	var to_loc = locations.get(to_id)
	
	if from_loc and to_loc and from_loc.is_unlocked and to_loc.is_unlocked:
		return WorldMapConnection.ConnectionState.UNLOCKED
	
	return WorldMapConnection.ConnectionState.HIDDEN

# ============================================================================
# API CONNEXIONS
# ============================================================================

func unlock_connection(from_id: String, to_id: String) -> void:
	var connection_id = _get_connection_id(from_id, to_id)
	if connections.has(connection_id):
		connections[connection_id].unlock()

func lock_connection(from_id: String, to_id: String) -> void:
	var connection_id = _get_connection_id(from_id, to_id)
	if connections.has(connection_id):
		connections[connection_id].lock()

func hide_connection(from_id: String, to_id: String) -> void:
	var connection_id = _get_connection_id(from_id, to_id)
	if connections.has(connection_id):
		connections[connection_id].hide_connection()

func reveal_connection(from_id: String, to_id: String, locked: bool = true) -> void:
	var connection_id = _get_connection_id(from_id, to_id)
	if connections.has(connection_id):
		if locked:
			connections[connection_id].lock()
		else:
			connections[connection_id].unlock()

# ============================================================================
# JOUEUR
# ============================================================================

func _spawn_player() -> void:
	player = WorldMapPlayer.new()
	player_container.add_child(player)
	
	var player_config = world_map_data.get("player", {})
	player.setup(player_config)
	
	var start_location_id = player_config.get("start_location", "")
	
	if locations.has(start_location_id):
		player.set_location(locations[start_location_id])
	else:
		push_warning("[WorldMap] Location de d√©part introuvable : %s" % start_location_id)
		for loc_id in locations:
			if locations[loc_id].is_unlocked:
				player.set_location(locations[loc_id])
				break
	
	player.movement_completed.connect(_on_player_movement_completed)

# ============================================================================
# INTERACTIONS LOCATIONS
# ============================================================================

func _on_location_clicked(location: WorldMapLocation) -> void:
	if player.current_location_id == location.location_id:
		_open_location_menu(location)
		return
	
	var current_loc = locations.get(player.current_location_id)
	if not current_loc:
		return
	
	var location_connections = current_loc.get_connections()
	
	if location.location_id in location_connections:
		player.move_to_location(location)
	else:
		show_notification("Impossible d'aller directement √† " + location.location_name, 2.0)

func _on_player_movement_completed() -> void:
	var current_loc = locations.get(player.current_location_id)
	if current_loc:
		show_notification("Arriv√©e √† " + current_loc.location_name, 2.0)
		await get_tree().create_timer(0.5).timeout
		_open_location_menu(current_loc)

func _on_location_hovered(location: WorldMapLocation) -> void:
	info_label.text = location.location_name

func _on_location_unhovered(_location: WorldMapLocation) -> void:
	info_label.text = ""

# ============================================================================
# MENU D'ACTIONS
# ============================================================================

func _open_location_menu(location: WorldMapLocation) -> void:
	selected_location = location
	
	var location_data = WorldMapDataLoader.load_location_data(location.location_id)
	if location_data.is_empty():
		show_notification("Aucune action disponible ici", 2.0)
		return
	
	for child in action_menu_container.get_children():
		child.queue_free()
	
	var actions = location_data.get("actions", [])
	
	for action in actions:
		if action.has("unlocked_at_step") and action.unlocked_at_step > current_step:
			continue
		
		var button = Button.new()
		button.text = action.get("label", "Action")
		button.custom_minimum_size = Vector2(200, 40)
		
		if action.has("icon"):
			var icon_path = action.icon
			if ResourceLoader.exists(icon_path):
				button.icon = load(icon_path)
		
		var action_data = action.duplicate()
		button.pressed.connect(func(): _on_action_selected(action_data))
		action_menu_container.add_child(button)
	
	var close_button = Button.new()
	close_button.text = "‚úï Fermer"
	close_button.custom_minimum_size = Vector2(200, 40)
	close_button.pressed.connect(_close_location_menu)
	action_menu_container.add_child(close_button)
	
	action_menu.popup_centered()

func _close_location_menu() -> void:
	action_menu.hide()
	selected_location = null

func _on_action_selected(action: Dictionary) -> void:
	_close_location_menu()
	
	match action.get("type"):
		"team_management":
			_handle_team_management_action()
		"battle":
			_handle_battle_action(action)
		"exploration":
			_handle_exploration_action(action)
		"building":
			_handle_building_action(action)
		"shop":
			_handle_shop_action(action)
		"quest_board":
			_handle_quest_board_action(action)
		"dialogue":
			_handle_dialogue_action(action)
		"custom":
			_handle_custom_action(action)
		_:
			show_notification("Type d'action non g√©r√© : " + action.get("type"), 2.0)

# ============================================================================
# GESTION DES ACTIONS
# ============================================================================

func _handle_battle_action(action: Dictionary) -> void:
	"""D√©l√®gue au CampaignManager pour le lancement de combat"""
	var battle_id = action.get("battle_id", "")
	
	if battle_id == "":
		show_notification("ID de combat manquant", 2.0)
		return
	
	print("[WorldMap] ‚öîÔ∏è Lancement du combat : %s" % battle_id)
	
	# D√©l√©guer √† CampaignManager (g√®re chargement JSON, merge team, stockage)
	if GameRoot and GameRoot.campaign_manager:
		GameRoot.campaign_manager.start_battle(battle_id)
	else:
		push_error("[WorldMap] CampaignManager non disponible")

func _handle_dialogue_action(action: Dictionary) -> void:
	"""Utilise DialogueManager + UIManager (DialogueBox persistante)"""
	var dialogue_id = action.get("dialogue_id", "")
	
	if dialogue_id == "":
		show_notification("ID de dialogue manquant", 2.0)
		return
	
	print("[WorldMap] üí¨ Lancement du dialogue : %s" % dialogue_id)
	
	var dialogue_loader = DialogueDataLoader.new()
	var dialogue_data_dict = dialogue_loader.load_dialogue(dialogue_id)
	
	if dialogue_data_dict.is_empty():
		show_notification("Dialogue introuvable : " + dialogue_id, 2.0)
		return
	
	# Convertir en DialogueData
	var dialogue_data = _convert_dialogue_dict_to_data(dialogue_data_dict)
	
	# D√©marrer via DialogueManager (utilise la DialogueBox persistante de UIManager)
	if GameRoot and GameRoot.dialogue_manager:
		GameRoot.dialogue_manager.start_dialogue(dialogue_data)

func _handle_team_management_action() -> void:
	var roster_ui = load("res://scenes/team/team_roster_ui.tscn").instantiate()
	ui_layer.add_child(roster_ui)

func _handle_exploration_action(action: Dictionary) -> void:
	show_notification("Exploration (√† impl√©menter)", 2.0)
	if action.has("event"):
		var event_data = action.event
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.emit_event(event_data.get("type"), [event_data])

func _handle_building_action(action: Dictionary) -> void:
	if action.has("scene"):
		show_notification("Entr√©e dans " + action.get("label"), 1.5)

func _handle_shop_action(action: Dictionary) -> void:
	var shop_id = action.get("shop_id", "")
	show_notification("Magasin : " + shop_id + " (√† impl√©menter)", 2.0)

func _handle_quest_board_action(action: Dictionary) -> void:
	show_notification("Panneau de qu√™tes (√† impl√©menter)", 2.0)

func _handle_custom_action(action: Dictionary) -> void:
	if action.has("event"):
		var event_data = action.event
		if GameRoot and GameRoot.event_bus:
			GameRoot.event_bus.emit_event(event_data.get("type"), [event_data])

# ============================================================================
# CONVERSIONS
# ============================================================================

func _convert_dialogue_dict_to_data(data_dict: Dictionary) -> DialogueData:
	var dialogue = DialogueData.new(data_dict.get("id", ""))
	
	if data_dict.has("sequences"):
		for sequence in data_dict.sequences:
			if sequence.has("lines"):
				for line in sequence.lines:
					dialogue.add_line({
						"speaker": line.get("speaker", ""),
						"text": line.get("text", ""),
						"emotion": line.get("emotion", "neutral"),
						"auto_advance": false
					})
	
	if data_dict.has("lines"):
		for line in data_dict.lines:
			dialogue.add_line(line)
	
	return dialogue

# ============================================================================
# PROGRESSION
# ============================================================================

func set_current_step(step: int) -> void:
	if step == current_step:
		return
	current_step = step
	_update_unlocked_locations()

func _update_unlocked_locations() -> void:
	for location_id in locations:
		var location = locations[location_id]
		var location_ref = _get_location_ref(location_id)
		if location_ref.is_empty():
			continue
		var unlocked = location_ref.get("unlocked_at_step", 0) <= current_step
		location.set_unlocked(unlocked)
	_refresh_connections()

func _get_location_ref(location_id: String) -> Dictionary:
	var locations_data = world_map_data.get("locations", [])
	for loc in locations_data:
		if loc.get("id") == location_id:
			return loc
	return {}

func _refresh_connections() -> void:
	for child in connections_container.get_children():
		child.queue_free()
	_create_connections()

# ============================================================================
# UI CALLBACKS
# ============================================================================

func _on_party_pressed() -> void:
	show_notification("Menu √âquipe (√† impl√©menter)", 2.0)

func _on_inventory_pressed() -> void:
	show_notification("Inventaire (√† impl√©menter)", 2.0)

func _on_menu_pressed() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.game_paused.emit(true)

# ============================================================================
# NOTIFICATIONS
# ============================================================================

func show_notification(message: String, duration: float = 2.0) -> void:
	notification_label.text = message
	notification_panel.visible = true
	notification_panel.modulate.a = 0.0
	
	var tween = create_tween()
	tween.tween_property(notification_panel, "modulate:a", 1.0, 0.3)
	tween.tween_interval(duration)
	tween.tween_property(notification_panel, "modulate:a", 0.0, 0.3)
	tween.tween_callback(func(): notification_panel.visible = false)

func _on_notification_posted(message: String, type: String) -> void:
	var duration = 2.0
	if type == "warning":
		duration = 3.0
	elif type == "error":
		duration = 4.0
	show_notification(message, duration)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _exit_tree() -> void:
	if GameRoot and GameRoot.event_bus:
		GameRoot.event_bus.disconnect_all(self)
```

## features/world_map/logic/world_map_connection.gd

```text
# scenes/world/world_map_connection.gd
extends Node2D
class_name WorldMapConnection

## Repr√©sente une connexion entre deux locations avec √©tat (unlocked/locked/hidden)

signal state_changed(new_state: ConnectionState)

enum ConnectionState {
	UNLOCKED,   # Accessible, pointill√©s normaux
	LOCKED,     # Visible mais bloqu√©, pointill√©s ternes + croix rouge
	HIDDEN      # Invisible, ne s'affiche pas
}

# ============================================================================
# CONFIGURATION GLOBALE (VARIABLES DE CLASSE)
# ============================================================================

# ‚úÖ AJOUT : Variables de classe statiques pour configuration globale
static var default_line_width: float = 4.0
static var default_dash_length: float = 15.0
static var default_gap_length: float = 10.0
static var default_cross_size: float = 20.0
static var default_color_unlocked: Color = Color(0.7, 0.7, 0.7, 0.8)
static var default_color_locked: Color = Color(0.3, 0.3, 0.3, 0.4)

# ============================================================================
# CONFIGURATION D'INSTANCE
# ============================================================================

@export var line_width: float = 4.0
@export var dash_length: float = 15.0
@export var gap_length: float = 10.0
@export var cross_size: float = 20.0

# Couleurs
var color_unlocked: Color = Color(0.7, 0.7, 0.7, 0.8)
var color_locked: Color = Color(0.3, 0.3, 0.3, 0.4)

# ============================================================================
# √âTAT
# ============================================================================

var connection_id: String = ""
var from_location: WorldMapLocation = null
var to_location: WorldMapLocation = null
var current_state: ConnectionState = ConnectionState.HIDDEN

# Visuels
var line_segments: Array[Line2D] = []
var cross_sprite: Polygon2D = null

# ============================================================================
# INITIALISATION
# ============================================================================

func setup(from: WorldMapLocation, to: WorldMapLocation, state: ConnectionState = ConnectionState.UNLOCKED) -> void:
	from_location = from
	to_location = to
	current_state = state
	
	connection_id = from.location_id + "_to_" + to.location_id
	
	# ‚úÖ AJOUT : Appliquer les valeurs par d√©faut globales
	line_width = default_line_width
	dash_length = default_dash_length
	gap_length = default_gap_length
	cross_size = default_cross_size
	color_unlocked = default_color_unlocked
	color_locked = default_color_locked
	
	_create_visuals()

func _create_visuals() -> void:
	_clear_visuals()
	
	if current_state == ConnectionState.HIDDEN:
		visible = false
		return
	
	visible = true
	
	# Cr√©er les segments de ligne pointill√©e
	_create_dashed_line()
	
	# Ajouter la croix si bloqu√©
	if current_state == ConnectionState.LOCKED:
		_create_cross()

# ============================================================================
# LIGNE POINTILL√âE
# ============================================================================

func _create_dashed_line() -> void:
	if not from_location or not to_location:
		return
	
	var start_pos = from_location.position
	var end_pos = to_location.position
	var direction = (end_pos - start_pos).normalized()
	var total_distance = start_pos.distance_to(end_pos)
	
	# Couleur selon l'√©tat
	var line_color = color_unlocked if current_state == ConnectionState.UNLOCKED else color_locked
	
	# Calculer le nombre de segments
	var segment_length = dash_length + gap_length
	var num_segments = int(total_distance / segment_length) + 1
	
	var current_distance = 0.0
	
	for i in range(num_segments):
		# Position de d√©but du segment
		var segment_start = start_pos + direction * current_distance
		
		# Position de fin du segment (sans d√©passer l'arriv√©e)
		var dash_end_distance = min(current_distance + dash_length, total_distance)
		var segment_end = start_pos + direction * dash_end_distance
		
		# Cr√©er le segment Line2D
		var line = Line2D.new()
		line.add_point(segment_start)
		line.add_point(segment_end)
		line.width = line_width
		line.default_color = line_color
		line.antialiased = true
		
		# Style arrondi pour les extr√©mit√©s
		line.begin_cap_mode = Line2D.LINE_CAP_ROUND
		line.end_cap_mode = Line2D.LINE_CAP_ROUND
		
		add_child(line)
		line_segments.append(line)
		
		# Avancer pour le prochain segment
		current_distance += segment_length
		
		# Arr√™ter si on a atteint la fin
		if current_distance >= total_distance:
			break

# ============================================================================
# CROIX ROUGE (pour chemins bloqu√©s)
# ============================================================================

func _create_cross() -> void:
	if not from_location or not to_location:
		return
	
	# Position au centre de la ligne
	var center = (from_location.position + to_location.position) / 2.0
	
	# Cr√©er un Polygon2D en forme de croix
	cross_sprite = Polygon2D.new()
	cross_sprite.color = Color(0.9, 0.2, 0.2, 0.9)
	
	# D√©finir les points de la croix (forme de "+")
	var half_size = cross_size / 2.0
	var thickness = cross_size / 5.0
	
	var points = PackedVector2Array([
		# Barre verticale
		Vector2(-thickness, -half_size),
		Vector2(thickness, -half_size),
		Vector2(thickness, -thickness),
		Vector2(half_size, -thickness),
		# Barre horizontale droite
		Vector2(half_size, thickness),
		Vector2(thickness, thickness),
		Vector2(thickness, half_size),
		Vector2(-thickness, half_size),
		# Barre horizontale gauche
		Vector2(-thickness, thickness),
		Vector2(-half_size, thickness),
		Vector2(-half_size, -thickness),
		Vector2(-thickness, -thickness),
	])
	
	cross_sprite.polygon = points
	cross_sprite.position = center
	
	# Contour noir pour meilleure visibilit√©
	var outline = Line2D.new()
	outline.points = points
	outline.closed = true
	outline.width = 2.0
	outline.default_color = Color.BLACK
	cross_sprite.add_child(outline)
	
	add_child(cross_sprite)

# ============================================================================
# GESTION D'√âTAT
# ============================================================================

func set_state(new_state: ConnectionState) -> void:
	if current_state == new_state:
		return
	
	current_state = new_state
	_create_visuals()
	state_changed.emit(new_state)

func is_accessible() -> bool:
	return current_state == ConnectionState.UNLOCKED

func unlock() -> void:
	set_state(ConnectionState.UNLOCKED)

func lock() -> void:
	set_state(ConnectionState.LOCKED)

func hide_connection() -> void:
	set_state(ConnectionState.HIDDEN)

func reveal() -> void:
	if current_state == ConnectionState.HIDDEN:
		set_state(ConnectionState.LOCKED)

# ============================================================================
# NETTOYAGE
# ============================================================================

func _clear_visuals() -> void:
	# Supprimer les segments de ligne
	for segment in line_segments:
		segment.queue_free()
	line_segments.clear()
	
	# Supprimer la croix
	if cross_sprite:
		cross_sprite.queue_free()
		cross_sprite = null
```

## features/world_map/logic/world_map_data_loader.gd

```text
# scripts/core/world_map_data_loader.gd
extends Node
class_name WorldMapDataLoader

const WORLD_MAP_PATH := "res://data/maps/"

static var _map_cache: Dictionary = {}
static var _location_cache: Dictionary = {}

# ============================================================================
# CHARGEMENT DE LA CARTE PRINCIPALE
# ============================================================================

## Charge les donn√©es compl√®tes de la world map
static func load_world_map_data(map_id: String = "world_map_data", use_cache: bool = true) -> Dictionary:
	var json_path = WORLD_MAP_PATH + map_id + ".json"
	
	var json_loader = JSONDataLoader.new()
	var raw_data = json_loader.load_json_file(json_path, use_cache)
	
	if typeof(raw_data) != TYPE_DICTIONARY or raw_data.is_empty():
		push_error("[WorldMapDataLoader] ‚ùå Impossible de charger : ", json_path)
		return {}
	
	# Convertir les positions
	raw_data = _convert_map_positions(raw_data)
	
	return raw_data

# ============================================================================
# CHARGEMENT DES LOCATIONS
# ============================================================================

## Charge les donn√©es d'une location sp√©cifique
static func load_location_data(location_id: String, use_cache: bool = true) -> Dictionary:
	var json_path = WORLD_MAP_PATH + "locations/" + location_id + ".json"
	
	var json_loader = JSONDataLoader.new()
	var raw_data = json_loader.load_json_file(json_path, use_cache)
	
	if typeof(raw_data) != TYPE_DICTIONARY or raw_data.is_empty():
		push_error("[WorldMapDataLoader] ‚ùå Impossible de charger location : ", json_path)
		return {}
	
	return raw_data

static func _convert_map_positions(data: Dictionary) -> Dictionary:
	var result = data.duplicate(true)
	
	if result.has("locations"):
		for location in result.locations:
			if location.has("position"):
				var pos = location.position
				location.position = Vector2i(pos.x, pos.y)
	
	return result

# ============================================================================
# QUERIES
# ============================================================================

## Retourne toutes les locations d'une carte
static func get_all_locations(map_id: String = "world_map_data") -> Array:
	var map_data = load_world_map_data(map_id)
	return map_data.get("locations", [])

## Retourne une location sp√©cifique par ID
static func get_location_by_id(location_id: String, map_id: String = "world_map_data") -> Dictionary:
	var locations = get_all_locations(map_id)
	
	for location in locations:
		if location.get("id") == location_id:
			return location
	
	return {}

## Retourne les locations d√©verrouill√©es jusqu'√† un certain step
static func get_unlocked_locations(current_step: int, map_id: String = "world_map_data") -> Array:
	var all_locations = get_all_locations(map_id)
	var unlocked: Array = []
	
	for location in all_locations:
		if location.get("unlocked_at_step", 0) <= current_step:
			unlocked.append(location)
	
	return unlocked

## V√©rifie si une location est d√©verrouill√©e
static func is_location_unlocked(location_id: String, current_step: int, map_id: String = "world_map_data") -> bool:
	var location = get_location_by_id(location_id, map_id)
	
	if location.is_empty():
		return false
	
	return location.get("unlocked_at_step", 0) <= current_step

# ============================================================================
# NPCs
# ============================================================================

## Trouve un NPC dans une location et retourne o√π il se trouve
static func find_npc_location(npc_id: String, location_id: String) -> Dictionary:
	var location_data = load_location_data(location_id)
	var npcs = location_data.get("npcs", [])
	
	for npc in npcs:
		if npc.get("id") == npc_id:
			# Calculer o√π le NPC se trouve (probabilit√©)
			return _calculate_npc_position(npc)
	
	return {}

## Calcule o√π se trouve un NPC selon les probabilit√©s
static func _calculate_npc_position(npc: Dictionary) -> Dictionary:
	var locations = npc.get("locations", [])
	
	if locations.is_empty():
		return {}
	
	# G√©n√©rer un nombre al√©atoire
	var roll = randf() * 100.0
	var cumulative = 0.0
	
	for loc in locations:
		cumulative += loc.get("chance", 0)
		
		if roll <= cumulative:
			return {
				"npc": npc,
				"place_id": loc.get("place_id"),
				"place_name": loc.get("place_name")
			}
	
	# Fallback : premi√®re location
	return {
		"npc": npc,
		"place_id": locations[0].get("place_id"),
		"place_name": locations[0].get("place_name")
	}

# ============================================================================
# CACHE
# ============================================================================

static func clear_cache() -> void:
	_map_cache.clear()
	_location_cache.clear()
	print("[WorldMapDataLoader] Cache vid√©")

static func clear_location_cache(location_id: String) -> void:
	_location_cache.erase(location_id)
```

## features/world_map/logic/world_map_location.gd

```text
# scenes/world/world_map_location.gd
extends Node2D
## WorldMapLocation - Repr√©sente un point d'int√©r√™t sur la carte
## G√®re l'affichage, l'interaction et le menu d'actions

class_name WorldMapLocation

signal clicked(location: WorldMapLocation)
signal hovered(location: WorldMapLocation)
signal unhovered(location: WorldMapLocation)

# ============================================================================
# PROPRI√âT√âS
# ============================================================================

var location_id: String = ""
var location_name: String = ""
var location_data: Dictionary = {}
var is_unlocked: bool = false
var is_hovered: bool = false

# Visuel
var sprite: Sprite2D
var label: Label
var area: Area2D

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	pass

func setup(data: Dictionary) -> void:
	"""Configure la location avec ses donn√©es"""
	
	location_data = data
	location_id = data.get("id", "")
	location_name = data.get("name", "")
	
	# Position
	if data.has("position"):
		var pos = data.position
		if typeof(pos) == TYPE_VECTOR2I:
			position = Vector2(pos.x, pos.y)
		else:
			position = Vector2(pos.get("x", 0), pos.get("y", 0))
	
	# D√©verrouillage
	is_unlocked = true
	
	# ‚úÖ Cr√©er les visuels MAINTENANT (avec les bonnes donn√©es)
	if not sprite:  # Seulement si pas d√©j√† cr√©√©s
		_create_visuals()
	
	_update_visuals()
	
	print("[WorldMapLocation] üìç Setup termin√© : ", location_name, " √† ", position)
	
func _create_visuals() -> void:
	"""Cr√©e les √©l√©ments visuels"""
	
	# ‚úÖ Rectangle de debug avec Polygon2D
	var debug_rect = Polygon2D.new()
	debug_rect.polygon = PackedVector2Array([
		Vector2(-32, -32),
		Vector2(32, -32),
		Vector2(32, 32),
		Vector2(-32, 32)
	])
	debug_rect.color = Color(1, 0, 0, 0.3)  # Rouge transparent
	add_child(debug_rect)
	print("[WorldMapLocation] üî¥ Rectangle debug cr√©√© pour ", location_name)
	
	# Sprite principal avec texture de rond jaune
	sprite = Sprite2D.new()
	sprite.centered = true
	sprite.texture = _create_yellow_circle_texture()
	add_child(sprite)
	print("[WorldMapLocation] üü° Sprite cr√©√© pour ", location_name)
	
	# Label avec le nom
	label = Label.new()
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.position = Vector2(-50, 50)
	label.custom_minimum_size = Vector2(100, 0)
	label.add_theme_font_size_override("font_size", 16)
	add_child(label)
	print("[WorldMapLocation] üè∑Ô∏è Label cr√©√© pour ", location_name)
	
	# Zone de collision pour le clic
	area = Area2D.new()
	area.collision_layer = 2
	area.collision_mask = 0
	area.input_pickable = true
	
	var collision = CollisionShape2D.new()
	var shape = CircleShape2D.new()
	shape.radius = 64  # ‚Üê Plus gros pour debug
	collision.shape = shape
	area.add_child(collision)
	add_child(area)
	print("[WorldMapLocation] üìç Area2D cr√©√©e pour ", location_name, " avec radius=64")
	
	# Signaux
	area.input_event.connect(_on_area_input_event)
	area.mouse_entered.connect(_on_mouse_entered)
	area.mouse_exited.connect(_on_mouse_exited)
	print("[WorldMapLocation] üîó Signaux connect√©s pour ", location_name)
	
# ‚úÖ NOUVELLE FONCTION : Cr√©er un rond jaune programmatiquement
func _create_yellow_circle_texture() -> ImageTexture:
	"""Cr√©e une texture de cercle jaune"""
	var size = 64
	var image = Image.create(size, size, false, Image.FORMAT_RGBA8)
	image.fill(Color.TRANSPARENT)
	
	var center = size / 2
	var radius = 28
	
	# Dessiner le cercle jaune
	for y in range(size):
		for x in range(size):
			var dx = x - center
			var dy = y - center
			var dist = sqrt(dx*dx + dy*dy)
			
			if dist < radius:
				# D√©grad√© du centre vers les bords
				var alpha = 1.0 - (dist / radius) * 0.3
				image.set_pixel(x, y, Color(1.0, 0.9, 0.2, alpha))
			
			# Contour plus fonc√©
			if dist >= radius - 3 and dist < radius:
				image.set_pixel(x, y, Color(0.8, 0.7, 0.0, 1.0))
	
	return ImageTexture.create_from_image(image)

func _update_visuals() -> void:
	"""Met √† jour l'apparence selon l'√©tat"""
	
	if not sprite or not label or not area:
		push_warning("[WorldMapLocation] Visuels non initialis√©s pour: ", location_name)
		return
	
	# ‚úÖ CHANGEMENT : Utiliser un rond jaune par d√©faut
	var icon_path = location_data.get("icon", "")
	
	if icon_path != "" and ResourceLoader.exists(icon_path):
		sprite.texture = load(icon_path)
	else:
		# Pas d'ic√¥ne sp√©cifi√©e ‚Üí utiliser le rond jaune
		sprite.texture = _create_yellow_circle_texture()
	
	# Scale
	var scale_value = location_data.get("scale", 1.5)  # ‚úÖ Un peu plus grand par d√©faut
	sprite.scale = Vector2(scale_value, scale_value)
	
	# Couleur (si sp√©cifi√©e dans les donn√©es)
	if location_data.has("color"):
		var c = location_data.color
		sprite.modulate = Color(c.get("r", 1), c.get("g", 1), c.get("b", 1), c.get("a", 1))
	else:
		# ‚úÖ Jaune par d√©faut
		sprite.modulate = Color(1.0, 0.9, 0.2, 1.0)
	
	# Nom
	label.text = location_name
	
	# Visibilit√© selon d√©verrouillage
	visible = is_unlocked
	
	# Effet hover
	if is_hovered:
		sprite.scale *= 1.2  # ‚úÖ Plus gros au survol
		label.add_theme_color_override("font_color", Color.YELLOW)
	else:
		label.add_theme_color_override("font_color", Color.WHITE)

func set_unlocked(unlocked: bool) -> void:
	"""D√©finit si la location est d√©verrouill√©e"""
	is_unlocked = unlocked
	_update_visuals()

# ============================================================================
# EVENTS
# ============================================================================

func _on_area_input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	print("[WorldMapLocation] üñ±Ô∏è Input event re√ßu sur : ", location_name)
	print("  - Type event: ", event.get_class())
	print("  - is_unlocked: ", is_unlocked)
	
	if event is InputEventMouseButton:
		print("  - MouseButton: ", event.button_index, " pressed: ", event.pressed)
		
		if event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
			print("  - Clic gauche d√©tect√©!")
			if is_unlocked:
				print("  - Location d√©verrouill√©e, √©mission signal clicked")
				clicked.emit(self)
			else:
				print("  - ‚ùå Location verrouill√©e, pas de signal")

func _on_mouse_entered() -> void:
	if is_unlocked:
		is_hovered = true
		_update_visuals()
		hovered.emit(self)

func _on_mouse_exited() -> void:
	is_hovered = false
	_update_visuals()
	unhovered.emit(self)

# ============================================================================
# GETTERS
# ============================================================================

func get_location_id() -> String:
	return location_id

func get_location_name() -> String:
	return location_name

func get_connections() -> Array:
	return location_data.get("connections", [])
```

## features/world_map/logic/world_map_player.gd

```text
# scenes/world/world_map_player.gd
extends Node2D
## WorldMapPlayer - Sprite du joueur sur la world map avec animation bounce

class_name WorldMapPlayer

signal movement_started()
signal movement_completed()

# ============================================================================
# CONFIGURATION
# ============================================================================

@export var bounce_speed: float = 1.5
@export var bounce_amount: float = 10.0
@export var bounce_offset: float = 75.0 
@export var scale_variation: float = 0.1  # Variation de scale pour l'effet respiration
@export var move_speed: float = 300.0

# ============================================================================
# √âTAT
# ============================================================================

var sprite: Sprite2D
var is_moving: bool = false
var current_location_id: String = ""

var bounce_tween: Tween = null
var move_tween: Tween = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_create_sprite()
	_start_bounce_animation()

func _create_sprite() -> void:
	"""Cr√©e le sprite du joueur"""
	
	sprite = Sprite2D.new()
	sprite.texture = load("res://icon.svg")
	sprite.centered = true
	add_child(sprite)

func setup(player_config: Dictionary) -> void:
	"""Configure le joueur avec les donn√©es Lua"""
	
	if player_config.has("icon"):
		var icon_path = player_config.icon
		if ResourceLoader.exists(icon_path):
			sprite.texture = load(icon_path)
	
	if player_config.has("scale"):
		sprite.scale = Vector2.ONE * player_config.scale
	
	bounce_speed = player_config.get("bounce_speed", 1.5)
	bounce_amount = player_config.get("bounce_amount", 10.0)
	move_speed = player_config.get("move_speed", 300.0)

# ============================================================================
# ANIMATION BOUNCE
# ============================================================================

func _start_bounce_animation() -> void:
	"""D√©marre l'animation de bounce continue"""
	
	if bounce_tween and bounce_tween.is_valid():
		bounce_tween.kill()
	
	bounce_tween = create_tween()
	bounce_tween.set_loops()
	bounce_tween.set_parallel(true)
	
	# ‚úÖ CHANGEMENT : Bounce entre -bounce_amount-bounce_offset et -bounce_offset
	# (au lieu de -bounce_amount √† 0)
	# Cela place le sprite plus haut de fa√ßon permanente
	
	var min_y = -bounce_offset  # Position basse du bounce
	var max_y = -bounce_offset - bounce_amount  # Position haute du bounce
	
	# Variation de position Y (bounce)
	bounce_tween.tween_property(
		sprite,
		"position:y",
		max_y,
		bounce_speed / 2.0
	).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
	
	bounce_tween.tween_property(
		sprite,
		"position:y",
		min_y,
		bounce_speed / 2.0
	).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE).set_delay(bounce_speed / 2.0)
	
	# Variation de scale (respiration) - inchang√©
	var base_scale = sprite.scale
	var scale_min = base_scale * (1.0 - scale_variation)
	var scale_max = base_scale * (1.0 + scale_variation)
	
	bounce_tween.tween_property(
		sprite,
		"scale",
		scale_max,
		bounce_speed / 2.0
	).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)
	
	bounce_tween.tween_property(
		sprite,
		"scale",
		scale_min,
		bounce_speed / 2.0
	).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE).set_delay(bounce_speed / 2.0)

# ============================================================================
# MOUVEMENT
# ============================================================================

func move_to_location(target_location: WorldMapLocation) -> void:
	"""D√©place le joueur vers une location"""
	
	if is_moving:
		return
	
	is_moving = true
	movement_started.emit()
	
	var target_pos = target_location.position
	var distance = position.distance_to(target_pos)
	var duration = distance / move_speed
	
	if move_tween and move_tween.is_valid():
		move_tween.kill()
	
	move_tween = create_tween()
	move_tween.tween_property(self, "position", target_pos, duration).set_ease(Tween.EASE_IN_OUT)
	await move_tween.finished
	
	current_location_id = target_location.location_id
	is_moving = false
	movement_completed.emit()

func set_location(location: WorldMapLocation) -> void:
	"""Place directement le joueur √† une location (sans animation)"""
	
	position = location.position
	current_location_id = location.location_id
```

## features/world_map/visuals/world_map.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://cnb8xh4y5qw7m"]

[ext_resource type="Script" uid="uid://cd0c7ma8fk7nn" path="res://features/world_map/logic/world_map.gd" id="1_world_map"]

[node name="WorldMap" type="Node2D"]
script = ExtResource("1_world_map")

[node name="Background" type="ColorRect" parent="."]
offset_right = 1920.0
offset_bottom = 1080.0
mouse_filter = 2
color = Color(0.15, 0.2, 0.15, 1)

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(960, 540)
zoom = Vector2(0.8, 0.8)

[node name="ConnectionsContainer" type="Node2D" parent="."]

[node name="LocationsContainer" type="Node2D" parent="."]

[node name="PlayerContainer" type="Node2D" parent="."]

[node name="UI" type="CanvasLayer" parent="."]

[node name="TopBar" type="PanelContainer" parent="UI"]
offset_right = 1920.0
offset_bottom = 80.0

[node name="TopBarBg" type="ColorRect" parent="UI/TopBar"]
layout_mode = 2
color = Color(0.1, 0.1, 0.12, 0.9)

[node name="MarginContainer" type="MarginContainer" parent="UI/TopBar"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 10

[node name="HBoxContainer" type="HBoxContainer" parent="UI/TopBar/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 40

[node name="TitleLabel" type="Label" parent="UI/TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0.9, 0.85, 0.7, 1)
theme_override_font_sizes/font_size = 32
text = "CARTE DU MONDE"

[node name="DivinityPanel" type="HBoxContainer" parent="UI/TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 30

[node name="AstraeonLabel" type="Label" parent="UI/TopBar/MarginContainer/HBoxContainer/DivinityPanel"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 0.8, 1, 1)
theme_override_font_sizes/font_size = 20
text = "‚öñ Astraeon: 0"

[node name="KharvulLabel" type="Label" parent="UI/TopBar/MarginContainer/HBoxContainer/DivinityPanel"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.5, 0.5, 1)
theme_override_font_sizes/font_size = 20
text = "‚ö° Kharv√ªl: 0"

[node name="BottomBar" type="PanelContainer" parent="UI"]
anchors_preset = 2
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = -120.0
offset_right = 1920.0
grow_vertical = 0

[node name="BottomBarBg" type="ColorRect" parent="UI/BottomBar"]
layout_mode = 2
color = Color(0.1, 0.1, 0.12, 0.9)

[node name="MarginContainer" type="MarginContainer" parent="UI/BottomBar"]
layout_mode = 2
theme_override_constants/margin_left = 30
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 30
theme_override_constants/margin_bottom = 15

[node name="HBoxContainer" type="HBoxContainer" parent="UI/BottomBar/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="InfoLabel" type="Label" parent="UI/BottomBar/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
theme_override_font_sizes/font_size = 22
text = "S√©lectionnez une destination pour voyager"
vertical_alignment = 1

[node name="ButtonsContainer" type="HBoxContainer" parent="UI/BottomBar/MarginContainer/HBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="PartyButton" type="Button" parent="UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "üë• √âquipe"

[node name="InventoryButton" type="Button" parent="UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "üéí Inventaire"

[node name="MenuButton" type="Button" parent="UI/BottomBar/MarginContainer/HBoxContainer/ButtonsContainer"]
custom_minimum_size = Vector2(150, 60)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "üìã Menu"

[node name="NotificationPanel" type="PanelContainer" parent="UI"]
visible = false
anchors_preset = 5
anchor_left = 0.5
anchor_right = 0.5
offset_left = -250.0
offset_top = 100.0
offset_right = 250.0
offset_bottom = 180.0
grow_horizontal = 2

[node name="NotificationBg" type="ColorRect" parent="UI/NotificationPanel"]
layout_mode = 2
color = Color(0.15, 0.15, 0.2, 0.95)

[node name="MarginContainer" type="MarginContainer" parent="UI/NotificationPanel"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 15

[node name="NotificationLabel" type="Label" parent="UI/NotificationPanel/MarginContainer"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 1, 0.8, 1)
theme_override_font_sizes/font_size = 24
text = "Notification"
horizontal_alignment = 1
vertical_alignment = 1
autowrap_mode = 3

[node name="DebugInfo" type="Label" parent="UI"]
visible = false
offset_left = 10.0
offset_top = 90.0
offset_right = 300.0
offset_bottom = 200.0
theme_override_colors/font_color = Color(0, 1, 0, 1)
theme_override_font_sizes/font_size = 16
text = "[DEBUG]
Camera Pos: (0, 0)
Zoom: 1.0"
```

## shared/barks/bark_label.gd

```text
extends Control
## BarkLabel - Label individuel pour un message bark
## Affiche un message court au-dessus d'un personnage

class_name BarkLabel

# ============================================================================
# PROPRI√âT√âS
# ============================================================================

var speaker: String = ""
var text: String = ""
var duration: float = 2.0

# ============================================================================
# UI
# ============================================================================

var panel: PanelContainer = null
var label: RichTextLabel = null

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_create_ui()

func _create_ui() -> void:
	"""Cr√©e l'interface du bark"""
	
	# Panel container
	panel = PanelContainer.new()
	panel.size_flags_horizontal = Control.SIZE_SHRINK_CENTER
	panel.size_flags_vertical = Control.SIZE_SHRINK_CENTER
	add_child(panel)
	
	# Background style
	var stylebox = StyleBoxFlat.new()
	stylebox.bg_color = Color(0.1, 0.1, 0.1, 0.85)
	stylebox.corner_radius_top_left = 8
	stylebox.corner_radius_top_right = 8
	stylebox.corner_radius_bottom_left = 8
	stylebox.corner_radius_bottom_right = 8
	stylebox.content_margin_left = 12
	stylebox.content_margin_right = 12
	stylebox.content_margin_top = 8
	stylebox.content_margin_bottom = 8
	stylebox.border_width_left = 2
	stylebox.border_width_right = 2
	stylebox.border_width_top = 2
	stylebox.border_width_bottom = 2
	stylebox.border_color = Color(0.9, 0.9, 0.9, 0.6)
	
	panel.add_theme_stylebox_override("panel", stylebox)
	
	# Label
	label = RichTextLabel.new()
	label.bbcode_enabled = true
	label.fit_content = true
	label.scroll_active = false
	label.custom_minimum_size = Vector2(100, 0)
	label.add_theme_font_size_override("normal_font_size", 16)
	label.add_theme_color_override("default_color", Color.WHITE)
	
	panel.add_child(label)
	
	# D√©finir le texte
	_update_text()

func _update_text() -> void:
	"""Met √† jour le texte affich√©"""
	
	if not label:
		return
	
	var display_text = text
	
	# Ajouter le nom du speaker si pr√©sent
	if speaker != "":
		display_text = "[b][color=#FFD700]" + speaker + ":[/color][/b] " + text
	
	label.text = display_text

# ============================================================================
# POSITIONNEMENT
# ============================================================================

func _process(_delta: float) -> void:
	# Centrer le panel
	if panel:
		panel.position = -panel.size / 2
```

## shared/barks/bark_label.tscn

```text
[gd_scene load_steps=2 format=3 uid="uid://cbixhsjlua0ai"]

[ext_resource type="Script" uid="uid://krnjeeijltk1" path="res://shared/barks/bark_label.gd" id="1_bark_label"]

[node name="BarkLabel" type="Control"]
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_bark_label")
```

## shared/battle_state_machine.gd

```text
extends StateMachine
class_name BattleStateMachine
## State Machine pour le syst√®me de combat

signal battle_phase_changed(old_phase: String, new_phase: String)

enum State {
	INTRO,
	PLAYER_TURN,
	ENEMY_TURN,
	ANIMATION,
	VICTORY,
	DEFEAT
}

func _define_states() -> void:
	add_state("INTRO", _on_intro_enter, _on_intro_exit)
	add_state("PLAYER_TURN", _on_player_turn_enter, _on_player_turn_exit, _on_player_turn_process)
	add_state("ENEMY_TURN", _on_enemy_turn_enter, _on_enemy_turn_exit)
	add_state("ANIMATION", _on_animation_enter, _on_animation_exit)
	add_state("VICTORY", _on_victory_enter)
	add_state("DEFEAT", _on_defeat_enter)
	
	current_state = "INTRO"

func _define_transitions() -> void:
	add_transition("INTRO", "PLAYER_TURN")
	add_transition("PLAYER_TURN", "ANIMATION")
	add_transition("PLAYER_TURN", "ENEMY_TURN")
	add_transition("ENEMY_TURN", "ANIMATION")
	add_transition("ENEMY_TURN", "PLAYER_TURN")
	add_transition("ANIMATION", "PLAYER_TURN")
	add_transition("ANIMATION", "ENEMY_TURN")
	add_transition("ANIMATION", "VICTORY")
	add_transition("ANIMATION", "DEFEAT")
	add_transition("PLAYER_TURN", "VICTORY")
	add_transition("PLAYER_TURN", "DEFEAT")
	add_transition("ENEMY_TURN", "VICTORY")
	add_transition("ENEMY_TURN", "DEFEAT")

# Callbacks des √©tats
func _on_intro_enter() -> void:
	print("[BattleStateMachine] üé¨ Intro")
	battle_phase_changed.emit("", "INTRO")  # ‚úÖ AJOUTER

func _on_intro_exit() -> void:
	pass

func _on_player_turn_enter() -> void:
	print("[BattleStateMachine] ‚ñ∂Ô∏è Tour du Joueur")
	battle_phase_changed.emit(get_previous_state(), "PLAYER_TURN")

func _on_player_turn_exit() -> void:
	pass

func _on_player_turn_process(delta: float) -> void:
	# Logique du tour joueur
	pass

func _on_enemy_turn_enter() -> void:
	print("[BattleStateMachine] üëæ Tour des Ennemis")
	battle_phase_changed.emit(get_previous_state(), "ENEMY_TURN") 

func _on_enemy_turn_exit() -> void:
	pass

func _on_animation_enter() -> void:
	print("[BattleStateMachine] üéûÔ∏è Animation")
	battle_phase_changed.emit(get_previous_state(), "ANIMATION")

func _on_animation_exit() -> void:
	pass

func _on_victory_enter() -> void:
	print("[BattleStateMachine] üéâ Victoire!")
	battle_phase_changed.emit(get_previous_state(), "VICTORY")

func _on_defeat_enter() -> void:
	print("[BattleStateMachine] üíÄ D√©faite")
	battle_phase_changed.emit(get_previous_state(), "DEFEAT")
```

## shared/battle_stats_tracker.gd

```text
extends Node
## BattleStatsTracker - Enregistre toutes les statistiques du combat
## MVP, efficacit√©, actions, etc.

class_name BattleStatsTracker

# ============================================================================
# SIGNAUX
# ============================================================================

signal stat_recorded(stat_name: String, value: Variant)

# ============================================================================
# STATISTIQUES GLOBALES
# ============================================================================

var global_stats: Dictionary = {
	"turns_elapsed": 0,
	"total_damage_dealt": 0,
	"total_damage_taken": 0,
	"total_healing": 0,
	"units_killed": 0,
	"units_lost": 0,
	"total_movements": 0,
	"total_actions": 0,
	"abilities_used": 0,
	"start_time": 0,
	"end_time": 0
}

# ============================================================================
# STATISTIQUES PAR UNIT√â
# ============================================================================

var unit_stats: Dictionary = {}
# Format: unit_id -> {damage_dealt, damage_taken, kills, movements, actions, ...}

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	global_stats.start_time = Time.get_unix_time_from_system()

# ============================================================================
# ENREGISTREMENT DES UNIT√âS
# ============================================================================

func register_unit(unit: BattleUnit3D) -> void:
	unit_stats[unit.unit_id] = {
		# ‚ùå plus de r√©f√©rence au node
		"id": unit.unit_id,
		"name": unit.unit_name,
		"is_player": unit.is_player_unit,

		"damage_dealt": 0,
		"damage_taken": 0,
		"healing_done": 0,
		"healing_received": 0,
		"kills": 0,
		"deaths": 0,
		"movements": 0,
		"actions": 0,
		"abilities_used": 0,
		"turns_survived": 0,
		"was_alive": true
	}
# ============================================================================
# ENREGISTREMENT DES ACTIONS
# ============================================================================

func record_movement(unit: BattleUnit3D, path: Array) -> void:
	"""Enregistre un d√©placement"""
	
	if not unit_stats.has(unit.unit_id):
		return
	
	unit_stats[unit.unit_id].movements += 1
	global_stats.total_movements += 1
	
	stat_recorded.emit("movement", unit.unit_id)

func record_action(attacker: BattleUnit3D, target: BattleUnit3D, action_type: String) -> void:
	"""Enregistre une action (attaque, capacit√©, etc.)"""
	
	if not unit_stats.has(attacker.unit_id):
		return
	
	unit_stats[attacker.unit_id].actions += 1
	global_stats.total_actions += 1
	
	if action_type != "attack":
		unit_stats[attacker.unit_id].abilities_used += 1
		global_stats.abilities_used += 1
	
	stat_recorded.emit("action", attacker.unit_id)

func record_damage(attacker: BattleUnit3D, target: BattleUnit3D, damage: int) -> void:
	"""Enregistre des d√©g√¢ts inflig√©s"""
	
	if unit_stats.has(attacker.unit_id):
		unit_stats[attacker.unit_id].damage_dealt += damage
		global_stats.total_damage_dealt += damage
	
	if unit_stats.has(target.unit_id):
		unit_stats[target.unit_id].damage_taken += damage
		
		if target.is_player_unit:
			global_stats.total_damage_taken += damage
	
	stat_recorded.emit("damage", damage)

func record_healing(healer: BattleUnit3D, target: BattleUnit3D, amount: int) -> void:
	"""Enregistre des soins"""
	
	if unit_stats.has(healer.unit_id):
		unit_stats[healer.unit_id].healing_done += amount
	
	if unit_stats.has(target.unit_id):
		unit_stats[target.unit_id].healing_received += amount
		global_stats.total_healing += amount
	
	stat_recorded.emit("healing", amount)

func record_kill(killer: BattleUnit3D, victim: BattleUnit3D) -> void:
	"""Enregistre une √©limination"""
	
	if unit_stats.has(killer.unit_id):
		unit_stats[killer.unit_id].kills += 1
		global_stats.units_killed += 1
	
	stat_recorded.emit("kill", killer.unit_id)

func record_death(unit: BattleUnit3D) -> void:
	if unit_stats.has(unit.unit_id):
		unit_stats[unit.unit_id].deaths += 1
		unit_stats[unit.unit_id].was_alive = false

	if unit.is_player_unit:
		global_stats.units_lost += 1

	stat_recorded.emit("death", unit.unit_id)

func record_turn_end() -> void:
	global_stats.turns_elapsed += 1

	for unit_id in unit_stats:
		if unit_stats[unit_id].was_alive:
			unit_stats[unit_id].turns_survived += 11

# ============================================================================
# CALCULS
# ============================================================================

func get_final_stats() -> Dictionary:
	"""Retourne les statistiques finales"""
	
	global_stats.end_time = Time.get_unix_time_from_system()
	var duration = global_stats.end_time - global_stats.start_time
	
	return {
		"global": global_stats.duplicate(),
		"duration_seconds": duration,
		"efficiency": calculate_efficiency(),
		"units": get_unit_summaries()
	}

func calculate_efficiency() -> float:
	"""Calcule un score d'efficacit√© global"""
	
	var score = 0.0
	
	# Bonus pour les √©liminations
	score += global_stats.units_killed * 100
	
	# Malus pour les pertes
	score -= global_stats.units_lost * 200
	
	# Bonus pour les d√©g√¢ts
	score += global_stats.total_damage_dealt * 0.5
	
	# Malus pour les d√©g√¢ts re√ßus
	score -= global_stats.total_damage_taken * 0.3
	
	# Bonus pour l'√©conomie d'actions
	if global_stats.total_actions > 0:
		var action_efficiency = float(global_stats.units_killed) / float(global_stats.total_actions)
		score += action_efficiency * 100
	
	return max(0.0, score)

func get_unit_summaries() -> Array[Dictionary]:
	var summaries: Array[Dictionary] = []

	for unit_id in unit_stats:
		var stats = unit_stats[unit_id]

		summaries.append({
			"id": stats.id,
			"name": stats.name,
			"is_player": stats.is_player,
			"is_alive": stats.was_alive,
			"damage_dealt": stats.damage_dealt,
			"damage_taken": stats.damage_taken,
			"kills": stats.kills,
			"deaths": stats.deaths,
			"actions": stats.actions,
			"score": _calculate_unit_score(stats)
		})

	return summaries

func _calculate_unit_score(stats: Dictionary) -> float:
	"""Calcule un score individuel pour une unit√©"""
	
	var score = 0.0
	
	score += stats.damage_dealt * 1.0
	score += stats.kills * 500
	score -= stats.damage_taken * 0.5
	score -= stats.deaths * 1000
	score += stats.healing_done * 2.0
	score += stats.actions * 10
	
	return max(0.0, score)

# ============================================================================
# MVP
# ============================================================================

func get_mvp() -> Dictionary:
	"""Retourne les stats du MVP (data only)"""
	
	var best_stats: Dictionary = {}
	var best_score: float = -INF
	
	for unit_id in unit_stats:
		var stats = unit_stats[unit_id]
		
		if not stats.is_player:
			continue
		
		var score = _calculate_unit_score(stats)
		
		if score > best_score:
			best_score = score
			best_stats = stats
	
	return best_stats


# ============================================================================
# DEBUG
# ============================================================================

func print_stats() -> void:
	"""Affiche toutes les statistiques (debug)"""
	
	print("\n=== STATISTIQUES DE COMBAT ===")
	print("Tours: ", global_stats.turns_elapsed)
	print("D√©g√¢ts totaux: ", global_stats.total_damage_dealt)
	print("√âliminations: ", global_stats.units_killed)
	print("Pertes: ", global_stats.units_lost)
	print("Efficacit√©: ", calculate_efficiency())
	
	print("\nUnit√©s:")
	for summary in get_unit_summaries():
		print("  - ", summary.name, " [Score: ", summary.score, "]")
	
	var mvp = get_mvp()
	if mvp:
		print("\nMVP: ", mvp.unit_name)
	
	print("==============================\n")
```

## shared/command.gd

```text
extends RefCounted
class_name Command
## Interface pour le pattern Command
## Permet undo/redo, replay, logging automatique

var is_executed: bool = false
var timestamp: float = 0.0
var description: String = ""

func execute() -> bool:
	"""Ex√©cute la commande"""
	if is_executed:
		push_warning("[Command] Commande d√©j√† ex√©cut√©e : ", description)
		return false
	
	timestamp = Time.get_unix_time_from_system()
	var success = _do_execute()
	
	if success:
		is_executed = true
	
	return success

func undo() -> bool:
	"""Annule la commande"""
	if not is_executed:
		push_warning("[Command] Impossible d'annuler une commande non ex√©cut√©e")
		return false
	
	var success = _do_undo()
	
	if success:
		is_executed = false
	
	return success

func _do_execute() -> bool:
	"""√Ä surcharger : impl√©mentation de l'ex√©cution"""
	push_error("[Command] _do_execute() non impl√©ment√©")
	return false

func _do_undo() -> bool:
	"""√Ä surcharger : impl√©mentation de l'annulation"""
	push_error("[Command] _do_undo() non impl√©ment√©")
	return false

func get_description() -> String:
	return description
```

## shared/item_data_loader.gd

```text
# addons/core/data/item_data_loader.gd
class_name ItemDataLoader
extends Node

## Charge les donn√©es d'items depuis JSON
## Format: data/items/*.json (organis√© par cat√©gories)

const ITEMS_DIR = "res://data/items/"

var _json_loader: JSONDataLoader
var items: Dictionary = {}
var items_by_category: Dictionary = {}

func _init():
	_json_loader = JSONDataLoader.new()

func load_all_items() -> void:
	# Charge r√©cursivement (pour avoir les sous-dossiers par cat√©gorie)
	items = _json_loader.load_json_directory(ITEMS_DIR, true)
	_organize_by_category()
	
	if items.is_empty():
		push_warning("No items loaded")
	else:
		print("Loaded %d items" % _count_items(items))
		GameRoot.event_bus.emit_signal("data_loaded", "items", items)

func _organize_by_category() -> void:
	items_by_category.clear()
	_flatten_items(items, items_by_category)

func _flatten_items(source: Dictionary, target: Dictionary) -> void:
	for key in source:
		if source[key] is Dictionary:
			if source[key].has("id"):
				# C'est un item
				var item = source[key]
				target[item.id] = item
				
				var category = item.get("category", "misc")
				if not items_by_category.has(category):
					items_by_category[category] = []
				items_by_category[category].append(item)
			else:
				# C'est un dossier
				_flatten_items(source[key], target)

func _count_items(dict: Dictionary) -> int:
	var count = 0
	for key in dict:
		if dict[key] is Dictionary:
			if dict[key].has("id"):
				count += 1
			else:
				count += _count_items(dict[key])
	return count

func get_item(item_id: String) -> Dictionary:
	if items_by_category.is_empty():
		_organize_by_category()
	
	for category in items_by_category:
		for item in items_by_category[category]:
			if item.id == item_id:
				return item
	
	push_error("Item not found: " + item_id)
	return {}

func get_items_by_category(category: String) -> Array:
	if items_by_category.has(category):
		return items_by_category[category]
	return []
```

## shared/json_scenario_module.gd

```text
# scenes/battle/json_scenario_module.gd
extends Node
class_name JSONScenarioModule

## üé¨ MODULE DE SC√âNARIO 100% JSON
## Remplace LuaScenarioModule pour utiliser uniquement du JSON

# ============================================================================
# SIGNAUX
# ============================================================================

signal dialogue_started(dialogue_id: String)
signal dialogue_ended(dialogue_id: String)
signal event_triggered(event_id: String)

# ============================================================================
# DONN√âES
# ============================================================================

var scenario_data: Dictionary = {}
var triggered_events: Array[String] = []

# ‚úÖ R√©f√©rence √† la DialogueBox
var dialogue_box: DialogueBoxClass = null

# ============================================================================
# SETUP
# ============================================================================

func setup_scenario(scenario_path: String) -> void:
	"""Configure un sc√©nario depuis JSON"""
	
	var json_loader = JSONDataLoader.new()
	scenario_data = json_loader.load_json_file(scenario_path)
	
	if scenario_data.is_empty():
		push_error("[JSONScenarioModule] Erreur : impossible de charger ", scenario_path)
		return
	
	print("[JSONScenarioModule] ‚úÖ Sc√©nario charg√© : ", scenario_path)

# ============================================================================
# INTRO / OUTRO
# ============================================================================

func has_intro() -> bool:
	return scenario_data.has("intro_dialogue")

func play_intro() -> void:
	if not scenario_data.has("intro_dialogue"):
		return
	
	var dialogue_lines = scenario_data.intro_dialogue
	await _play_json_dialogue(dialogue_lines)

func has_outro() -> bool:
	return scenario_data.has("outro_victory") or scenario_data.has("outro_defeat")

func play_outro(victory: bool) -> void:
	var dialogue_key = "outro_victory" if victory else "outro_defeat"
	
	if not scenario_data.has(dialogue_key):
		return
	
	var dialogue_lines = scenario_data[dialogue_key]
	await _play_json_dialogue(dialogue_lines)

# ============================================================================
# TRIGGERS
# ============================================================================

func trigger_turn_event(turn: int, is_player: bool) -> void:
	if not scenario_data.has("turn_events"):
		return
	
	var turn_events = scenario_data.turn_events
	var turn_key = "turn_" + str(turn)
	
	if turn_events.has(turn_key):
		var event_data = turn_events[turn_key]
		await _execute_json_event(event_data)

func trigger_position_event(unit: BattleUnit3D, pos: Vector2i) -> void:
	if not scenario_data.has("position_events"):
		return
	
	var position_events = scenario_data.position_events
	var pos_key = str(pos.x) + "," + str(pos.y)
	
	if position_events.has(pos_key):
		var event_data = position_events[pos_key]
		await _execute_json_event(event_data)

# ============================================================================
# EX√âCUTION D'√âV√âNEMENTS JSON
# ============================================================================

func _execute_json_event(event_data: Dictionary) -> void:
	match event_data.get("type", ""):
		"dialogue":
			await _play_json_dialogue(event_data.get("dialogue", []))
		
		"spawn_units":
			GameRoot.event_bus.emit_signal("units_spawn_requested", event_data.get("units", []))
		
		"trigger_cutscene":
			GameRoot.event_bus.emit_signal("cutscene_requested", event_data.get("cutscene_id", ""))
		
		_:
			push_warning("[JSONScenarioModule] Type d'√©v√©nement inconnu : ", event_data.type)

# ============================================================================
# SYST√àME DE DIALOGUE
# ============================================================================

func _play_json_dialogue(dialogue_lines: Array) -> void:
	if not dialogue_box:
		push_warning("[JSONScenarioModule] DialogueBox non configur√©e")
		return
	
	# Cr√©er un DialogueData
	var dialogue_data = DialogueData.new("scenario_dialogue_" + str(Time.get_ticks_msec()))
	
	for line in dialogue_lines:
		if typeof(line) != TYPE_DICTIONARY:
			continue
		
		var speaker = line.get("speaker", "")
		var text = line.get("text", "")
		
		dialogue_data.add_line({
			"speaker": speaker,
			"text": text
			})
	
	# D√©marrer le dialogue
	GameRoot.dialogue_manager.start_dialogue(dialogue_data, dialogue_box)
	
	# Attendre la fin
	await GameRoot.dialogue_manager.dialogue_ended
```

## shared/state_machine.gd

```text
extends Node
class_name StateMachine
## Machine √† √©tats g√©n√©rique r√©utilisable
## Usage: H√©riter et d√©finir _define_states() et _define_transitions()

signal state_changed(from: String, to: String)
signal state_entered(state_name: String)
signal state_exited(state_name: String)

# ============================================================================
# √âTAT
# ============================================================================

var current_state: String = ""
var previous_state: String = ""
var states: Dictionary = {}  # state_name -> { enter: Callable, exit: Callable, process: Callable }
var transitions: Dictionary = {}  # from_state -> [allowed_to_states]

var is_active: bool = true
var debug_mode: bool = false

var current_state_name: String:
	get:
		return current_state

# ============================================================================
# INITIALISATION
# ============================================================================

func _ready() -> void:
	_define_states()
	_define_transitions()
	
	if not current_state.is_empty():
		_enter_state(current_state)

## √Ä surcharger : d√©finir les √©tats
func _define_states() -> void:
	pass  # Override in child class

## √Ä surcharger : d√©finir les transitions autoris√©es
func _define_transitions() -> void:
	pass  # Override in child class

# ============================================================================
# GESTION DES √âTATS
# ============================================================================

func add_state(state_name: String, enter: Callable = Callable(), exit: Callable = Callable(), process: Callable = Callable()) -> void:
	"""Ajoute un √©tat √† la machine"""
	states[state_name] = {
		"enter": enter,
		"exit": exit,
		"process": process
	}
	
	if debug_mode:
		print("[StateMachine] √âtat ajout√© : ", state_name)

func add_transition(from: String, to: String) -> void:
	"""Autorise une transition from -> to"""
	if not transitions.has(from):
		transitions[from] = []
	
	if to not in transitions[from]:
		transitions[from].append(to)

func can_transition(from: String, to: String) -> bool:
	"""V√©rifie si une transition est autoris√©e"""
	if not transitions.has(from):
		return false
	
	return to in transitions[from]

func change_state(new_state: String, force: bool = false) -> bool:
	"""Change l'√©tat actuel"""
	if not states.has(new_state):
		push_error("[StateMachine] √âtat inexistant : ", new_state)
		return false
	
	# V√©rifier la transition
	if not force and not can_transition(current_state, new_state):
		if debug_mode:
			push_warning("[StateMachine] Transition interdite : ", current_state, " -> ", new_state)
		return false
	
	# Exit current state
	if not current_state.is_empty():
		_exit_state(current_state)
	
	# Change state
	previous_state = current_state
	current_state = new_state
	
	# Enter new state
	_enter_state(new_state)
	
	state_changed.emit(previous_state, current_state)
	
	if debug_mode:
		print("[StateMachine] ", previous_state, " -> ", current_state)
	
	return true

func _enter_state(state_name: String) -> void:
	"""Appelle le callback d'entr√©e d'un √©tat"""
	if states[state_name].enter.is_valid():
		states[state_name].enter.call()
	
	state_entered.emit(state_name)

func _exit_state(state_name: String) -> void:
	"""Appelle le callback de sortie d'un √©tat"""
	if states[state_name].exit.is_valid():
		states[state_name].exit.call()
	
	state_exited.emit(state_name)

func _process(delta: float) -> void:
	if not is_active or current_state.is_empty():
		return
	
	if states[current_state].process.is_valid():
		states[current_state].process.call(delta)

# ============================================================================
# GETTERS
# ============================================================================

func get_current_state() -> String:
	return current_state

func get_previous_state() -> String:
	return previous_state

func is_in_state(state_name: String) -> bool:
	return current_state == state_name

func get_allowed_transitions() -> Array:
	return transitions.get(current_state, [])
```

## shared/visuals/effects/text/rainbow_effect.gd

```text
@tool
extends RichTextEffect
## RainbowEffect - Effet arc-en-ciel pour RichTextLabel
## Usage: [rainbow freq=0.2 sat=0.8 val=0.8]Texte color√©[/rainbow]

class_name RichTextRainbow

# BBCode tag
var bbcode = "rainbow"

# ============================================================================
# PROCESS
# ============================================================================

func _process_custom_fx(char_fx: CharFXTransform) -> bool:
	# Param√®tres
	var freq = char_fx.env.get("freq", 0.2)
	var sat = char_fx.env.get("sat", 0.8)
	var val = char_fx.env.get("val", 0.8)
	
	# Calcul de la couleur arc-en-ciel
	var time = char_fx.elapsed_time
	var hue = fmod(time * freq + char_fx.glyph_index * 0.1, 1.0)
	
	var color = Color.from_hsv(hue, sat, val)
	char_fx.color = color
	
	return true
```

## shared/visuals/effects/text/shake_effect.gd

```text
@tool
extends RichTextEffect
## ShakeEffect - Effet de tremblement pour RichTextLabel
## Usage: [shake rate=20 level=5]Texte tremblant[/shake]

class_name RichTextShake

# BBCode tag
var bbcode = "shake"

# ============================================================================
# PROCESS
# ============================================================================

func _process_custom_fx(char_fx: CharFXTransform) -> bool:
	# Param√®tres
	var rate = char_fx.env.get("rate", 20.0)
	var level = char_fx.env.get("level", 5.0)
	
	# Calcul du d√©calage
	var time = char_fx.elapsed_time
	var offset = Vector2(
		sin(time * rate + char_fx.glyph_index) * level,
		cos(time * rate * 1.3 + char_fx.glyph_index) * level
	)
	
	char_fx.offset += offset
	
	return true
```

## shared/visuals/effects/text/wave_effect.gd

```text
@tool
extends RichTextEffect
## WaveEffect - Effet de vague pour RichTextLabel
## Usage: [wave amp=50 freq=2]Texte ondulant[/wave]

class_name RichTextWave

# BBCode tag
var bbcode = "wave"

# ============================================================================
# PROCESS
# ============================================================================

func _process_custom_fx(char_fx: CharFXTransform) -> bool:
	# Param√®tres
	var amp = char_fx.env.get("amp", 50.0)
	var freq = char_fx.env.get("freq", 2.0)
	
	# Calcul de l'offset vertical
	var time = char_fx.elapsed_time
	var offset_y = sin(time * freq + char_fx.glyph_index * 0.5) * amp
	
	char_fx.offset.y += offset_y
	
	return true
```

## Statistics

- Total Files: 69
- Total Characters: 454952
- Total Tokens: 0
